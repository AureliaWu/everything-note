<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UI</title>
    <url>/2019/06/22/UI/UI%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="UI入门"><a href="#UI入门" class="headerlink" title="UI入门"></a>UI入门</h1><h2 id="UI设计场景"><a href="#UI设计场景" class="headerlink" title="UI设计场景"></a>UI设计场景</h2><p>网页设计、管理界面、电脑软件、车载系统、智能终端</p>
<p>UI设计的合理进阶： 联系设计 + 联系产品</p>
<h2 id="视觉层次"><a href="#视觉层次" class="headerlink" title="视觉层次"></a>视觉层次</h2><h3 id="版面层级"><a href="#版面层级" class="headerlink" title="版面层级"></a>版面层级</h3><p>页面层级： 图片 &gt; 图标 &gt; 文字</p>
<h3 id="板块凸显"><a href="#板块凸显" class="headerlink" title="板块凸显"></a>板块凸显</h3><ol>
<li>卡片式设计（凸显板块）</li>
</ol>
<p>难点： 合适的阴影设计——弥散(使用PS进行操作)</p>
<p>PS操作重点：</p>
<ul>
<li>创建圆角矩形</li>
<li>复制图层作为阴影层，缩小至90%,适当调整颜色</li>
<li>阴影层板块： 属性–&gt;蒙版–&gt;羽化30像素(可自行调节)</li>
<li>整个阴影层板块稍微下移，制造阴影效果</li>
</ul>
<ol start="2">
<li><p>增加角标(凸显细小版块)</p>
</li>
<li><p>增加标签(凸显细节)</p>
</li>
</ol>
<p>使用PS设计小标签：</p>
<ul>
<li>文字大小基本为24像素，中粗黑字体</li>
<li>左右间距一般大于上下边距，使标签设计有呼吸感</li>
</ul>
<h3 id="文字层级"><a href="#文字层级" class="headerlink" title="文字层级"></a>文字层级</h3><p>字重、颜色、特殊字体包</p>
<hr>
<p>参考视频: <a href="https://huke88.com/course/12944.html" target="_blank" rel="noopener">https://huke88.com/course/12944.html</a></p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据</title>
    <url>/2023/06/05/algorithm/bigData/</url>
    <content><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><p>内存寻址时间比IO寻址快10w倍</p>
<p>单机处理大数据的Io速度太慢，内存也太小</p>
<p>大数据技术关心的重点： </p>
<ul>
<li>分而治之</li>
<li>并行计算</li>
<li>计算向数据移动</li>
<li>数据本地化读取 </li>
</ul>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>Hadoop Distributed File System 分布式文件系统，与其他的分布式文件系统相比，Hadoop能更好的支持分布式计算。</p>
<h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><ul>
<li>文件线性按字节切割成块（block），具有offset, id</li>
<li>文件与文件的block大小可以不一样</li>
<li>一个文件除最后一个block，其他block大小一致</li>
<li>block的大小依据硬件的I/O特性调整</li>
<li>block被分散存放在集群的节点中，具有location</li>
<li>Block具有副本(replication),没有主从概念，副本不能出现在同一个节点</li>
<li>副本是满足可靠性和性能的关键</li>
<li>文件上传可以指定block的大小和副本数，上传后只能修改副本数</li>
<li>一次写入多次读取，不支持修改</li>
<li>支持追加数据</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>algorithm</tag>
        <tag>basic</tag>
        <tag>bigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据库</title>
    <url>/2019/07/24/database/oracle/</url>
    <content><![CDATA[<h1 id="Oracle的安装"><a href="#Oracle的安装" class="headerlink" title="Oracle的安装"></a>Oracle的安装</h1><h2 id="数据库和数据仓库"><a href="#数据库和数据仓库" class="headerlink" title="数据库和数据仓库"></a>数据库和数据仓库</h2><p>数据库： 对数据进行持久化存储，将数据直接存储到磁盘</p>
<ul>
<li><p>关系型数据库： </p>
<ul>
<li><p>Mysql(最常用)</p>
</li>
<li><p>Oracle(最安全)</p>
</li>
<li><p>QLserver(.net)</p>
</li>
<li><p>Db2(金融、银行)</p>
</li>
</ul>
</li>
</ul>
<h1 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h1><ol>
<li>登录：sqlplus / as sysdba</li>
<li><p>创建表空间：<code>create tablespace aezocn datafile &#39;d:/tablespace/aezo&#39; size 800m extent management local segment space management auto;</code> ，需要先建好路径 <code>d:/tablespace</code> ，最终会在该目录下建一个 AEZO 的文件(表空间之后可以修改)</p>
<ul>
<li>删除表空间：<code>drop tablespace aezocn including contents and datafiles;</code></li>
</ul>
</li>
<li>创建用户：<code>create user aezo identified by aezo default tablespace aezocn;</code></li>
<li>授权<ul>
<li><code>grant create session to aezo;</code></li>
<li><code>grant unlimited tablespace to aezo;</code></li>
<li><code>grant dba to aezo;</code> 导入导出时，只有dba权限的账户才能导入由dba账户导出的数据，因此不建议直接设置用户为dba</li>
</ul>
</li>
</ol>
<h1 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h1><p><code>.dmp</code>适合大数据导出，<code>.sql</code>适合小数据导出(表中含有CLOB类型字段则不能导出)</p>
<h2 id="命令行-4"><a href="#命令行-4" class="headerlink" title="命令行 ^4"></a>命令行 ^4</h2><ul>
<li>输入 <code>imp/exp</code> 用户名/密码 可根据提示导入导出。直接<code>cmd</code>运行。</li>
<li>成功提示 <code>Export terminated successfully [with/without warnings]</code>；失败提示 <code>Export terminated unsuccessfully [with/without warnings]</code></li>
</ul>
<h2 id="dmp格式导出导入-cmd"><a href="#dmp格式导出导入-cmd" class="headerlink" title="dmp格式导出导入(cmd)"></a>dmp格式导出导入(cmd)</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><h4 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h4><ul>
<li><p><code>exp system/manager file=d:/exp.dmp owner=scott</code> 导出scott用户的所有对象，前提是system有相关权限</p>
</li>
<li><p>远程导出：此时<code>system/manager</code>默认连接的是本地数据库。如果使用<code>exp system/manager@remote_orcl file=d:/exp.dmp owner=scott</code> (<code>remote_orcl</code>为在本地建立的远程数据库网络服务名. 即tnsnames.ora里面的配置项名称)则可导出远程数据库的相关数据，下同。或者<a href="mailto:`system/manager@192.168.1.1" target="_blank" rel="noopener">`system/manager@192.168.1.1</a>:1521/orcl`</p>
<ul>
<li>加上 <code>compress=y</code> 表示压缩数据</li>
<li>加上 <code>rows=n</code> 表示不导出数据行，只导出结构</li>
</ul>
</li>
</ul>
<h4 id="表模式"><a href="#表模式" class="headerlink" title="表模式"></a>表模式</h4><ul>
<li><p><code>exp scott/tiger file=d:/exp.dmp tables=emp</code> 导出<code>scott</code>的<code>emp</code>表</p>
<ul>
<li>导出其他用户的表：<code>exp system/manager file=d:/exp.dmp tables=scott.emp</code>, <code>scott.dept</code> 导出<code>scott</code>的<code>emp</code>、<code>dept</code>表，用户<code>system</code>需要相关权限</li>
<li><p>导出部分表数据：<code>exp scott/tiger file=d:/exp.dmp tables=emp query=\&quot; where ename like &#39;%AR%&#39;\&quot;</code></p>
</li>
<li><p>常见错误(EXP-00011)：原因为11g默认创建一个表时不分配segment，只有在插入数据时才会产生。</p>
</li>
</ul>
</li>
<li><p>导出全部：<code>exp system/manager file=d:/exp.dmp full=y</code></p>
<ul>
<li>用户 <code>system/manager</code> 必须具有相关权限</li>
<li>导出的是整个数据库，包括所有的表空间</li>
</ul>
</li>
</ul>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><h4 id="用户模式："><a href="#用户模式：" class="headerlink" title="用户模式："></a>用户模式：</h4><ul>
<li><code>imp system/manager file=d:/exp.dmp fromuser=scott touser=aezo ignore=y</code><ul>
<li><code>ignore=y</code>忽略创建错误, 不少情况下要先将表彻底删除，然后导入</li>
</ul>
</li>
</ul>
<h4 id="表模式-1"><a href="#表模式-1" class="headerlink" title="表模式"></a>表模式</h4><ul>
<li><p><code>imp system/manager file=d:/exp.dmp fromuser=scott tables=emp, dept touser=aezo ignore=y</code></p>
<ul>
<li>将<code>scott</code>的表<code>emp</code>、<code></code>dept导入到用户<code>aezo</code></li>
<li>此处 <code>file/fromuser/touser</code> 都可以指定多个</li>
</ul>
</li>
<li><p>导入全部：<code>imp system/manager file=d:/exp.dmp full=y ignore=y</code></p>
<ul>
<li>用户 <code>system/manager</code> 必须具有相关权限</li>
<li>导入的是整个数据库，包括所有的表空间</li>
</ul>
</li>
</ul>
<h1 id="Oracle报错记录"><a href="#Oracle报错记录" class="headerlink" title="Oracle报错记录"></a>Oracle报错记录</h1><h2 id="EXP-00011"><a href="#EXP-00011" class="headerlink" title="EXP-00011"></a>EXP-00011</h2><p><code>EXP-00011: XXX does not exist</code></p>
<ul>
<li>报错内容： 表XXX不存在</li>
<li>报错场景： 直接用命令行导出单张表时，执行命令 <code>exp user/psw file=d:/exp.dmp tables=emp;</code> 提示表<code>emp</code>不存在，而实际查询时此表存在且有数据</li>
<li>报错原因之一：<code>exp</code>执行语句多加了一个’<code>;</code>‘ 网上还有记录其它原因，但实际只遇到的是多加了分号，所以暂不记他人的情况</li>
<li>解决方案： 将命令中的分号去掉就好啦</li>
</ul>
<h2 id="ORA-01940"><a href="#ORA-01940" class="headerlink" title="ORA-01940"></a>ORA-01940</h2><p><code>ORA-01940: cannot drop a user that is currently connected</code></p>
<ul>
<li>报错内容： 无法删除当前已连接用户</li>
<li>报错场景： 执行<code>drop user</code>时出现此报错</li>
<li>报错原因： 有用户在连接，无法执行<code>drop</code></li>
<li>解决方案： <ul>
<li>锁定用户: <code>alter user XXX account lock;</code></li>
<li>查询进程号: <code>SELECT * FROM V$SESSION WHERE USERNAME=&#39;xxx&#39;;</code></li>
<li>删除对应的进程: <code>alter system kill session &#39;xx,xx&#39;;</code></li>
<li>删除对应用户: <code>drop user xx cascade;</code></li>
</ul>
</li>
</ul>
<h1 id="Oracle-sql语句"><a href="#Oracle-sql语句" class="headerlink" title="Oracle sql语句"></a>Oracle sql语句</h1><h2 id="将查询结果存入新表"><a href="#将查询结果存入新表" class="headerlink" title="将查询结果存入新表"></a>将查询结果存入新表</h2><p><code>create table 临时表名 as select * from table_name</code></p>
<ul>
<li><code>select * from table_name</code>表示得到查询结果的查询语句</li>
<li>此方法无需先创建表设置字段，而是会将查询结果的字段和字段类型直接赋予新表</li>
<li>此方法创建的不属于临时表，可以根据需求作为缓存表，用完可以删除</li>
</ul>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="使用plsql创建存储过程"><a href="#使用plsql创建存储过程" class="headerlink" title="使用plsql创建存储过程"></a>使用plsql创建存储过程</h2><ol>
<li><p>plsql –&gt; Objects –&gt; Procedures 右键–&gt; 新建 –&gt; 弹出框中输入存储过程的名字</p>
</li>
<li><p>书写存储过程逻辑，以下为清理作废数据的存储过程</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> clear_ycama_lock_data <span class="keyword">is</span></span><br><span class="line"><span class="keyword">cursor</span> c <span class="keyword">is</span> <span class="keyword">select</span> t.id <span class="keyword">from</span> ycama_box_lock t <span class="keyword">where</span> t.yes_status <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">type tb_records is table of c%rowtype;</span><br><span class="line">rd_records tb_records;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">open</span> c;</span><br><span class="line">  loop</span><br><span class="line">    fetch c bulk collect into rd_records limit 500;</span><br><span class="line">    forall i in 1..rd_records.count</span><br><span class="line">     <span class="keyword">delete</span> <span class="keyword">from</span> ycama_box_lock c <span class="keyword">where</span> c.id = rd_records(i).id;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line">    exit when c%notfound;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">  close c;</span><br><span class="line"><span class="keyword">end</span> clear_ycama_lock_data;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>直接执行存储过程，执行完成后，在Procedures底下会出现此存储过程</p>
</li>
<li><p>调用存储过程： 在sql窗口输入以下命令后运行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  CLEAR_YCAMA_LOCK_DATA(); // 此处为存储过程的名称，注意最后的分号;不能省略</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>参考文章</p>
<p><a href="http://blog.aezo.cn/2016/10/12/db/oracle-dba/" target="_blank" rel="noopener">http://blog.aezo.cn/2016/10/12/db/oracle-dba/</a>  (aezo blog)</p>
]]></content>
      <categories>
        <category>Database, Oracle</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Database</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2023/05/09/java/maven/</url>
    <content><![CDATA[<p>Maven：</p>
<p>项目对象模型POM</p>
<p>核心配置文件： setting.xml</p>
<p>Maven工程关系： 依赖关系、继承关系、聚合关系</p>
<h2 id="常见的插件"><a href="#常见的插件" class="headerlink" title="常见的插件"></a>常见的插件</h2><h3 id="编译器插件"><a href="#编译器插件" class="headerlink" title="编译器插件"></a>编译器插件</h3><p><code>settings.xml</code>文件里面可配置全局默认的JDK版本,<code>settings.xml</code>文件中的id不能随便取名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.4<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk14<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Repository for JDK 1.4 builds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.myhost.com/maven/jdk14<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshotPolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">snapshotPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>若不想用setting.xml中默认的JDK，可以在项目的<code>pom.xml</code>文件中添加一个编译器插件的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDK编译插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--插件坐标--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--源代码使用JDK版本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--源代码编译为class文件的版本，要与上面版本保持一致--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="资源拷贝插件"><a href="#资源拷贝插件" class="headerlink" title="资源拷贝插件"></a>资源拷贝插件</h3><p>配置文件一般都放在<code>src/main/resources</code>目录下，打包后配置文件会在<code>target/classes</code>目录中,默认情况下不放在<code>src/main/resources</code>的配置文件打包后不会存在<code>target/classes</code>目录中，若想要把指定路径下的配置文件打包到<code>target/classes</code>目录中需要添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述配置表示<code>src/main/java</code>目录下的xml文件和<code>src/main/resources</code>目录下的xml文件、properties文件都会被打包到<code>target/classes</code>中</p>
<h3 id="Tomcat插件"><a href="#Tomcat插件" class="headerlink" title="Tomcat插件"></a>Tomcat插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Tomcat插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置Tomcat监听端口--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置项目的访问路径(Application Context)--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用Tomcat插件发布部署并执行war工程的时候，需要使用启动命令，启动命令为: <code>tomcat7:run</code>.命令中的tomcat7是插件命名，由插件提供商决定。run为插件中的具体功能。</p>
<p>Tomcat是可运行插件，必须要通过命令来运行控制</p>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p><code>mvn install</code></p>
<p>本地安装，包含编译、打包、安装到本地仓库</p>
<p><code>mvn clean</code></p>
<p>清除已编译信息，删除工程中的target目录</p>
<p>常用的命令在IDEA都有可视化界面可以操作</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Ofbiz</title>
    <url>/2019/10/23/frameworks/ofbiz/</url>
    <content><![CDATA[<h1 id="Ofbiz权限设计"><a href="#Ofbiz权限设计" class="headerlink" title="Ofbiz权限设计"></a>Ofbiz权限设计</h1><h2 id="相关表"><a href="#相关表" class="headerlink" title="相关表"></a>相关表</h2><h2 id="用户登录表-user-login"><a href="#用户登录表-user-login" class="headerlink" title="用户登录表 user_login"></a>用户登录表 <code>user_login</code></h2><h2 id="安全组列表-security-group"><a href="#安全组列表-security-group" class="headerlink" title="安全组列表 security_group"></a>安全组列表 <code>security_group</code></h2><h2 id="登录用户和安全组关系表-user-login-security-group"><a href="#登录用户和安全组关系表-user-login-security-group" class="headerlink" title="登录用户和安全组关系表 user_login_security_group"></a>登录用户和安全组关系表 <code>user_login_security_group</code></h2><h2 id="权限组列表-security-permission"><a href="#权限组列表-security-permission" class="headerlink" title="权限组列表 security_permission"></a>权限组列表 <code>security_permission</code></h2><p>‘security_permission’中的数据是在 <code>xxxSecurityPermissionSeedData.xml</code>文件中配置的，<code>xxx</code>表示组件名称</p>
<h2 id="安全组与权限关系表-security-group-permission"><a href="#安全组与权限关系表-security-group-permission" class="headerlink" title="安全组与权限关系表 security_group_permission"></a>安全组与权限关系表 <code>security_group_permission</code></h2>]]></content>
      <categories>
        <category>framework,Ofbiz</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>framework</tag>
        <tag>Ofbiz</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniapp</title>
    <url>/2023/11/09/frameworks/uniapp/</url>
    <content><![CDATA[<h1 id="Uniapp开发安卓APP"><a href="#Uniapp开发安卓APP" class="headerlink" title="Uniapp开发安卓APP"></a>Uniapp开发安卓APP</h1><h2 id="离线缓存与数据持久化"><a href="#离线缓存与数据持久化" class="headerlink" title="离线缓存与数据持久化"></a>离线缓存与数据持久化</h2><p>离线缓存： 将网络请求的数据缓存到本地，用户在没有网络链接的情况下可以继续访问已缓存的数据。<br>Uniapp使用<code>uni.setStorageSync</code>和<code>uni.getStorageSync</code>来实现</p>
<blockquote>
<p>uni-app的Storage在不同端的实现不同, App端为原生的plus.storage，无大小限制，不是缓存，是持久化的</p>
</blockquote>
<h1 id="Uniapp离线打包安卓APK"><a href="#Uniapp离线打包安卓APK" class="headerlink" title="Uniapp离线打包安卓APK"></a>Uniapp离线打包安卓APK</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="一些下载"><a href="#一些下载" class="headerlink" title="一些下载"></a>一些下载</h3><ol>
<li>下载安装<code>Android Studio</code>,<a href="https://developer.android.google.cn/studio/index.html" target="_blank" rel="noopener">下载地址</a></li>
<li>下载HbuilderX最新的SDK,<a href="https://nativesupport.dcloud.net.cn/AppDocs/download/android.html#" target="_blank" rel="noopener">下载地址</a></li>
</ol>
<h3 id="HbuilderX离线打包"><a href="#HbuilderX离线打包" class="headerlink" title="HbuilderX离线打包"></a>HbuilderX离线打包</h3><ol>
<li><code>HbuilderX</code>界面选择<code>发行 -&gt; 原生APP-本地打包 -&gt; 生成本地打包APP资源</code></li>
<li>打包完成后会在控制台输出打包生成的文件地址<code>xxxx/__UNI__XXX/xxx</code>,<code>__UNI__XXX</code>是本项目对应的Appid</li>
<li>将下载的HbuilderX最新的SDK解压，使用<code>Android Studio</code>打开包中的<code>HBuilder-Integrate-AS</code>文件夹</li>
<li>将<code>HBuilder-Integrate-AS\simpleDemo\src\main\assets\apps\</code>下的所有文件删除，替换成步骤2中生成的整个<code>__UNI__XXX/</code>文件夹</li>
<li>将<code>src/main/assets/data/dcloud_control.xml</code>中的<code>APPID</code>修改为上面的<code>__UNI__XXX</code></li>
<li><code>Android Studio</code>界面选择<code>Build -&gt; Generate Signed Bundle/APK...</code>,在跳出的弹窗页面选择APK,选择<code>Next</code>,进入下一步</li>
<li>首次生成选择<code>Create new ...</code>,<code>key store path</code>要在<code>simpleDemo</code>文件夹下，可以直接放在根目录；密码和别名都可以自定义，点击<code>ok</code>开始生成签名文件<br> 注：<ul>
<li>此步骤是在生成签名文件，由于下载的Demo包是Gradle，可能会出现生成签名出错的问题，目前遇到的基本都是提示<code>invalid keystore format</code></li>
<li><code>invalid keystore format</code>很可能是因为项目本身的JDK版本和电脑环境变量的JDK版本不一致，将两者调成JDK12是可以运行的</li>
</ul>
</li>
<li>在<code>/simpleDemo/build.gradle</code>中配置信息，<code>keyAlias</code>为刚刚填写的key的别名，<code>keypassword</code>为自定义的密码，<code>StorageFile</code>为刚刚生成的文件名</li>
<li>查看刚生成的签名文件(此处以<code>test.keystore</code>为例)的签名，进入到<code>test.keystore</code>文件夹，在命令行输入<code>keytool -list -v -keystore test.keystore</code></li>
<li>步骤9中查看的签名可能只会有<code>SHA1</code>和<code>SHA256</code>两种，但实际配置时还需要<code>MD5</code>签名，则只能使用<a href="#jump">另一种方法</a>查看</li>
<li>登录UniAPP开发者中心管理应用，进入相应的应用，选择<code>各平台信息</code>标签，如果没有则自己新建一个</li>
<li>配置信息中的包名需要填写在<code>/simpleDemo/build.gradle</code>文件的<code>applicationId</code>中</li>
<li>填写步骤10中的<code>MD5</code>信息、<code>SHA1</code>信息、<code>SHA256</code>信息，提交后会生成对应的APPKey</li>
<li>将生成的APPKey填入<code>src/main/AndroidManifest.xml</code>的<code>android:value</code></li>
<li><code>\src\main\res\drawable</code>文件夹下的<code>icon.png</code>、<code>push.png</code>、<code>splash.png</code>分别对应APP的logo、消息推送logo、启动页图片，可改成自定义</li>
<li>在<code>\src\main\res\values\strings.xml</code>中修改APP的名称</li>
<li><code>Android Studio</code>界面选择<code>Build -&gt; Build Bundle(s)/APK(s) -&gt; Build APK(s)</code>开始打包</li>
<li>打包后的文件位置在<code>\build\outputs\apk\debug\simpleDemo-debug.apk</code>(<code>\release\simpleDemo-release.apk</code>不是自定义的apk包，为啥？？？有待继续研究)</li>
</ol>
<h4 id="查看签名文件的SHA1-SHA256-MD5信息"><a href="#查看签名文件的SHA1-SHA256-MD5信息" class="headerlink" title="查看签名文件的SHA1 SHA256 MD5信息"></a><span id="jump">查看签名文件的<code>SHA1</code> <code>SHA256</code> <code>MD5</code>信息</span></h4><p>生成<code>test.keystore</code>文件后，在<code>Android Studio</code>的<code>HBuilder-Integrate-AS</code>项目根目录下打开终端，输入<code>./gradlew signingReport</code>命令</p>
<p>正常情况下能获取到<code>SHA1</code> <code>SHA256</code> <code>MD5</code>信息，如果报错则查看jdk版本是否一致</p>
<p><strong>如果修改过环境变量，需要重启<code>Android Studio</code>再操作</strong></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol>
<li><a href="https://blog.csdn.net/qq_26282869/article/details/127012224" target="_blank" rel="noopener">uniapp离线打包安卓APP全过程</a></li>
<li><a href="https://nativesupport.dcloud.net.cn/AppDocs/download/android.html#" target="_blank" rel="noopener">HBuilderX离线SDK (Android)</a></li>
<li><a href="https://blog.csdn.net/m0_62059090/article/details/127425912" target="_blank" rel="noopener">Android 连接第三方模拟器</a></li>
<li><a href="https://blog.csdn.net/Ysmooth_Alone/article/details/130176427" target="_blank" rel="noopener">uniapp离线打包在Android Studio创建的jsk证书无法获取MD5的问题</a></li>
</ol>
]]></content>
      <categories>
        <category>framework,Uniapp</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>framework</tag>
        <tag>Uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>面向面试查漏补缺</title>
    <url>/2020/08/18/java/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组相当于是一种数据结构，很多数据在进行存储的时候需要使用数组</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度： <code>O(n^2)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 冒泡排序: 前一个数字与后一个数字比较，若后者大于前者，两者交换</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length -<span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>平均时间复杂度：O(n2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 选择排序:</span></span><br><span class="line"><span class="comment">* 在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；</span></span><br><span class="line"><span class="comment">* 第二次遍历n-2个数，找到最小的数值与第二个元素交换；</span></span><br><span class="line"><span class="comment">* ...</span></span><br><span class="line"><span class="comment">* 第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取最小值下标</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; arr[j]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[k]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>平均时间复杂度：O(n2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 插入排序：</span></span><br><span class="line"><span class="comment">* 假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。</span></span><br><span class="line"><span class="comment">* 如此反复循环，直到全部排好顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 第n个数小于前n-1已排好序的数组的最后一位，换位</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第n个数大于前n-1已排好序的数组的最后一位，直接跳过进入第n+1个数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序：</span></span><br><span class="line"><span class="comment"> * 采用分治策略</span></span><br><span class="line"><span class="comment"> * 1．先从数列中取出一个数作为基准数。</span></span><br><span class="line"><span class="comment"> * 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</span></span><br><span class="line"><span class="comment"> * 3．再对左右区间重复第二步，直到各区间只有一个数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin 排序起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 排序最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[begin];<span class="comment">// 定义数组最左边一个数为基准值</span></span><br><span class="line">    <span class="keyword">boolean</span> rtl = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = begin;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rtl) &#123;</span><br><span class="line">            <span class="comment">// 从右往左移动，将右边的值与基准值比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[right] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 若右边的值小于基准值，将右边的值填入左边的位置上，左指针向后移动</span></span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                left++;</span><br><span class="line">                rtl = <span class="keyword">false</span>;<span class="comment">// 移动左指针</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右边的值大于基准值，右指针向前移动</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从左往右，将左边的值与基准值比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[left] &gt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 若左边的值大于基准值，将左边的值填入右指针位置，右指针向前移动</span></span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">                right--;</span><br><span class="line">                rtl = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            arr[left] = pivot;</span><br><span class="line">            <span class="comment">// 分别对左右数组排序</span></span><br><span class="line">            <span class="keyword">if</span>(left-<span class="number">1</span> &gt;= begin) &#123;</span><br><span class="line">                quickSort(arr, begin, left-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right+<span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">                quickSort(arr, right+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="常用的消息队列"><a href="#常用的消息队列" class="headerlink" title="常用的消息队列"></a>常用的消息队列</h2><p><code>ActiveMQ</code> <code>rabbitMQ</code> <code>rocketMQ</code> <code>kafka</code></p>
<h3 id="activeMQ"><a href="#activeMQ" class="headerlink" title="activeMQ"></a>activeMQ</h3><h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><h4 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h4><p>答题思路： 你们公司有什么业务场景，这个场景有什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多好处</p>
<p><strong>面试技巧</strong>： 考虑下你负责的系统中是否有类似场景，就是一个系统或者一个模块调用了多个系统或者模块，互相之间的调用很复杂， 维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的。你就需要去考虑在你的项目中，是不是可以运用这个MQ去进行系统的解释</p>
<ul>
<li>消息队列的常用场景： 解耦、异步、削峰</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>basic</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2019/06/13/microservice/docker/</url>
    <content><![CDATA[<h1 id="下载、安装及设置-win10"><a href="#下载、安装及设置-win10" class="headerlink" title="下载、安装及设置(win10)"></a>下载、安装及设置(win10)</h1><ol>
<li>进入官网进行下载，下载地址: <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></li>
</ol>
<p><img src="/data/img/docker/docker_download.png" alt="docker下载"></p>
<p>最新版需要登录下载，懒得找免登录下载方法，直接注册了个账号,点击<code>Get Docker</code>就可以下载啦~下载完就是傻瓜安装，一路next,下载+安装成就达成!</p>
<ol start="2">
<li>打开cmd，输入<code>docker version</code>，出现以下页面表示成功~</li>
</ol>
<p><img src="/data/img/docker/docker_version.jpg" alt="docker下载验证"></p>
<ol start="3">
<li>更换镜像地址(网上搜来的，暂时不知为啥要设)</li>
</ol>
<p>安装完成后启动可爱的小鲸鱼~首次打开会提示要设置<code>Hyper-V</code>，点击确定后电脑自动重启。本部分忘记截图。重启后会在右下角出现萌萌的小鲸鱼图标~~ <img src="/data/img/docker/docker_start_logo.png" alt="docker启动图标"></p>
<p>右击图标,选择<code>setting</code>,选择<code>Deamon</code>,在<code>Registry mirrors</code>中填入镜像地址:<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p>
<p><img src="/data/img/docker/docker_setting.png" alt="docker镜像设置"></p>
<p>设置完毕后docker会自动重启,打开cmd命令,输入<code>docker run hello-world</code>,出现以下页面表示成功</p>
<p><img src="/data/img/docker/docker_mirror.png" alt="docker镜像设置验证"> </p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>业务需要，一脸懵逼的安装好了docker，接下来就是一脸懵逼的应用~</p>
<h2 id="使用Docker打包Maven项目镜像"><a href="#使用Docker打包Maven项目镜像" class="headerlink" title="使用Docker打包Maven项目镜像"></a>使用Docker打包Maven项目镜像</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>Docker</li>
<li>一个SpringBoot项目</li>
<li>一个镜像仓库</li>
</ul>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li>创建Harbor项目<ul>
<li>在公司的Harbor仓库中新建一个项目,用于存放本次打包的镜像文件</li>
</ul>
</li>
<li>配置SpringBoot项目(添加docker配置)<ul>
<li>在<code>pom.xml</code>中引入docker依赖<br><img src="/data/img/docker/docker_mirror.png" alt="docker镜像设置验证"> </li>
</ul>
</li>
</ol>
<p>1.创建harbor项目</p>
<p>2.配置springboot项目</p>
<p>3.配置本地docker的insecure-registries</p>
<p>4.配置maven的setting.xml中server</p>
<h2 id="使用docker打包ofbiz项目"><a href="#使用docker打包ofbiz项目" class="headerlink" title="使用docker打包ofbiz项目"></a>使用docker打包ofbiz项目</h2><p>不是我打包的，我不知道怎么配置啊。。。o(╥﹏╥)o</p>
<p>直接运行<code>_docker_depoly</code>,此名称为自定义，可修改，至于在哪定义的，emmm… …</p>
<p><img src="/data/img/docker/docker_ofbiz.png" alt="docker打包ofbiz"> </p>
<p>前人铺路，后人踩坑，于是一运行就有了问题。</p>
<p>// 过几天再更新，emmm…</p>
<h3 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h3><ol>
<li>提示用户</li>
</ol>
]]></content>
      <categories>
        <category>microservice,Docker</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>microservice</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2019/06/13/microservice/microservice/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>SOA： Service Oriented Architecture，面向服务的架构<br>业务服务(business service)</p>
<p>前台访问服务：<br>客户端UI–&gt;API Gateway –&gt;访问后台服务</p>
<p>服务之间互相调用：<br>IPC(Inter Process Communication)</p>
<p>REST（JAX-RS，Spring Boot）</p>
<p>RPC（Thrift, Dubbo）</p>
<p>异步消息调用(Kafka, Notify)</p>
]]></content>
      <categories>
        <category>microservice</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>microservice</tag>
      </tags>
  </entry>
  <entry>
    <title>uni-app</title>
    <url>/2019/08/25/frontend/uni-app/</url>
    <content><![CDATA[<h1 id="uni-app笔记"><a href="#uni-app笔记" class="headerlink" title="uni-app笔记"></a>uni-app笔记</h1><h2 id="uni-app介绍"><a href="#uni-app介绍" class="headerlink" title="uni-app介绍"></a>uni-app介绍</h2><p><code>uni-app</code> 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="下载编辑器HBuilderX"><a href="#下载编辑器HBuilderX" class="headerlink" title="下载编辑器HBuilderX"></a>下载编辑器HBuilderX</h3><p>HBuilderX，以下简称HX， HX是轻量编辑器和强大IDE的完美结合体。敏捷的性能，清爽的界面，强大的功能和于一身。HX是通用的前端开发工具，但为uni-app做了特别强化。<br>下载App开发版，可开箱即用；如下载标准版，在运行或发行uni-app时，会提示安装uni-app插件，插件下载完成后方可使用。因此，直接下载APP版比较方便。</p>
<p>下载地址： <a href="https://www.dcloud.io/hbuilderx.html" target="_blank" rel="noopener">https://www.dcloud.io/hbuilderx.html</a></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h2 id="页面样式与布局"><a href="#页面样式与布局" class="headerlink" title="页面样式与布局"></a>页面样式与布局</h2><p>flex布局？</p>
<p>尺寸和单位： H5适配，宽度使用百分比，高度使用px<br>uniapp 基准宽度为750px，设计稿1px与框架样式1px转换公式： 设计稿 1px / 设计稿基准宽度 = 框架样式 1px / 750px</p>
<p>内联样式，直接在页面使用style,写在app.vue会应用于所有页面</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="pages-json"><a href="#pages-json" class="headerlink" title="pages.json"></a>pages.json</h3><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"pages"</span>: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"path"</span>: <span class="string">"pages/index/index"</span>,</span><br><span class="line">			<span class="attr">"style"</span>: &#123;</span><br><span class="line">				<span class="attr">"navigationBarTitleText"</span>: <span class="string">"uni-app"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"globalStyle"</span>: &#123;</span><br><span class="line">		"navigationBarTextStyle": "black",// 导航栏文字颜色</span><br><span class="line">		"navigationBarTitleText": "uni-app",</span><br><span class="line">		"navigationBarBackgroundColor": "#F8F8F8",</span><br><span class="line">		"backgroundColor": "#F8F8F8"</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pages</code>每新建一个页面需要配置一次，放在第一个表示入口页面<br><code>pages.styles</code> 每个页面个性化背景颜色等配置</p>
<h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><p>color: 文字颜色<br>selectedColor: 选中颜色<br>list: 配置文件路径、图标、名称等</p>
<p>最多只能放五个小图标</p>
<h4 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h4><p>启动模式配置，仅开发期间生效，用户检查传值？</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><p><code>App.vue</code>文件中的<code>onLaunch</code> <code>onShow</code> <code>onHide</code> 表示的是整个应用的生命周期，进入应用–&gt;显示应用–&gt;关闭应用</p>
<p><code>onLaunch</code>全局只触发一次，可在此处获取用户操作的场景值，如进入主程序、扫码进入程序…</p>
<h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p>每个页面自己的生命周期：  <code>onLoad</code> <code>onReady</code> <code>onShow</code> <code>onHide</code> 等</p>
<p><code>onLoad</code>： 页面初始化，执行一次</p>
<p><code>onShow</code>: 页面进入执行，进入多次，执行多次</p>
<p><code>onReady</code>: 页面加载完毕，执行一次</p>
<p><code>onHide</code>: 页面离开执行，离开多次，执行多次</p>
<p><code>onPullDownRefresh</code>: 监听用户下拉动作</p>
<pre><code>- 需要在 `pages.json` 里，找到的当前页面的`pages`节点，并在 `style` 选项中开启 `enablePullDownRefresh`。

- 当处理完数据刷新后，`uni.stopPullDownRefresh` 可以停止当前页面的下拉刷新。
</code></pre><p><code>onShareAppMessage</code>: 用户点击右上角分享</p>
<h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>写在组件中。</p>
<p><code>beforeMount</code>: 在挂载开始之前被调用</p>
<p><code>mounted</code>: 挂载到实例上之后调用</p>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><h3 id="跳转至tabbar中配置的页面"><a href="#跳转至tabbar中配置的页面" class="headerlink" title="跳转至tabbar中配置的页面"></a>跳转至tabbar中配置的页面</h3><p><code>uni.switchTab(OBJECT)</code></p>
<p><code>OBJECT</code>参数: </p>
<ul>
<li><p><code>url</code> </p>
<p>  需要跳转的 tabBar 页面的路径（需在 pages.json 的 tabBar 字段定义的页面），路径后不能带参数</p>
</li>
<li><p><code>success</code>  </p>
<p>  接口调用成功的回调函数</p>
</li>
<li><p><code>fail</code> </p>
<p>  接口调用失败的回调函数</p>
</li>
<li><p><code>complete</code></p>
<p>  接口调用结束的回调函数（调用成功、失败都会执行）</p>
</li>
</ul>
<h3 id="跳转至非tabbar中配置的页面"><a href="#跳转至非tabbar中配置的页面" class="headerlink" title="跳转至非tabbar中配置的页面"></a>跳转至非tabbar中配置的页面</h3><h4 id="navigateTo"><a href="#navigateTo" class="headerlink" title="navigateTo"></a>navigateTo</h4><p><code>uni.navigateTo(OBJECT)</code></p>
<p>不关闭当前页，跳转至新页面。如列表页跳到详情页</p>
<p><code>OBJECT</code>参数： </p>
<ul>
<li><p><code>url</code>    </p>
<p>  需要跳转的应用内非<code>tabBar</code>的页面的路径 , 路径后可以带参数。<br>  参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；</p>
</li>
<li><p><code>animationType</code>    </p>
<p>  默认值为<code>pop-in</code>，表示窗口显示的动画效果</p>
</li>
<li><p><code>animationDuration</code></p>
<p>  窗口动画持续时间，单位为ms</p>
</li>
<li><p><code>success</code>    </p>
<p>  接口调用成功的回调函数    </p>
</li>
<li><p><code>fail</code></p>
<p>  接口调用失败的回调函数    </p>
</li>
<li><p><code>complete</code></p>
<p>  接口调用结束的回调函数（调用成功、失败都会执行）</p>
</li>
</ul>
<h4 id="redirectTo"><a href="#redirectTo" class="headerlink" title="redirectTo"></a>redirectTo</h4><p><code>uni.redirectTo(OBJECT)</code></p>
<p>关闭当前页面，跳转新页面</p>
<h2 id="模板语法和数据绑定"><a href="#模板语法和数据绑定" class="headerlink" title="模板语法和数据绑定"></a>模板语法和数据绑定</h2><p>声明在data中的数据是响应式绑定</p>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>使用 <code>v-for</code>属性</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>使用 <code>v-if</code> 或 <code>v-hidden</code>属性</p>
<p><code>v-if</code> 根据条件进行渲染<br><code>v-hidden</code> 根据条件进行展示，类似于<code>v-show</code></p>
<h2 id="class-和-style-的绑定"><a href="#class-和-style-的绑定" class="headerlink" title="class 和 style 的绑定"></a>class 和 style 的绑定</h2><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>class支持的语法 <code>:class</code><br>style支持的语法 <code>:style</code></p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>事件映射表：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>uni-app中没有什么默认事件，比如submit不会自动提交</p>
<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p><code>view</code> : 视图区域<br><code>scroll-view</code> : 滚动区域<br><code>swiper</code> : 轮播区域</p>
<h2 id="uni-app中的请求"><a href="#uni-app中的请求" class="headerlink" title="uni-app中的请求"></a>uni-app中的请求</h2><hr>
<p>官方地址： <a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">https://uniapp.dcloud.io/README</a></p>
<p>参考视频: <a href="https://www.bilibili.com/video/av48272338?from=search&amp;seid=7223491785740158297" target="_blank" rel="noopener">https://www.bilibili.com/video/av48272338?from=search&amp;seid=7223491785740158297</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>vue</category>
        <category>uni-app</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>web</tag>
        <tag>vue</tag>
        <tag>uni-app</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3</title>
    <url>/2023/07/21/python/python%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在Mac上安装Python3"><a href="#在Mac上安装Python3" class="headerlink" title="在Mac上安装Python3"></a>在Mac上安装Python3</h2><p>方法一： 从Python官网下载Python3 <code>https://www.python.org/downloads/</code>，下载完成后双击运行并安装</p>
<p>方法二： 如果安装了Homebrew,直接通过命令<code>brew install python3</code>安装即可,若要指定版本，使用命令<code>brew install --build-from-source python@3.8</code></p>
<h3 id="使用Homebrew安装可能出的错"><a href="#使用Homebrew安装可能出的错" class="headerlink" title="使用Homebrew安装可能出的错"></a>使用Homebrew安装可能出的错</h3><p>Mac升级为macOS Big Sur系统11.1之后，需要先升级Homebrew，否则使用<code>brew</code>命令时会报错 <code>Version value must be a string; got a NilClass ()</code></p>
<p>Homebrew升级命令： <code>brew update-reset</code></p>
<p>查看Homebrew版本命令： <code>brew --version</code></p>
<p>查看python3版本的命令： <code>python3 --version</code></p>
<h1 id="Mac直接运行-py文件"><a href="#Mac直接运行-py文件" class="headerlink" title="Mac直接运行.py文件"></a>Mac直接运行<code>.py</code>文件</h1><ol>
<li>在<code>.py</code>文件的第一行加特殊的注释: <code>#!/usr/bin/env python3</code></li>
<li>通过命令行给文件以执行权限 <code>chmod a+x xx.py</code></li>
</ol>
<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><ul>
<li>以<code>#</code>开头的语句是注释，每一行都是一个语句，当语句以<code>:</code>冒号结尾时，缩进的语句视为代码块</li>
<li>Python程序大小写敏感</li>
</ul>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数、浮点数、字符串、布尔值、空值、列表、字典、自定义数据类型</p>
<ul>
<li>使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li>
<li>使用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li>
<li>空值是Python里的一个特殊的值，用<code>None</code>表示</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Python中，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而而且可以是不同类型的变量。</p>
<p>这种本身类型不固定的语言称之为<code>动态语言</code>,与之对应的是<code>静态语言</code>静态语言在定义变量时必须指定变量类型，如Java语言。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Python源代码是一个文本文件，当源代码中包含中文的时候，保存源代码时就务必要指定保存为UTF-8编码；当Python解释器读取源代码时，为了让它按UTF-8编码读取，通常在文件开头写上以下两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略此注释</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则在源代码中写的中文输出可能会有乱码</p>
<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>Python中采用的格式化方式和C语言是一致的，用<code>%</code>实现</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">'hello, %s' % 'world' --&gt; hello, world</span><br><span class="line"></span><br><span class="line">'Hi, %s, you have $%d.' % ('Michael', 10000) --&gt; Hi, Michael, you have $10000.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%s</code>表示用字符串替换</li>
<li><code>%d</code>表示用整数替换</li>
<li><code>%f</code>表示用浮点数替换</li>
<li><code>%x</code>表示用十六进制整数替换</li>
</ul>
<p><strong>格式化整数和浮点数还可以指定是否补0和整数与小数的位数</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print('%2d-%02d' % (3,1)) --&gt; '3-01'</span><br><span class="line"></span><br><span class="line">print('%.2f' % 3.1415926) --&gt; '3.14'</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表： list</p>
<p>list是一个有序的集合，可以随时添加和删除其中的元素</p>
<p>list.len() 获得list中元素的个数</p>
<p>list[index] 访问每一个指定位置的元素</p>
<p>list.append(xx) 将元素追加到list末尾</p>
<p>list.insert(index, xx) 将元素插入到索引号为index的位置</p>
<p>list.pop() 删除list末尾的元素</p>
<p>list.pop(index) 删除指定位置的元素</p>
<p><strong>list里面的元素数据类型可以不同，也可以是另一个list</strong></p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种有序列表叫元组： tuple</p>
<p>tuple和list非常类似，但是tuple一旦初始化就不能修改，没有<br><code>append()</code> <code>insert()</code>这样的方法</p>
<p><code>t = ()</code> 定义一个空的tuple</p>
<p>list和tuple是Python内置的有序组合，一个可变一个不可变。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><code>if: ... elif: ... else: ...</code></p>
<p><code>elif</code>是<code>else if</code> 的缩写</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for...in</code> 依次把list或tuple中的每个元素迭代出来</p>
<p><code>range()</code>函数可以申请改成一个整数序列，<code>range(5)</code>表示生成的序列是从0开始小于5的整数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">list(range(5)) --&gt; [0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>只要满足条件就会不断循环</p>
<p>使用<code>break</code>可提前退出循环</p>
<p>使用<code>continue</code>可跳过当前循环直接开始下次循环</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Python内置了字典：<code>dict</code>，全称<code>dictionary</code>,使用键值对存储，具有极快的查找速度</p>
<p>如果key不存在，dict就会报错，为避免key不存在的错误，有两种办法：</p>
<ul>
<li>通过使用<code>xx in dict</code>判断key是否存在</li>
<li>通过dict.get(xx)，如果key不存在可以返回None或者自己指定的value</li>
</ul>
<p>返回None的时候，Python的交互环境不显示结果</p>
<p>使用dict.pop(key)会将key对应的键值对一起删除</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。set中没有重复的key.</p>
<p>要创建一个set，需要提供一个list作为输入集合，重复元素在set中会被自动过滤</p>
<p>set.add(key) 添加元素到set中，可以重复添加，但是不会有效果</p>
<p>set.remove(key) 删除元素</p>
<p>set可以看成是数学意义上的无需和无重复元素的集合</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数就是最基本的一种代码抽象的方式</p>
<p>Python内置了很多函数可以直接调用，使用函数名和参数就能直接调用函数。</p>
<p>abs() 求绝对值函数</p>
<p>max() 接收任意多个参数并返回最大的那个</p>
<p>int() 把其他数据类型转换成整数</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>使用<code>def</code>语句定义一个函数，依次写出函数名、括号、括号中的参数、冒号，然后在缩进块在红编写函数体，函数的返回值用<code>return</code>语句返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p>如果想定义一个什么也不做的空函数，可以用pass语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>pass</code>可以用来作为一个占位符让代码先运行起来</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>basic</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/2019/05/12/others/hello-world/</url>
    <content><![CDATA[<p>我的第一篇文章</p>

<h2 id="github-jeykll-markdown个人书写习惯"><a href="#github-jeykll-markdown个人书写习惯" class="headerlink" title="github-jeykll-markdown个人书写习惯"></a>github-jeykll-markdown个人书写习惯</h2><blockquote>
<p>2017-07-01 之后使用hexo书写博客, 格式依然可用</p>
</blockquote>
<h3 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h3><p>categories和tags都可以有多个</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">categories: [cat1, cat2]</span><br><span class="line">tags: [tag1, tag2, tag3]</span><br></pre></td></tr></table></figure>
<h3 id="md语法"><a href="#md语法" class="headerlink" title="md语法"></a>md语法</h3><ul>
<li>md文件中可以使用html标签</li>
<li><code>---</code>代表分割线</li>
</ul>
<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>正文的第一级标题用h2(<code>##</code>)，标题和字段间要有换行</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li><p>列表（有序/无序）下面显示 <strong>代码、引用、图片</strong> 时：相对列表的该子项代码需要多缩进一个Tab（4个空格），且中间要空行，如：</p>
<pre>
- 标题

  &#x60;&#x60;&#x60;html
    ...
  &#x60;&#x60;&#x60;
</pre></li>
<li><p>引用需要上下都空一行，列表只需要在上面空一行</p>
</li>
<li><p>子列表基于父列表要有一个Tab缩进（4个空格），中间无需空行</p>
</li>
</ul>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注支持链接跳转，注意脚注与被批注文本之间有一个空格</p>
<pre>
标题或者文字 [^1]

---

参考文章

[^1]: [http://blog.aezo.cn](http://blog.aezo.cn)
</pre>


<h2 id="github-hexo-markdown个人书写习惯"><a href="#github-hexo-markdown个人书写习惯" class="headerlink" title="github-hexo-markdown个人书写习惯"></a>github-hexo-markdown个人书写习惯</h2><h3 id="修改文章后保存源码并更新博客"><a href="#修改文章后保存源码并更新博客" class="headerlink" title="修改文章后保存源码并更新博客"></a>修改文章后保存源码并更新博客</h3><ul>
<li><p><strong>更新步骤如下</strong> (或者直接执行项目目录下的<strong>blog-deploy.sh</strong>文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean # 有时候修改了静态文件需要先clean一下</span><br><span class="line"><span class="meta">$</span> git add .</span><br><span class="line"><span class="meta">$</span> git commit -am "update blog"</span><br><span class="line"><span class="meta">$</span> git push origin master:source</span><br><span class="line"><span class="meta">$</span> hexo g &amp;&amp; gulp &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="博客源码管理和博客更新"><a href="#博客源码管理和博客更新" class="headerlink" title="博客源码管理和博客更新"></a>博客源码管理和博客更新</h3><ul>
<li>本地处于master分支，远程有master(为博客渲染后的代码)和source(博客源码, 可设为远程默认分支)两个分支</li>
<li><p>更新博客 <code>hexo d -g</code></p>
<ul>
<li><p><code>_config.yml</code>文件中需要指向master分支</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/aezocn/aezocn.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><code>hexo clean</code> 清除缓存(如果未修改配置文件可不运行)</li>
<li><code>hexo g</code>/<code>hexo generate</code> 静态文件生成(修改主题文件可不用重新启动服务)</li>
<li><code>hexo s -p 5000</code>(<code>hexo server</code>) <strong>启动本地服务器(本地测试)</strong></li>
<li><code>hexo d</code>/<code>hexo deploy</code> 部署到github</li>
</ul>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><ul>
<li>clone远程source分支到本地master分支</li>
<li><code>npm install -g hexo-cli</code> 全局安装hexo</li>
<li><code>npm install</code> 初始化</li>
<li>按照上述【修改文章后保存源码并更新博客】进行部署</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>图片格式如：<code>![hello](/data/images/2017/07/hello.png)</code></li>
<li>内部链接格式如：<code>[http://blog.aezo.cn/2017/01/16/arch/nginx/](/_posts/arch/nginx.md#基于编译安装tengine)</code>，其中<code>#</code>后面为完整子标题</li>
<li>hexo转义字符：<code>{: &amp;#123;</code>、<code>}: &amp;#125;</code> (如写vue代码的时会出现双括号导致hexo编译失败)</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul>
<li>NexT主题本地搜索<ul>
<li>安装：<code>npm install --save hexo-generator-search</code></li>
<li>开启local_search</li>
<li>还可手动写本地搜索功能 <a href="http://www.hahack.com/codes/local-search-engine-for-hexo/" title="jQuery-based Local Search Engine for Hexo" target="_blank" rel="noopener">^1</a></li>
</ul>
</li>
<li>基于Swiftype的搜索</li>
</ul>
<h4 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h4><ul>
<li><code>npm install --save hexo-filter-plantuml</code> 安装插件(vscode可以再配合插件<code>PlantUML</code>使用)</li>
<li>markdown语法如下</li>
</ul>
<pre>
&#x60;&#x60;&#x60;plantuml
@startuml
/' 样式(背景和波浪线条)和标题。这是代码注释，不会渲染 '/
skinparam backgroundColor #EEEBDC
skinparam handwritten true
title
  标题和水印 &lt;img:http://blog.aezo.cn/aezocn.png&gt;
end title

Bob->Alice : hello
@enduml
&#x60;&#x60;&#x60;
</pre>

<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><ul>
<li>自定义代码在<code>/themes/next/layout/_custom/</code>目录下</li>
<li>footer代码修改 <code>/themes/next/layout/_partials/footer.swig</code></li>
<li>部分图片禁用fancybox，可在img上加<code>class=&quot;nofancybox&quot;</code>。需要修改主题中的js文件，详细修改方法参考<a href="https://blog.csdn.net/cddchina/article/details/79764432" target="_blank" rel="noopener">https://blog.csdn.net/cddchina/article/details/79764432</a></li>
</ul>
<hr>
<p>参考文章</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>坦克大战</title>
    <url>/2023/06/06/projects/tank/</url>
    <content><![CDATA[<h1 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Frame f = <span class="keyword">new</span> Frame(); <span class="comment">// 新建Frame类</span></span><br><span class="line">f.setSize(<span class="number">800</span>, <span class="number">600</span>);<span class="comment">// 设置窗口大小</span></span><br><span class="line">f.setResizable(<span class="keyword">false</span>);<span class="comment">// 设置窗口不能调整大小</span></span><br><span class="line">f.setTitle(<span class="string">"Tank War"</span>);<span class="comment">// 设置窗口名称</span></span><br><span class="line">f.setVisible(<span class="keyword">true</span>);<span class="comment">// 设置窗口可见</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加窗口监听事件</span></span><br><span class="line">f.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">    <span class="comment">// 添加窗口关闭事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="坦克大战"><a href="#坦克大战" class="headerlink" title="坦克大战"></a>坦克大战</h1><h2 id="创建TankFrame类继承Frame类"><a href="#创建TankFrame类继承Frame类" class="headerlink" title="创建TankFrame类继承Frame类"></a>创建TankFrame类继承Frame类</h2><p><code>public class TankFrame extends Frame {}</code></p>
<h2 id="在构造函数中设置默认值"><a href="#在构造函数中设置默认值" class="headerlink" title="在构造函数中设置默认值"></a>在构造函数中设置默认值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    setResizable(<span class="keyword">false</span>);</span><br><span class="line">    setTitle(<span class="string">"Tank War"</span>);</span><br><span class="line">    setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    addKeyListener(<span class="keyword">new</span> KeyListener());<span class="comment">// 监听键盘按键事件</span></span><br><span class="line"></span><br><span class="line">    addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建内部类KeyListener控制键盘按键"><a href="#创建内部类KeyListener控制键盘按键" class="headerlink" title="创建内部类KeyListener控制键盘按键"></a>创建内部类KeyListener控制键盘按键</h2><p><code>class KeyListener extends KeyAdapter {}</code></p>
<p>重写KeyAdapter类中的<code>keyPressed()</code>和<code>keyReleased()</code>方法</p>
<h2 id="判断两个方块相交"><a href="#判断两个方块相交" class="headerlink" title="判断两个方块相交"></a>判断两个方块相交</h2><p>使用工具类Rectangle,<code>Rectangle.intersects()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rectangle rect1 = <span class="keyword">new</span> Rectangle(x, y, WIDTH, HEIGHT);</span><br><span class="line">Rectangle rect2 = <span class="keyword">new</span> Rectangle(x2, y2, WIDTH2, HEIGHT2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rect1.intersects(rect2)) System.out.println(<span class="string">"两者相交"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="坦克大战中的设计模式"><a href="#坦克大战中的设计模式" class="headerlink" title="坦克大战中的设计模式"></a>坦克大战中的设计模式</h2><ol>
<li><p>单例模式</p>
<p> 应用场景：只需要一个实例 比如各种各样的manager、Factory</p>
<ul>
<li><p>饿汉式</p>
<p>  类加载到内存后就实例化一个单例，JVM保证线程安全，缺点是无论是否会用都会在类装载完成时完成实例化</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- 懒汉式

    按需使用

    - 多线程使用不安全写法

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    - 多线程使用安全写法

        类加载时不会产生实例，只有在调用`getInstance()`时调用静态内部类会实例化对象

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonDemo INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonDemoHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    - 目前语法上最完美的写法，既能解决线程同步问题，还能防止反序列化

        调用时直接使用 `SingletonDemo.INSTANCE`

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    枚举类没有构造方法，所以能防止反序列化

实际使用时常用的还是饿汉式
</code></pre><ol start="2">
<li><p>策略模式</p>
<p> <code>Comparator</code>接口 和 <code>Comparable</code>接口</p>
<ul>
<li><p><code>Comparator</code>接口是java.util包内的接口，包含两个抽象方法： <code>compare(o1，o2)</code>和<code>equals(obj)</code></p>
</li>
<li><p><code>Comparable</code>接口是java.lang包内的接口，只有一个方法： <code>compareTo(obj)</code></p>
<p>开闭原则： 对修改关闭，对扩展开放</p>
<p>实现<code>Comparable</code>接口时只能有一个compareTo方法</p>
</li>
</ul>
</li>
<li><p>工厂模式</p>
<p> 简单工厂和静态工厂</p>
<p> 任何产生对象的方法或类都可以称为工厂</p>
<p> 形容词用接口，名词用抽象类</p>
<p> 工厂模式更好的方法是spring里面的bean工厂</p>
<p> 坦克大战里面利用抽象工厂完成一键风格替换</p>
<p> 父类抽象方法时，方法要尽量少，因为父类方法越多实现时子类就会要覆写越多</p>
<p> 生产一系列的类是抽象工厂</p>
<p> 抽象工厂在实际的开发过程中使用的不是特别多</p>
</li>
</ol>
<ol start="4">
<li><p>facade模式（门面模式）</p>
</li>
<li><p>Mediator模式(调停者模式)</p>
</li>
<li><p>责任链模式</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>面向对象设计时，慎用继承关系，因为继承是一种强关系，父类变了，子类必须变。</li>
</ol>
<p>强关系对于代码的扩展性是有局限的。</p>
<ol start="2">
<li>Java转exe需要java虚拟机、jar包和转换工具</li>
</ol>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Visio</title>
    <url>/2020/02/26/others/visio/</url>
    <content><![CDATA[<h1 id="UML基础-1"><a href="#UML基础-1" class="headerlink" title="UML基础 ^1"></a>UML基础 <a href="https://www.bilibili.com/video/av34973179?from=search&amp;seid=955581513016587565" title="熟练使用UML" target="_blank" rel="noopener">^1</a></h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><code>OO(Object-Orientation)</code> 面向对象，一种系统建模技术 </p>
</li>
<li><p><code>OOP(Object-Orientation Programming)</code> 按照<code>OO</code>的方法来开发程序的过程</p>
</li>
<li><p><code>OOAD(Object Oriented Analysis and Design)</code> 面向对象的分析与设计，根据<code>OO</code>的方法学，对软件系统进行分析和设计的过程(分析阶段<code>OOA</code>、设计阶段<code>OOD</code>)</p>
<ul>
<li><p><code>OOA</code>阶段需要解决的核心问题是 <code>what to do</code></p>
<ul>
<li><p>建立针对业务问题域的清晰视图</p>
</li>
<li><p>列出系统必须要完成的核心任务</p>
</li>
<li><p>针对问题域建立公共词汇表</p>
</li>
<li><p>列出针对此问题域的最佳解决方案</p>
</li>
</ul>
</li>
<li><p><code>OOD</code>阶段需要解决的核心问题是 <code>How to do</code></p>
<ul>
<li><p>如何解决具体的业务问题</p>
</li>
<li><p>引入系统工作所需的支持元素</p>
</li>
<li><p>定义系统的实现策略</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>对象</code>: </p>
<ul>
<li><p>客观存在的、唯一的实体</p>
</li>
<li><p>是面向对象编程过程中分析与解决问题的出发点与基础</p>
</li>
<li><p>拥有自己的标识、数据与行为</p>
</li>
<li><p>可以简单或复杂</p>
</li>
<li><p>可以抽象或具体</p>
</li>
<li><p>在<code>OOP</code>中是一个类的动态实例</p>
</li>
</ul>
</li>
</ul>
<h3 id="OOP主要特征"><a href="#OOP主要特征" class="headerlink" title="OOP主要特征"></a>OOP主要特征</h3><ul>
<li><p>抽象(abstract)</p>
<ul>
<li><p>忽略一个对象或实体的细节而只关注其本质特征的过程</p>
</li>
<li><p>简化功能与格式</p>
</li>
<li><p>帮助用户与对象交互</p>
</li>
</ul>
</li>
<li><p>封装(encapsulation)</p>
<ul>
<li><p>隐藏数据和实现</p>
</li>
<li><p>提供公共方法供用户调用功能</p>
</li>
<li><p>对象的两种视图： 外部视图(对象能做的工作)、内部视图(对象如何完成工作)  </p>
</li>
</ul>
</li>
<li><p>继承(inheritance)</p>
<ul>
<li><p>通过存在的类型定义新类型的机制</p>
</li>
<li><p>通常在两个类型之间存在<code>is a</code>或<code>kind of</code>这样的关系</p>
</li>
<li><p>通过继承可实现代码重用，是多态的基础</p>
</li>
</ul>
</li>
<li><p>多态(polymorphism)</p>
<ul>
<li><p>一个名称，多种形式</p>
</li>
<li><p>基于继承的多态</p>
</li>
<li><p>调用方法时根据所给对象的不同，选择不同的处理方式</p>
</li>
</ul>
</li>
<li><p>关联(association)</p>
<ul>
<li><p>对象之间交互时的一种引用方式</p>
</li>
<li><p>当一个对象通过对另一个对象的引用去使用另一个对象的服务或操作时，两个对象之间便产生了关联</p>
</li>
</ul>
</li>
<li><p>聚合(aggregation)</p>
<ul>
<li><p>一种关系较强的关联关系，一个对象成为另一个对象的组成部分</p>
</li>
<li><p>两个对象之间存在<code>has a</code>的关系，一个对象作为另一个对象的属性存在，在外部对象被生产时可由客户端指定与其关联的内部对象</p>
</li>
<li><p>e.g. 汽车与轮胎的关系： 轮胎作为汽车的一部分可以和汽车分别生产后装配起来，但汽车也可换别新轮胎，轮胎也可与其他汽车装配使用</p>
</li>
</ul>
</li>
<li><p>组合(composition)</p>
<ul>
<li><p>关联关系中最为强烈的一种关系</p>
</li>
<li><p>当一个对象包含另一个对象时，外部对象负责管理内部对象的生命周期情况</p>
</li>
<li><p>内部对象的创建又由外部对象自己控制</p>
</li>
<li><p>外部对象不存在时内部对象也不能存在</p>
</li>
</ul>
</li>
<li><p>内聚与耦合(cohesion &amp; coupling)</p>
<p>内聚： 度量一个类独立完成某项工作的能力</p>
<p>耦合： 度量系统内或系统之间依赖关系的复杂度</p>
<p>设计原则： 增加内聚，减少耦合(高内聚低耦合)</p>
</li>
</ul>
<h3 id="域模型"><a href="#域模型" class="headerlink" title="域模型"></a>域模型</h3><p>在面向对象术语中也可称为设计模型，由具有状态和行为的域对象组成。</p>
<p>域对象之间的关系：</p>
<ul>
<li><p>关联(Association)</p>
</li>
<li><p>依赖(Dependency)</p>
</li>
<li><p>聚集(Aggregation)</p>
<p>整体和部分之间的关系</p>
</li>
<li><p>一般化(泛化)(Generalization)</p>
<p>类之间的继承关系</p>
</li>
</ul>
<h3 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h3><p>传统开发过程： 瀑布模型</p>
<p><img src="/source/data/img/uml/瀑布模型.png" alt="传统开发过程"></p>
<p>OOAD开发过程：</p>
<ul>
<li><p>大项目分解成子项目</p>
</li>
<li><p>使用UML工具</p>
</li>
<li><p>统一软件开发过程是迭代、递增的开发过程</p>
</li>
</ul>
<h3 id="迭代、递增的项目生命周期"><a href="#迭代、递增的项目生命周期" class="headerlink" title="迭代、递增的项目生命周期"></a>迭代、递增的项目生命周期</h3><p>在每一个迭代的阶段应该做以下工作：</p>
<ul>
<li><p>选择并分析相关用例</p>
</li>
<li><p>根据所选架构进行设计</p>
</li>
<li><p>在组件层次实现设计</p>
</li>
<li><p>验证组件满足用例的需要</p>
</li>
</ul>
<p>当一次迭代满足目标后，开发进入下一个迭代周期。</p>
<p>主要阶段：</p>
<p>Inception - start up</p>
<p>Elaboration - refine</p>
<p>Constructon - implement</p>
<p>Transition - promotion</p>
<p>每个周期包含一次或多次迭代</p>
<p>一个阶段的结束称之为“里程碑(milestone)”</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>此阶段的增量集中于：</p>
<ul>
<li><p>项目启动</p>
</li>
<li><p>建立业务模型</p>
</li>
<li><p>定义业务问题域</p>
</li>
<li><p>找出主要的风险因素</p>
</li>
<li><p>定义项目需求的外延</p>
</li>
<li><p>创建业务问题域的相关说明文档</p>
</li>
</ul>
<h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>此阶段增量集中于： </p>
<ul>
<li><p>高层的分析与设计</p>
</li>
<li><p>建立项目的基础框架</p>
</li>
<li><p>监督主要的风险因素</p>
</li>
<li><p>制定达成项目目标的创建计划</p>
</li>
</ul>
<h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>代码及功能的实现</p>
<h4 id="移交阶段"><a href="#移交阶段" class="headerlink" title="移交阶段"></a>移交阶段</h4><p>此阶段增量集中于：</p>
<ul>
<li><p>向用户发布产品</p>
</li>
<li><p>beta测试</p>
</li>
<li><p>执行性能调优，用户培训和接收测试</p>
</li>
</ul>
<h4 id="每个阶段包含的工作流"><a href="#每个阶段包含的工作流" class="headerlink" title="每个阶段包含的工作流"></a>每个阶段包含的工作流</h4><p>每一次递增都由5部分组成： 需求与初始分析、分析、设计、实现、测试。</p>
<p>每一次迭代执行工作流的深度不同，早期的迭代在深度上覆盖初始工作流，后期迭代在深度上覆盖后期工作流。</p>
<h4 id="迭代、递增生命周期的优势"><a href="#迭代、递增生命周期的优势" class="headerlink" title="迭代、递增生命周期的优势"></a>迭代、递增生命周期的优势</h4><ul>
<li><p>降低成本</p>
</li>
<li><p>便于更好地维护项目进度</p>
</li>
<li><p>便于团队的协作开发</p>
</li>
<li><p>便于适应用户需求的动态变化</p>
</li>
</ul>
<h2 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h2><p><code>Unified Modeling Language</code>: 统一建模语言。图形化语言表示。</p>
<h3 id="UML图的分类"><a href="#UML图的分类" class="headerlink" title="UML图的分类"></a>UML图的分类</h3><h4 id="静态模型-static-model"><a href="#静态模型-static-model" class="headerlink" title="静态模型(static model)"></a>静态模型(static model)</h4><ul>
<li><p>创建并记录一个系统的静态特征</p>
</li>
<li><p>反映一个软件系统基础、固定的框架结构</p>
</li>
<li><p>创建相关问题域主要元素的视图</p>
</li>
</ul>
<p>静态建模包括： 用例图(user case diagrams)、类图(class diagrams)、对象图(object diagrams)、组件图(component diagrams)、部署图(deployment diagrams)</p>
<h4 id="动态模型-dynamic-model"><a href="#动态模型-dynamic-model" class="headerlink" title="动态模型(dynamic model)"></a>动态模型(dynamic model)</h4><p>动态建模用以展示系统的行为</p>
<p>动态建模包括： 时序图(sequence diagrams)、协作图(collaboration diagrams)、状态图(state chart diagrams)、活动图(activity diagrams)</p>
<h2 id="九大核心UML图"><a href="#九大核心UML图" class="headerlink" title="九大核心UML图"></a>九大核心UML图</h2><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>展示系统的核心功能与其交互的用户，用户被称之为<code>&quot;活动者(Actor)&quot;</code></p>
<p>用例使用椭圆表示，为简化建模过程，用例图可标注优先级</p>
<h3 id="使用starUML绘制用例图"><a href="#使用starUML绘制用例图" class="headerlink" title="使用starUML绘制用例图"></a>使用starUML绘制用例图</h3><ol>
<li>在 <code>Model Explorer</code>工具栏中选中<code>Model</code>–&gt;右键选择<code>Add Diagram</code> –&gt; 选择 <code>Use Case Diagram</code></li>
</ol>
<p><img src="/source/data/img/uml/用例图绘制1.png" alt="用例图绘制步骤1"></p>
<ol start="2">
<li>在<code>Tool Box</code>工具栏中选择模板进行绘制</li>
</ol>
<p><img src="/source/data/img/uml/用例图绘制2.png" alt="用例图绘制步骤2"></p>
<p>上图表示 <code>活动者admin</code>可执行<code>add</code> <code>update</code> <code>delete</code> <code>query</code>操作，<code>活动者guest</code>只能执行<code>query</code>操作</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>表现类的特征，描述多个类、接口特征以及对象之间的协作与交互。</p>
<p>类图由一个或多个矩形区域构成，包括类型(类名)、属性(可选)、操作(可选)</p>
<h3 id="使用starUML绘制类图"><a href="#使用starUML绘制类图" class="headerlink" title="使用starUML绘制类图"></a>使用starUML绘制类图</h3><p><img src="/source/data/img/uml/类图示例.png" alt="类图示例"></p>
<hr>
<p>参考文章</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/10/13/tools/git/</url>
    <content><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git clone xxx(远程仓库地址)</code> 克隆远程仓库至本地</p>
<p><code>git branch</code> 查看本地分支</p>
<p><code>git branch -r</code> 查看远程分支</p>
<p><code>git branch &lt;分支名&gt;</code> 创建本地分支</p>
<p><code>git status</code> 查看当前状态</p>
<p><code>git add .</code> 将所有文件添加到暂存区</p>
<p><code>git commit am &quot;代码提交备注&quot;</code> 提交代码并添加注释</p>
<p><code>git push</code> 将分支推送至远程</p>
<p><code>git pull</code> 拉取远程分支</p>
<h2 id="一套代码关联多个远程仓库"><a href="#一套代码关联多个远程仓库" class="headerlink" title="一套代码关联多个远程仓库"></a>一套代码关联多个远程仓库</h2><p><code>git remote -v</code></p>
]]></content>
      <categories>
        <category>Tools, Git</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>vsCode</title>
    <url>/2019/10/13/tools/vsCode/</url>
    <content><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>安装主题插件，个人偏好 <code>One Dark Pro</code></p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="键入提示"><a href="#键入提示" class="headerlink" title="键入提示"></a>键入提示</h2><p>vsCode安装成功后，内置了Emmet插件，用于对一些代码进行补全</p>
<p><code>h1*6 + tab/enter键</code>: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>h1*6&gt;{1级标题} + tab/enter键</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>h$*6&gt;{$级标题} + tab/enter键</code>: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>2级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>3级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>4级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>5级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>6级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>lorem</code>： 乱数假文，没有任何实际含义的数字</p>
<p>例如： </p>
<p><code>p*6&gt;lorem + tab/enter键</code> ： 生成六段乱数假文，用于写静态页面时测试排版</p>
<p><code>p*6&gt;lorem1 + tab/enter键</code>： 生成六段乱数假文，每段只有一个单词</p>
<p><code>p*6&gt;lorem1000 + tab/enter键</code>： 生成六段乱数假文，每段只有1000个单词</p>
<p><code>(h2&gt;{章节1})+p&gt;lorem</code> : </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>章节1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Sit veritatis perferendis sint ipsa consectetur eligendi fugiat magni officiis! Nisi repellendus dignissimos dolorem a adipisci odit omnis, id nobis in quod.   </span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>(h2[id=&quot;chapter$&quot;]&gt;{章节$})*6</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter1"</span>&gt;</span>章节1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter2"</span>&gt;</span>章节2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter3"</span>&gt;</span>章节3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter4"</span>&gt;</span>章节4<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter5"</span>&gt;</span>章节5<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"chapter6"</span>&gt;</span>章节6<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><p><code>ctrl + enter键</code>： 光标切换至下一行<br><code>ctrl + shift + enter键</code>： 光标切换至上一行</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>按住鼠标中间上下移动，可将光标选中多行进行编辑</p>
<hr>
]]></content>
      <categories>
        <category>Tools, vsCode</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>vsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA</title>
    <url>/2023/06/27/tools/idea/</url>
    <content><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li><code>Alt + insert</code> 生成构造方法、getset方法、mybatis文件等</li>
</ul>
<h2 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h2><h3 id="MyBatisCodeHelperPro-Marketplace-Edition"><a href="#MyBatisCodeHelperPro-Marketplace-Edition" class="headerlink" title="MyBatisCodeHelperPro (Marketplace Edition)"></a>MyBatisCodeHelperPro (Marketplace Edition)</h3><ul>
<li><p><a href="https://www.cnblogs.com/equals/p/15391453.html" target="_blank" rel="noopener">安装说明</a></p>
</li>
<li><p><a href="https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/" target="_blank" rel="noopener">使用说明</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/av50632948/?vd_source=8a67383411f69921887ca2f40f490a83" target="_blank" rel="noopener">操作视频</a></p>
</li>
<li><p>支持实体生成建表语句</p>
</li>
<li><p>支持基于表生成实体/Mapper/服务等</p>
</li>
<li><p>支持生成Mybatis执行日志</p>
</li>
<li><p>支持预执行SQL</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools, IDEA</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法基础</title>
    <url>/2020/08/18/algorithm/dataStructure&amp;algorithm/</url>
    <content><![CDATA[<h1 id="复杂度、对数器、二分法、异或运算"><a href="#复杂度、对数器、二分法、异或运算" class="headerlink" title="复杂度、对数器、二分法、异或运算"></a>复杂度、对数器、二分法、异或运算</h1><p>常见的评估算法优劣的核心指标：</p>
<ul>
<li>时间复杂度(流程决定)</li>
<li>额外空间复杂度(流程决定)</li>
<li>常数项时间(实现细节决定)</li>
</ul>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>什么是常数时间的操作？<br>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间，这样的操作被称为常数时间的操作。</p>
<p>常见的常数时间操作：</p>
<ul>
<li>算数运算(+ - * % /)等</li>
<li>常见的位运算(&gt;&gt; &gt;&gt;&gt; &lt;&lt; | &amp; ^)等</li>
<li>赋值、比较、自增、自减操作</li>
<li>数组寻址操作</li>
</ul>
<p><strong>执行时间固定的操作都是常数时间的操作，执行时间不固定的操作，都不是常数时间的操作</strong></p>
<blockquote>
<p>JAVA中LinkedList的get(i)就不是常数时间的操作</p>
</blockquote>
<p>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</p>
<ol>
<li>想象该算法流程所处理的数据状况，要按照最差情况来</li>
<li>把整个流程彻底拆分为一个个基本动作，保证<strong>每个动作都是常数时间的操作</strong></li>
<li>如果数据为N,看看基本动作的数量和N是什么关系</li>
</ol>
<p>如何确定算法流程的时间复杂度？<br>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为O(忽略掉系数的高阶项)</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度就是来衡量在整个流程中发生了多少次的常数操作这件事.</p>
<p>时间复杂度的意义：<br>当我们要处理的样本很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的；真正重要的是最高阶项</p>
<p>时间复杂度是衡量算法流程的复杂度的一种指标，该指标只与数据量有关，与过程之外的优化无关</p>
<p>常见的时间复杂度排序(从好到差): O(1) &gt; O(logN) &gt; O(N) &gt; O(N*logN) &gt; O(N²)  O(N³)… O(N^k) &gt; O(2^N) O(3^N)… O(k^N) &gt; O(N!)</p>
<h2 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h2><ul>
<li>选择排序O(n²)： 轮询数组，将最小的数放到最前面</li>
<li>冒泡排序O(n²)： 数组之间两两元素顺序交换，大的值放后面</li>
<li>插入排序：将i位置上的数与前面的数相比较，只要前面的数比它大，就交换</li>
</ul>
<p>注：</p>
<ul>
<li>算法的过程和具体的语言无关</li>
<li>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</li>
<li>一定要确保在拆分算法的流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己用过的每一个系统api都是非常熟悉，否则会影响你对时间复杂度的估算</li>
</ul>
<h2 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h2><p>实现算法流程的过程中，你需要开辟一些新的空间来支持你的算法流程</p>
<p>作为输入参数的空间，不算额外空间<br>作为输出结果的空间，不算额外空间</p>
<p>因为输入参数和输出结果都是必要的、和现实目标有关的，所以都不算额外空间</p>
<p>除上述以外，你的流程中如果还需要开辟空间才能继续下去，这部分的空间就是额外空间</p>
<p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)</p>
<h2 id="常数项时间"><a href="#常数项时间" class="headerlink" title="常数项时间"></a>常数项时间</h2><p>时间复杂度这个指标是忽略低阶项和所有常数系数的。<br>但同样的时间复杂度的流程，运行时实际也并不是一样好。<br>时间复杂度只是一个重要指标，如果两个时间复杂度一样的算法还要咋时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p>
<p>两个流程的常数项时间进行比拼不采用理论分析，直接生成随机数据测试</p>
<h2 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h2><p>一般情况下认为，解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解</p>
<p>一般最优解都是忽略掉常数项的，因为常数项这个因素只决定了实现层次的优化和考虑，和怎么解决整个问题的思想无关。</p>
<h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><ol>
<li>你想要测的方法a</li>
<li>实现复杂度不好，但是容易实现的方法b</li>
<li>实现一个随机样本产生器</li>
<li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</li>
<li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b</li>
<li>当样本数量很多时，比对测试依然正确，可以确定方法a已经正确</li>
</ol>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><blockquote>
<p>算术运算怎么转换成位运算？</p>
</blockquote>
<ul>
<li>在一个有序数组中，找某个数是否存在</li>
<li>在一个有序数组中，找&gt;=某个数最左侧的位置</li>
<li>在一个有序数组中，找&lt;=某个数最右侧的位置</li>
<li>局部最小值问题</li>
</ul>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><p>异或运算： 相同为0，不同为1<br>同或运算： 相同为1，不同为0</p>
<p>异或运算其实就是无进位的相加，即产生了进位则忽略成0</p>
<p>异或运算的性质:</p>
<ol>
<li>0 ^ N == N  N ^ N == 0</li>
<li>异或运算满足交换律和结合律</li>
</ol>
<h3 id="异或运算的应用"><a href="#异或运算的应用" class="headerlink" title="异或运算的应用"></a>异或运算的应用</h3><ol>
<li><p>如何不用额外变量交换两个数？<br> int a = m;<br> int b = n;<br> a = a ^ b;<br> b = a ^ b;<br> a = a ^ b;</p>
<p> 最终结果： a = n; b = m;</p>
<p> 以上的交换只能a b的值为两个不同的内存空间才能操作，若a=b=arr[i]则不能用以上方法，因此实际使用时还是使用临时变量temp进行交换</p>
</li>
<li><p>一个数组中有一种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这种数？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	eor = eor ^ arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 以上代码运行出来最终得到的eor的值就是出现了奇数次的数</p>
</li>
<li><p>如何把一个int类型的数提取出最右侧的1来？</p>
<p> 例如：int N = 00…1101010000</p>
<p> 将最右侧的1提取出来的结果是：00…0000010000</p>
<p> N &amp; ((~N) + 1)</p>
<p> 先将N取反，取反后的值+1，最后将这个值与N进行与运算得到的结果就是只保留最右侧的1其他位为0</p>
</li>
<li><p>一个数组中有两种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这两种数？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="comment">// 使用eor=0将所有数都^一遍，最终得到的结果 eor = a ^ b</span></span><br><span class="line"><span class="comment">// 且eor != 0,表示eor必然有一个位置上是1</span></span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取eor中最右侧的1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor ^ ((~eor) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新的变量onlyOne=0,将所有与eor最右侧是1同类的数进行操作</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// (arr[i] &amp; rightOne) != 0表示arr[i]在rightOne中为1的位数上也是1</span></span><br><span class="line">		onlyOne ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上得到的onlyOne的结果是a或者b</span></span><br><span class="line"><span class="comment">// 出现奇数次的两个数a b 分别是 onlyOne和 eor^onlyOne</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><ul>
<li><p>单向链表节点结构(可以实现成范型)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向链表节点结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h3><ul>
<li><p>单链表和双链表如何反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 单向链表单反转 */</span></span><br><span class="line">    <span class="comment">// 1. 定义单向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            value = date;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*双向链表反转*/</span></span><br><span class="line">    <span class="comment">// 1. 定义双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">        DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">        DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            head.last = next;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除给定值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定删除head中值为num的节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首次遍历，过滤头节点为num的情况</span></span><br><span class="line">    <span class="comment">// 找到第一个不需要删的位置</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.value != num) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.value == num) &#123;</span><br><span class="line">            <span class="comment">// 当前值为num,将当前值的下一位赋于pre.next</span></span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前值保留,记录当前值</span></span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="逻辑概念"><a href="#逻辑概念" class="headerlink" title="逻辑概念"></a>逻辑概念</h3><ul>
<li><p>栈： 先进后出</p>
</li>
<li><p>堆： 先进先出</p>
</li>
</ul>
<h3 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h3><ul>
<li><p>双向链表实现</p>
</li>
<li><p>数组实现</p>
</li>
</ul>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ol>
<li><p>怎么用数组实现不超过固定大小的队列和栈</p>
<p>栈： 正常使用</p>
<p>队列： 环形数组</p>
</li>
<li><p>实现一个特殊的栈，在基本功能的基础上再实现返回栈中最小元素的功能</p>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>algorithm</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/10/25/database/database/</url>
    <content><![CDATA[<h1 id="数据库表的创建、表的约束、索引、数据库"><a href="#数据库表的创建、表的约束、索引、数据库" class="headerlink" title="数据库表的创建、表的约束、索引、数据库"></a>数据库表的创建、表的约束、索引、数据库</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="标准的建表语法"><a href="#标准的建表语法" class="headerlink" title="标准的建表语法"></a>标准的建表语法</h3><p>数据库连接池： <code>C3P0</code> <code>DBCP</code> <code>druid</code></p>
<p><code>CREATE TABLE[schema.]table(column datatype [DEFAULT])</code> </p>
<p>例如：</p>
<p>建立一张用来存储学生信息的表，表中的字段包含学生的学号、姓名、年龄、入学日期、年纪、班级、email等信息，且为grade指定默认值为1</p>
<ul>
<li><p>创建</p>
<p><code>create table student (sty_id number(10), name varcher2(20), age number(3), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50))</code></p>
</li>
<li><p>插入</p>
<ul>
<li><p><code>insert into student values(20201025, &#39;zhangshan&#39;, 22, to_date(&#39;2020-10-25&#39;, &#39;YYYY-MM-DD&#39;), &#39;2&#39;, &#39;1&#39;, &#39;123@xx.com&#39;)</code></p>
</li>
<li><p><code>insert into student(sty_id, name, age, hiredate,classes,email) values(20201025, &#39;zhangshan&#39;, 22, to_date(&#39;2020-10-25&#39;, &#39;YYYY-MM-DD&#39;), &#39;1&#39;, &#39;123@xx.com&#39;)</code></p>
</li>
</ul>
</li>
</ul>
<p>注意事项： </p>
<ul>
<li>创建新表时，指定的表名必须不存在，否则报错</li>
<li>使用默认值时，当插入行不给出值，dbms将自动采用默认值</li>
<li>使用create语句创建基本表时，最初只是一个空的框架，用户可以使用insert命令将数据插入表中，即只包含表结构不包含表数据</li>
</ul>
<p><strong>正规的表结构设计需要使用第三方工具</strong></p>
<ul>
<li><p>修改表</p>
<p>例如： 在上述<code>student</code>表中添加字段<code>address</code></p>
<p><code>alter table student add address varchar2(100)</code></p>
<p>注： 新增加的列不能设置为 <code>not null</code>，基本表在增加一列后，原有元组在新增加的列上的值都定义为空值</p>
</li>
<li><p>删除表字段</p>
<p><code>alter table 表名 drop column 列名</code></p>
<p><code>alter table student drop column address</code></p>
</li>
<li><p>修改表字段类型</p>
<p><code>alter table 表名 modify(字段 字段类型);</code></p>
<p><code>alter table student modify(email varchar2(100));</code></p>
</li>
<li><p>删除表</p>
<p><code>drop table 表名</code></p>
<p>多表关联时不能随意删除，需要使用</p>
<ul>
<li><p>级联删除<code>cascade</code>: 如果表A和表B，A中的某一个字段与B中的某一个字段做关联，那么删除A表的时候，需要先将B表删除</p>
</li>
<li><p><code>set null</code>删除时，把表的关联字段设置为空</p>
</li>
<li><p><code>restrict</code>，只有当依赖表中没有一个外键值与要删除的主表中主键值相对应时，才可执行删除操作</p>
</li>
</ul>
</li>
<li><p>修改表名称</p>
<p><code>rename 原表名 to 新表名;</code></p>
<p><code>rename student to stu;</code></p>
</li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>创建表时同时可以指定所插入数据的一些规则，比如说某个字段不能为空，某个字段你的值不能小于0等，这些规则统称为约束。约束是在表上强制执行的<strong>数据校验规则</strong></p>
<p>Oracle支持以下五类完整型约束：</p>
<ul>
<li>NOT NULL 非空，插入数据时，指定列不允许为空</li>
<li>UNIQUE Key 唯一键， 可以限定某一列的值唯一，唯一键的列一般被用作索引列</li>
<li>PRIMARY KEY 主键， 非空且唯一，任何一张表一般情况下最好有主键用来唯一的标识一行记录</li>
<li><p>FOREIGN KEY 外键，多个表之间有关联关系(一个表的某个列的值依赖于另一张表的某个值)时，需要使用外键</p>
<ul>
<li>外键是表中的一个列，其值必须在另一表的主键或者唯一键中列出</li>
<li>作为“主键”的表称为“主表”，作为外键的关系称为“依赖表”</li>
<li>外键参照的是主表的主键或者唯一键</li>
<li>对于主表的删除和修改主键值的操作，回怼依赖关系产生影响，如要删除主表的某个记录（即删除一个主键值），那么对依赖的影响可采取<code>RESTRICT方式</code>、<code>CASCADE方式</code>、<code>SET NULL方式</code></li>
</ul>
<p>插入DEPT表中的DEPTNO列作为外键<br><code>create table student (sty_id number(10), name varcher2(20), age number(3), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50)), foreign key [DEPTNO] references DEPT[DEPTNO]</code></p>
</li>
<li><p>CHECK 自定义检查约束，可以根据用户自己的需求去限定某些列的值</p>
<p>例如： 限制0&lt;年龄&lt;150</p>
<p>   <code>create table student (sty_id number(10), name varcher2(20), age number(3) check(age &gt; 0 and age &lt; 150), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50))</code></p>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>索引是为了加快对数据的搜索速度而设立的。索引是方案(schema)中的一个数据库对象，与表独立存放</li>
<li>索引的作用： 在数据库中用来加速对表的查询，通过使用快速路径访问方法快读定位数据，减少了磁盘的I/O</li>
<li>sql中的索引是非显示索引，也就是在索引创建之后，在用户撤销它之前不会再用到该索引的名字，但是索引在用户查询时会自动起作用</li>
<li><p>索引的创建有两种情况</p>
<ul>
<li>自动： 当在表上定义一个<code>primary key</code> 或者 <code>unique 约束条件</code>时，Oracle数据库自动创建一个对应的唯一索引</li>
<li>手动： 用户可以创建索引以加速查询</li>
</ul>
</li>
</ul>
<h3 id="开发使用索引的要点"><a href="#开发使用索引的要点" class="headerlink" title="开发使用索引的要点"></a>开发使用索引的要点</h3><ol>
<li>索引改善检索操作的性能，但降低数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引</li>
<li>索引数据可能要占用大量的存储空间</li>
<li>并非所有数据都适合于索引。唯一性不好的数据（如省）从索引得到的好处不比具有股鞥多可能值的数据（如姓名）从索引中得到的好处多</li>
<li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能是索引的备选</li>
<li>可以在索引中定义多个列（例如省+市），这样的索引只在省+市的顺序排序时游泳。如果想按城市排序，则这种索引没用</li>
</ol>
<h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><ul>
<li><p>创建</p>
<p><code>create index 索引名称 on 表名(列名1[,列名2]...);</code></p>
</li>
<li><p>删除</p>
<p><code>drop index 索引名</code></p>
</li>
</ul>
<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><p>在设计和数据库有关的系统时，数据库表的设计至关重要，这些设计关系整个系统的架构，需要精心的仔细考虑。数据库的设计主要包含了设计表结构和表之间的联系，在设计的过程中，有一些规则应该遵守</p>
<p><strong>三范式的存在是为了减少数据库中的数据冗余</strong></p>
<h2 id="第一范式-1NF-：-确保每列保持原子性"><a href="#第一范式-1NF-：-确保每列保持原子性" class="headerlink" title="第一范式(1NF)： 确保每列保持原子性"></a>第一范式(1NF)： 确保每列保持原子性</h2><p>第一范式是最基本的范式，如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行，但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对“地址”中某一部分操作的时候将非常方便，这样设计才满足了数据库的第一范式。</p>
<p>所谓的第一范式是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即<strong>列不可分</strong></p>
<h2 id="第二范式-2NF-：-确保表中的每列都和主键相关"><a href="#第二范式-2NF-：-确保表中的每列都和主键相关" class="headerlink" title="第二范式(2NF)： 确保表中的每列都和主键相关"></a>第二范式(2NF)： 确保表中的每列都和主键相关</h2><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<h2 id="第三范式-3NF-必须先满足第二范式"><a href="#第三范式-3NF-必须先满足第二范式" class="headerlink" title="第三范式(3NF): 必须先满足第二范式"></a>第三范式(3NF): 必须先满足第二范式</h2><p>第三范式要求在一个数据库表中不包含已在其他表中已包含的非主关键字信息。</p>
<p>例如： 存在一个部门信息表，其中每个部门有部门编号(dep_id)、部门名称、部门简介等信息，那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门先关的信息加入员工信息表中。如果不存在部门信息表，则根据第三范式，应该创建部门信息表，否则会有大量的数据冗余。</p>
<p>第三范式就是属性不依赖于其他非主属性</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p>
<h1 id="DBUtil及数据库连接池"><a href="#DBUtil及数据库连接池" class="headerlink" title="DBUtil及数据库连接池"></a>DBUtil及数据库连接池</h1><h2 id="DBUtil"><a href="#DBUtil" class="headerlink" title="DBUtil"></a>DBUtil</h2><p>Commons DbUtils: JDBC Utility Component</p>
<p>Apache封装的JDBC工具组件</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池的目的是为了减少频繁开关连接的时间，提高整个系统的响应能力，数据库连接池应该具备几个属性值：</p>
<ol>
<li>初始大小</li>
<li>每次扩容的大小</li>
<li>连接池的最大个数</li>
<li>空闲连接的死亡时间</li>
</ol>
<p>各种数据库连接池：</p>
<ul>
<li>DBCP</li>
<li>C3P0</li>
<li>Druid</li>
<li>hikariCP</li>
</ul>
<h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a><code>DBCP</code></h3><p>Apache提供的数据库连接池，目前用的比较少</p>
<h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a><code>C3P0</code></h3><p>开源的数据库连接池</p>
<ol>
<li><p>下载Jar包并导入项目中</p>
</li>
<li><p>使用步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.*;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 加载mysql驱动</span></span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass( <span class="string">"com.mysql.jdbc.Driver"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置URL、用户名、密码         </span></span><br><span class="line">cpds.setJdbcUrl( <span class="string">"jdbc:postgresql://localhost/testdb"</span> );</span><br><span class="line">cpds.setUser(<span class="string">"dbuser"</span>); </span><br><span class="line">cpds.setPassword(<span class="string">"dbpassword"</span>);</span><br></pre></td></tr></table></figure>
<p><code>c3p0</code>若要通过配置文件进行参数配置，则配置文件必须放置在根目录，且文件名为<code>c3p0.properties</code>(properties文件)或<code>c3p0-config.xml</code>(xml文件)</p>
</li>
</ol>
<p><strong>JDBC4之前是必须要填写驱动名称的，但是之后的版本不需要填写</strong></p>
<h3 id="druid"><a href="#druid" class="headerlink" title="druid"></a><code>druid</code></h3><h3 id="hikariCP"><a href="#hikariCP" class="headerlink" title="hikariCP"></a><code>hikariCP</code></h3><p>配置参见官方文档</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础</title>
    <url>/2023/07/14/frontend/frontend/</url>
    <content><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><p>进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程</p>
<p>每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意</p>
<p>线程： 运行代码的“人”称之为“线程”，一个进程至少有一个线程，所以在进程开启之后会主动创建一个线程来运行代码，该线程称之为主线程。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><p>浏览器是一个多进程多线程的应用程序。</p>
<p>浏览器内部工作机器复杂，为了避免互相影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<p>谷歌浏览器 –&gt; 点击更多 –&gt; 选择更多工具 –&gt; 任务管理器</p>
<p>能看到浏览器的多个进程，即使一个网页都没打开也会有很多进程</p>
<p>浏览器中的主要进程包括：浏览器进程、网络进程、渲染进程</p>
<p>浏览器进程： 负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
<p>浏览器进程负责的页面展示指的是浏览器本身的界面，如标签页、前进后退刷新按钮、导航栏等的展示</p>
<p>网络进程： 负责加载网络资源</p>
<p>渲染进程：</p>
<p>渲染进程启动后会开启一个渲染主线程，主线程负责执行HTML、CSS、JS代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不互相影响。</p>
<p><strong>将来此默认模式可能会有所改变，有可能会变成一个站点开启一个进程，而不是一个标签页一个进程，但目前还是一个标签页一个进程的模式，具体可以参见chrome官方文档说明</strong></p>
<p><strong>最新版的chrome(114.0.5735.199)已经有所改动，新增了一个性能模块，需要自动开启，开启后会自动释放已有一段时间未使用的标签页占用的内存，以让使用中的标签页和其他应用获得更多计算机资源，并让 Chrome 保持快速运行。可在“设置”页面中管理省内存模式以及选择要释放哪些网站占用的内存</strong></p>
<h2 id="渲染主线程是如何工作的"><a href="#渲染主线程是如何工作的" class="headerlink" title="渲染主线程是如何工作的"></a>渲染主线程是如何工作的</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li><p>解析HTML</p>
</li>
<li><p>解析CSS</p>
</li>
<li><p>计算样式</p>
</li>
<li><p>布局</p>
</li>
<li><p>处理图层</p>
</li>
<li><p>每秒把页面画60次</p>
</li>
<li><p>执行全局js代码</p>
</li>
<li><p>执行事件处理函数</p>
</li>
<li><p>执行计时器的回调函数</p>
</li>
</ul>
<p>渲染主线程调度任务：排队</p>
<p>将需要执行的任务放在消息队列中进行排队</p>
<ol>
<li><p>最开始的时候，渲染总线程会进入一个无限循环</p>
</li>
<li><p>每一次循环会检查消息队列中是否有任务存在。如果有就取出第一个任务执行，执行完一个后进入下一次循环；如果没有则进入休眠状态</p>
</li>
<li><p>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒继续循环拿取任务</p>
</li>
</ol>
<p>以上整个过程被称为事件循环(event loop)，又叫做消息循环（message loop）</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>代码在执行过程中会遇到一些无法立即处理的任务，如：</p>
<ul>
<li><p>计时完成后需要执行的任务： setTimeout setInterval</p>
</li>
<li><p>网络通信完成后需要执行的任务： XHR、Fetch</p>
</li>
<li><p>用户操作后需要执行的任务： addEventListener</p>
</li>
</ul>
<p>如果让渲染主线程等待这些任务执行完，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死</p>
<h2 id="JS为何会阻碍渲染"><a href="#JS为何会阻碍渲染" class="headerlink" title="JS为何会阻碍渲染"></a>JS为何会阻碍渲染</h2><p>因为JS和渲染都在浏览器的渲染主线程中，执行JS渲染就需要等着，执行渲染，JS就要等着</p>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>任务没有优先级，在消息队列中先进先出</p>
<p><strong>但是消息队列是有优先级的</strong></p>
<ul>
<li><p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行</p>
</li>
<li><p>浏览器必须准备好一个微队列(microtask queue)，微队列中的任务优先所有其他任务队列</p>
</li>
</ul>
<p>Chrome的实现中，至少包含一下队列：</p>
<ul>
<li><p>延时队列： 用于存放计时器到达后的回调任务，优先级 中</p>
</li>
<li><p>交互队列： 用于存放用户操作后产生的事件处理任务，优先级 高</p>
</li>
<li><p>微队列： 用户存放需要最快执行的任务，优先级 最高</p>
</li>
</ul>
<p>添加任务到微队列的主要方式是使用Promise、MutationObserver</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(函数)</span><br></pre></td></tr></table></figure>
<p>以下代码的执行顺序：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的顺序应该是2， 1</p>
<p>以下代码的执行顺序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出顺序应该是3 2 1</p>
<p>console.log(3)属于全局函数，所以是先执行，console.log(2)在微队列，优先级高于console.log(1)的延时队列</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="如何理解JS的异步"><a href="#如何理解JS的异步" class="headerlink" title="如何理解JS的异步"></a>如何理解JS的异步</h3><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。<br>渲染主线程承担着诸多工作，页面渲染、执行js都在其中运行。<br>如果使用同步的方式，极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法执行。<br>这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法即使更新，给用户造成卡死的现象。</p>
<p>所以浏览器采用异步的方式来避免。<br>具体做法是，当某些任务，如计时器、网络、事件监听，主线程将任务交给其他线程处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程进行调用执行。</p>
<p>异步模式下浏览器永不阻塞，从而最大限度保障了单线程的执行。</p>
<h3 id="阐述下JS的事件循环"><a href="#阐述下JS的事件循环" class="headerlink" title="阐述下JS的事件循环"></a>阐述下JS的事件循环</h3><p>事件循环又叫消息循环，是浏览器渲染主线程的工作方式。<br>在Chrome源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，其他线程只需要在合适的时候将任务加入到队列末尾即可</p>
<p>过去把消息队列简单分为虹队列和微队列，这种说法已经无法满足现在的复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据W3C官方的解释，每个任务具有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高优先级，必须优先调度执行</p>
<h3 id="JS中的计时器能做到精确计时吗？为什么？"><a href="#JS中的计时器能做到精确计时吗？为什么？" class="headerlink" title="JS中的计时器能做到精确计时吗？为什么？"></a>JS中的计时器能做到精确计时吗？为什么？</h3><p>不能。</p>
<ul>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又会带来偏差</li>
</ul>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>绘制Paint –&gt; 分块Tiling –&gt; 光栅化 Raster –&gt; 画 Draw</p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>将每个块变成位图，优先处理靠近视口的块  </p>
<p>此过程会使用GPU进行加速</p>
<h2 id="画"><a href="#画" class="headerlink" title="画"></a>画</h2><p>合成线程及选出每个位图在屏幕上的位置，交给GPU进行最终呈现。 GPU是浏览器的进程，不是显卡的进程</p>
<p>此部分会进行transform等变形属性的计算，这就是transform效率高的根本原因，因为它发生在合成线程，与渲染主线程无关</p>
<p>合成线程会把quad交给渲染主线程</p>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="浏览器是如何渲染页面的"><a href="#浏览器是如何渲染页面的" class="headerlink" title="浏览器是如何渲染页面的"></a>浏览器是如何渲染页面的</h3><h3 id="什么是reflow"><a href="#什么是reflow" class="headerlink" title="什么是reflow"></a>什么是reflow</h3><p>reflow的本质是重新计算Layout树。</p>
<p>当进行了会影响布局树的操作之后，需要重新计算布局树，会引发layout.</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当JS代码全部完成后在进行统一计算，所以改动属性造成的reflow是异步完成的。</p>
<p>当JS获取布局属性时就有可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复的权衡下，最终决定获取属性立即reflow。</p>
<h3 id="什么是repaint"><a href="#什么是repaint" class="headerlink" title="什么是repaint"></a>什么是repaint</h3><p>repaint本质上是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式之后，就需要重新计算，会引发repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint。</p>
<h3 id="为什么transform的效率高"><a href="#为什么transform的效率高" class="headerlink" title="为什么transform的效率高"></a>为什么transform的效率高</h3><p>因为transform既不会影响布局也不会影响绘制指令，它只会影响渲染流程的最后一个Draw阶段。</p>
<p>由于draw阶段在合成线程中，所以transform的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌也不会影响transform的变化</p>
<h1 id="实战——歌词滚动效果"><a href="#实战——歌词滚动效果" class="headerlink" title="实战——歌词滚动效果"></a>实战——歌词滚动效果</h1><p><code>transition</code>表示变化过渡时间，只针对数值类的属性有效，比如颜色、宽高、透明度等</p>
<p>JS 先做数据逻辑，再做界面逻辑，最后才是事件逻辑</p>
<h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>得到属性描述符：</p>
<p><code>Object.getOwnPropertyDescriptor(对象, 对象的属性属性名称)</code></p>
<p>设置属性描述符：</p>
<p><code>Object.defineProperty(对象, 对象的属性名, {需要设置的属性：属性对应的属性值})</code></p>
<p><code>Object.freeze(obj)</code> 冻结对象，对象冻结后不能修改和增删属性</p>
<p><code>obj = {...obj}</code> 克隆对象</p>
<p><code>obj.seal(obj)</code> 密封对象</p>
<p>属性描述符有：</p>
<ul>
<li><p><code>value</code> 属性值</p>
</li>
<li><p><code>writable</code> 是否可以重写</p>
</li>
<li><p><code>enumerable</code> 是否可遍历</p>
</li>
<li><p><code>configurable</code> 是否可修改描述符本身，设置为false之后就不能再次修改属性符了</p>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>前端学习路线： h5+css3 –&gt; es6 -&gt; 网络 –&gt; 第三方库 –&gt; 工程化 –&gt; Vue react等框架 –&gt; …</p>
<p>Vue的data中是界面数据</p>
<p>数据响应式： 数据的变化会引发界面的更新，其本质是当数据变化时，会自动运行相关函数</p>
<p>Vue中的computed表示计算属性，本身不存在，要靠计算出来</p>
]]></content>
      <categories>
        <category>frontend,js</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>frontend</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础之HTML5</title>
    <url>/2019/07/21/frontend/html5/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="超-基础概念（各种缩写）"><a href="#超-基础概念（各种缩写）" class="headerlink" title="超~~~基础概念（各种缩写）"></a>超~~~基础概念（各种缩写）</h2><p>HTML: Hyper Text Markup Language 超文本标记语言；定义网页中有什么<br>CSS： Cascading Style Sheets 层叠样式表；定义网页中的东西长什么样</p>
<p>VSCode： Visual Studio Code 通用编辑器<br>MD： MarkDown，文档格式标准</p>
<p>Web： 互联网<br>W3C: 万维网联盟，非营利性组织: w3.org 为互联网提供各种标准<br>XML: Extension markup language 可扩展标记语言，用于定义文档结构<br>MDN： Mozilla Development Network, Mozilla开发者社区</p>
<h2 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h2><p>HTML是W3C组织定义的语言标准： 用于描述页面结构的语言</p>
<h2 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h2><p>CSS是W3C定义的语言标准： CSS用于描述页面结构的语言</p>
<h2 id="执行HTML-CSS"><a href="#执行HTML-CSS" class="headerlink" title="执行HTML CSS"></a>执行HTML CSS</h2><p>HTML&amp;CSS –&gt; 浏览器内核 –&gt; 页面</p>
<p>浏览器：由shell(外壳)和core(内核 JS执行引擎、渲染引擎)组成</p>
<p>常见浏览器(包含自己的内核)： </p>
<ol>
<li>IE: Trident</li>
<li>Firefox: Gecko</li>
<li>Chrome: Webkit / Blink</li>
<li>Safari: Webkit</li>
<li>Opera: Presto(已弃用) / Blink</li>
</ol>
<h2 id="版本和兼容性"><a href="#版本和兼容性" class="headerlink" title="版本和兼容性"></a>版本和兼容性</h2><p>HTML5、CSS3</p>
<p>HTML5： 2014年发布，目前浏览器基本都兼容</p>
<p>CSS3： 目前还未定制完成</p>
<p>XHTML： 可以认为是HTML的一种版本，完全符合XML的规范(HTML5发布后，已弃用)</p>
<h1 id="第一个页面"><a href="#第一个页面" class="headerlink" title="第一个页面"></a>第一个页面</h1><p>Emmet插件： 自动生成Html代码的插件，VSCode自带此插件</p>
<p>快捷键：输入<code>!</code>后按<code>tab</code>键会自动生成html5代码；输入标签后按<code>tab</code>键可补全标签代码</p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>注释为diamante的阅读者提供帮助，注释不参与运行</p>
<p>使用 <code>&lt;!-- --&gt;</code> 进行注释，快捷键：<code>ctrl + /</code></p>
<h2 id="元素-标签、标记、element"><a href="#元素-标签、标记、element" class="headerlink" title="元素(标签、标记、element)"></a>元素(标签、标记、element)</h2><p>元素 = 起始标记(begin tag) + 结束标记(end tag) + 元素内容(页面上需要显示的内容) + 元素属性(描写元素的额外信息)</p>
<ol>
<li><p>空元素： 没有结束标记的元素，如： <code>&lt;img/&gt;</code> <code>&lt;input/&gt;</code></p>
<p> 空元素的两种写法：</p>
 <figure class="highlight plain"><figcaption><span>charset</span></figcaption><table><tr><td class="code"><pre><span class="line">    ``` &lt;meta charset=&quot;UTF-8&quot;/&gt;``` </span><br><span class="line"></span><br><span class="line">    html5中空元素可以不加后面的`/`</span><br><span class="line"></span><br><span class="line">2. 元素属性 = 属性名 + 属性值</span><br><span class="line"></span><br><span class="line">    属性的分类：</span><br><span class="line"></span><br><span class="line">    - 局部属性： 某些元素特有的属性</span><br><span class="line">    - 全局属性： 所有元素通用</span><br><span class="line"></span><br><span class="line">## 元素的嵌套</span><br><span class="line"></span><br><span class="line">父元素、子元素、祖先元素、后代元素、兄弟元素(拥有同一父元素)</span><br><span class="line"></span><br><span class="line">## 标准文档结构</span><br><span class="line"></span><br><span class="line">文档声明：告诉浏览器当前文档使用的HTML标准是HTML5。不写文档声明将导致浏览器进入怪异渲染模式</span><br><span class="line"></span><br><span class="line">    ```html</span><br><span class="line">    &lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根元素(<code>&lt;html&gt;</code>)： 一个页面最多只能有一个，且该元素是所有元素的父元素或祖先元素。HTML5中没有强制要求写此元素，但最好写上以兼容以往版本。其中lang属性为全局属性，表示该元素内部使用的文字是哪种自然语言，声明此属性是为了触发浏览器中翻译、语音等插件。</p>
<pre><code>`lang=&quot;cmn-hans&quot;`表示中国大陆官方简体中文，`lang=&quot;zh-CN&quot;`已过时。

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><p>文档头(<code>&lt;head&gt;</code>): 文档头内部的内容不会显示到页面上</p>
<p>文档的元数据(<code>&lt;meta&gt;</code>)： 附加信息</p>
<p>charset: 指定网页内容编码</p>
<p>计算机中，电子元件接触到低压电(0~2V)时，用0表示,接触到高压电(2~5 V)时，用1表示。因此计算机中只能存储数字</p>
<p>文字和数字进行对应</p>
<p>比如： a - 97, A - 64</p>
<p>此种规律(字典)叫做字符编码表，GB2312 大陆用的编码表  GBK 台湾用的编码表  UTF-8 是unicode编码的一个版本</p>
<p>Unicode是万国码 将全世界的文字融合 有很多版本 UTF-8 是其中之一</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> <span class="comment">&lt;!-- 文档声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> <span class="comment">&lt;!-- 根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 文档头 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span> <span class="comment">&lt;!-- 元数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span> <span class="comment">&lt;!-- 用于适配手机端 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span><span class="comment">&lt;!-- 用于解决IE浏览器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 网页标题，显示在浏览器标签，不显示在网页内容中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 文档体，页面上所有要参与显示的元素都应该放在文档体中 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h1><h2 id="什么是语义化"><a href="#什么是语义化" class="headerlink" title="什么是语义化"></a>什么是语义化</h2><ol>
<li>每一个HTML元素都有具体的含义</li>
</ol>
<p>a元素： 超链接<br>p元素： 段落<br>h1元素： 一级标题</p>
<ol start="2">
<li>所有元素与展示效果无关</li>
</ol>
<p>元素展示到页面的效果，应该由CSS决定</p>
<p>因为浏览器带有默认的CSS样式，所以每个元素有一些默认样式</p>
<p><strong>重要： 选择什么元素，取决于内容的含义，而不是显示出的效果</strong></p>
<h2 id="为什么需要语义化？"><a href="#为什么需要语义化？" class="headerlink" title="为什么需要语义化？"></a>为什么需要语义化？</h2><ol>
<li>为了搜索引擎优化(SEO)</li>
</ol>
<p>搜索引擎： 百度、搜搜、Bing、Google</p>
<p>每隔一段时间，搜索引擎会从整个互联网中，抓取网页源代码，搜索引擎根据语义化标签来理解网页，语义化越好，搜索引擎就越能理解网页</p>
<ol start="2">
<li>为了让浏览器理解网页</li>
</ol>
<p>阅读模式、语音模式</p>
<h1 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h1><p>HTML5中支持的元素： HTML5元素周期表 (<a href="http://www.xuanfengge.com/funny/html5/element/" target="_blank" rel="noopener">http://www.xuanfengge.com/funny/html5/element/</a>)</p>
<h2 id="h"><a href="#h" class="headerlink" title="h"></a>h</h2><p>标题： head</p>
<p>h1~h6： 表示一级标题到六级标题</p>
<h2 id="p"><a href="#p" class="headerlink" title="p"></a>p</h2><p>段落: paragraphs</p>
<h2 id="span【无语义】"><a href="#span【无语义】" class="headerlink" title="span【无语义】"></a>span【无语义】</h2><p>没有语义，仅用于设置样式</p>
<p>某些元素在显示时会独占一行(Html5之前称为块级元素,h5已弃用此说法)，而某些元素不会(Html5之前称为行级元素，h5已弃用此说法)；</p>
<h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><p>预格式化文本元素</p>
<p>空白折叠： 在源代码中的连续空白字符（空格、换行、制表tab），在页面显示时会被折叠成一个空格</p>
<p>在pre元素中的内容不会出现空白折叠，即在pre元素内部出现的内容，会按照源代码格式显示到页面上</p>
<p>该元素通常用于在网页中显示一些代码。</p>
<p>pre元素功能的本质： 它有一个默认的CSS属性 <code>white-space: pre</code></p>
<p>显示代码时，通常外面套code元素，code表示代码区域。</p>
<h1 id="HTML实体"><a href="#HTML实体" class="headerlink" title="HTML实体"></a>HTML实体</h1><p>实体字符， HTML Entity</p>
<p>通常用于在页面中现实一些特殊符号。</p>
<p>书写格式： </p>
<ol>
<li>&amp;单词缩写; (常用)</li>
<li>&amp;#数字;</li>
</ol>
<p>常用的实体字符：</p>
<ul>
<li>小于符号：</li>
</ul>
<p><code>&amp;lt;</code>  (lt是less than 的缩写)<br><code>&amp;#60;</code></p>
<ul>
<li>大于符号: </li>
</ul>
<p><code>&amp;gt;</code> (gt 是 greater than 的缩写)</p>
<ul>
<li>空格符号：</li>
</ul>
<p><code>&amp;nbsp;</code> (nbsp 是 non-breaking space 的缩写)</p>
<ul>
<li>版权符号 <code>©</code></li>
</ul>
<p><code>&amp;copy;</code></p>
<ul>
<li><code>&amp;</code>符号</li>
</ul>
<p><code>&amp;amp;</code></p>
<h1 id="a元素"><a href="#a元素" class="headerlink" title="a元素"></a>a元素</h1><p>超链接</p>
<h2 id="href属性"><a href="#href属性" class="headerlink" title="href属性"></a>href属性</h2><p>hyper reference： 通常表示跳转地址</p>
<ol>
<li>普通链接： 跳转地址 (<code>href=&quot;www.baidu.com&quot;</code> 跳转到百度)</li>
<li><p>锚链接： 跳转某个锚点,需要定义id属性(<code>href=&quot;#id&quot;</code> 定位到当前页面id的位置)</p>
<p> id属性： 全局属性，表示元素在整个HTML中的唯一标识<br> <code>href=&quot;#&quot;</code> 表示回到顶部</p>
</li>
<li><p>功能链接： 点击后，触发某个功能</p>
</li>
</ol>
<ul>
<li>执行JS代码</li>
<li>发送邮件,mailto: (要求用户计算机安装有邮件发送软件：exchange)</li>
<li>拨打电话, tel: (要求用户计算机上安装有拨号软件，或使用的是移动端访问)</li>
</ul>
<h2 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h2><p>表示跳转窗口位置。</p>
<p>target的取值：</p>
<ul>
<li><code>_self</code>: 在当前页面窗口中打开，默认值</li>
<li><code>_blank</code>: 在新窗口中打开</li>
</ul>
<h1 id="路径的写法"><a href="#路径的写法" class="headerlink" title="路径的写法"></a>路径的写法</h1><h2 id="站内资源和站外资源"><a href="#站内资源和站外资源" class="headerlink" title="站内资源和站外资源"></a>站内资源和站外资源</h2><p>站内资源： 当前网站的资源</p>
<p>站外资源： 非当前网站的资源</p>
<h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><p>对站外资源使用绝对路径，对站内资源进行相对路径</p>
<ol>
<li>绝对路径</li>
</ol>
<p>绝对路径的书写格式：</p>
<p>url地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议名：//主机名:端口号/路径</span><br><span class="line"></span><br><span class="line">schema://host:port/path</span><br></pre></td></tr></table></figure>
<p>协议名： http、https、file</p>
<p>主机名： 域名、IP地址</p>
<p>端口： 如果协议是http协议，默认端口号是80；如果协议是https协议，默认端口号是443； </p>
<p>当跳转目标和当前页面的协议相同时，可以省略协议</p>
<ol start="2">
<li>相对路径</li>
</ol>
<p>以<code>./</code>开头，<code>./</code>表示当前资源所在的目录</p>
<p>可以书写<code>../</code>表示返回上一级目录</p>
<p>相对路径中<code>./</code>可以省略</p>
<h1 id="图片元素"><a href="#图片元素" class="headerlink" title="图片元素"></a>图片元素</h1><h2 id="img元素"><a href="#img元素" class="headerlink" title="img元素"></a>img元素</h2><p>image缩写，空元素</p>
<p>src属性： source<br>alt属性： 当图片资源失效时，将使用该属性的文字替代图片</p>
<h2 id="和a元素的联用"><a href="#和a元素的联用" class="headerlink" title="和a元素的联用"></a>和a元素的联用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./xx/xx.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="和map元素联用"><a href="#和map元素联用" class="headerlink" title="和map元素联用"></a>和map元素联用</h2><p>map： 地图</p>
<p>map的子元素： area</p>
<p>area属性：</p>
<p>shape： 形状 circle 圆形 rect 矩形 poly 多边形<br>coords： 坐标 根据shape属性的不同而不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">原点坐标在图片的左上角，横向往右为X轴，纵向向下为Y轴</span><br><span class="line"></span><br><span class="line"> shape=&quot;circle&quot; coords=&quot;X轴坐标,Y轴坐标,圆的半径&quot; </span><br><span class="line"></span><br><span class="line"> shape=&quot;rect&quot; coords=&quot;矩形左上角X轴坐标,矩形左上角Y轴坐标,矩形右下角X轴坐标,矩形右下角Y轴坐标&quot; </span><br><span class="line"></span><br><span class="line"> shape=&quot;poly&quot; coords=&quot;角1的X轴坐标，角1的Y轴坐标，角2的X轴坐标，角2的Y轴坐标...&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注： 衡量坐标时，为了避免衡量误差，需要使用专业的衡量工具： ps、pxcook 等</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">usemap</span>=<span class="string">"#solarMap"</span> <span class="attr">src</span>=<span class="string">"./xx/xx.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"solarMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="和figure元素联用"><a href="#和figure元素联用" class="headerlink" title="和figure元素联用"></a>和figure元素联用</h2><p>指代、定义，通常用于把图片、图片标题、描述包裹起来</p>
<p>子元素： figcaption 通常用于包裹图片标题</p>
<h1 id="多媒体元素"><a href="#多媒体元素" class="headerlink" title="多媒体元素"></a>多媒体元素</h1><p>video 视频</p>
<p>audio 音频</p>
<h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p>controls: 控制控件的显示，取值只能为controls</p>
<p>某些属性只有两种状态：1. 不写 2. 取值为属性名，这种属性叫做布尔属性</p>
<p>布尔属性在HTML5中可以不写属性值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span><span class="comment">&lt;!-- 布尔属性，省略属性值 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>video中的布尔属性： </p>
<p>controls 控制控件</p>
<p>autoplay 自动播放</p>
<p>muted 静音播放</p>
<p>loop 循环播放</p>
<h2 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h2><p>音频和视频的使用完全一致，属性相同</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol>
<li>旧版本的浏览器不支持这两个元素</li>
</ol>
<p>对于不支持的浏览器，以前可以换成flash,但由于谷歌浏览器宣布不再支持flash，因此只能提示用户更新浏览器</p>
<ol start="2">
<li>不同的浏览器支持的音频、视频格式可能不一致</li>
</ol>
<p>使用<code>&lt;video&gt;</code>的子元素<code>&lt;source&gt;</code>放置多种格式以获得浏览器最好的兼容性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx/xxx.mp4"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"xxx/xxx.webm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="列表元素"><a href="#列表元素" class="headerlink" title="列表元素"></a>列表元素</h1><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>ol: ordered list</p>
<p>li: list item</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">把大象装冰箱，总共分几步？</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>打开冰箱门<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>大象进去<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>关上冰箱门<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ul>
<li><p><code>type</code>(不建议使用)</p>
<p>1 表示使用数字排列 </p>
<p>i 表示使用罗马数字排列 </p>
<p>a表示使用字母排列</p>
<p><strong>type属性曾经在HTML4被弃用过，但是在HTML5中被重新引入。除非列表中序号很重要（比如法律或技术文件中条目通常被需要所引用），否则请使用 CSS list-style-type 属性代替</strong></p>
<ul>
<li><code>reversed</code></li>
</ul>
<p>顺序倒叙</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>ul: unordered list</p>
<p>li: list item</p>
<p>无序列表常用于制作菜单或新闻列表</p>
<h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p>通常用于一些术语的定义</p>
<p>dl: difinition list</p>
<p>dt: definition title</p>
<p>dd: definition description</p>
</li>
</ul>
<h1 id="容器元素"><a href="#容器元素" class="headerlink" title="容器元素"></a>容器元素</h1><p>容器元素： 该元素代表一个块区域，内部用于放置其他元素</p>
<h2 id="div元素"><a href="#div元素" class="headerlink" title="div元素"></a>div元素</h2><p>无语义</p>
<h2 id="语义化容器元素"><a href="#语义化容器元素" class="headerlink" title="语义化容器元素"></a>语义化容器元素</h2><p>header： 通常用于表示页头，也可以表示文章的头部</p>
<p>footer: 通常用于表示页脚，也可以表示文章的尾部</p>
<p>article: 通常用于表示整篇文章</p>
<p>section: 通常用于表示文章的章节</p>
<p>aside: 通常用于表示侧边栏(附加信息)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        页头</span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span>文章头<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Pariatur excepturi, eius deserunt incidunt sint eveniet earum adipisci obcaecati, unde repellendus nam minus minima blanditiis nesciunt quas qui veritatis dicta at.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Amet nobis deserunt facere in nulla consectetur consequatur quos doloremque nam dolor impedit sequi quas veniam, harum, recusandae, tenetur ducimus assumenda. Totam ad repudiandae ipsam ducimus harum recusandae, quaerat eum?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Porro deleniti, corporis totam autem quos inventore quis voluptas, eum ex, molestias eos aperiam vero voluptate error qui a? Ipsam impedit alias odio ab vitae voluptatibus quas suscipit numquam non?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span>文章尾<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span>边侧栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        页脚</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="元素包含关系"><a href="#元素包含关系" class="headerlink" title="元素包含关系"></a>元素包含关系</h1><p>以前： 块级元素可以包含行级元素，行级元素不可以包含块级元素，a元素除外</p>
<p>现在： 元素的包含关系由元素的内容类别决定</p>
<p>例如，查看h1元素中是否可以包含p元素</p>
<p>总结：</p>
<ol>
<li>容器元素可以包含任何元素</li>
<li>a元素中几乎可以包含任何元素</li>
<li>某些元素有固定的子元素(ul&gt;li,ol&gt;li,dl&gt;dt+dd)</li>
<li>标题元素和段落元素不能相互嵌套，并且不能包含容器元素</li>
</ol>
<hr>
<p>参考视频</p>
<p> <a href="https://www.bilibili.com/video/av57100756?from=search&amp;seid=2646463889570770154" target="_blank" rel="noopener">https://www.bilibili.com/video/av57100756?from=search&amp;seid=2646463889570770154</a> (2019年 HTML+CSS 零基础权威入学宝典【渡一教育】p1~p15)</p>
]]></content>
      <categories>
        <category>web,html</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2020/02/04/miniProgram/wechat_miniprogram/</url>
    <content><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>参考微信小程序官方文档： <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html</a></p>
<ol>
<li>注册账号</li>
</ol>
<ul>
<li><p>每个邮箱仅能申请一个小程序</p>
</li>
<li><p>邮箱必须未被微信公众号注册且未被微信用户绑定</p>
</li>
</ul>
<ol start="2">
<li><p>获取APPID</p>
</li>
<li><p>下载微信小程序开发工具，下载地址： <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
</li>
</ol>
<h1 id="小程序Demo"><a href="#小程序Demo" class="headerlink" title="小程序Demo"></a>小程序Demo</h1><p>启动微信小程序开发工具，使用测试appid新建项目。</p>
<h2 id="小程序结构目录"><a href="#小程序结构目录" class="headerlink" title="小程序结构目录"></a>小程序结构目录</h2><table>
<thead>
<tr>
<th>结构</th>
<th>传统web</th>
<th>微信小程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构</td>
<td>HTML</td>
<td>WXML</td>
</tr>
<tr>
<td>样式</td>
<td>CSS</td>
<td>WXSS</td>
</tr>
<tr>
<td>逻辑</td>
<td>JavaScript</td>
<td>JavaScript</td>
</tr>
<tr>
<td>配置</td>
<td>无</td>
<td>JSON</td>
</tr>
</tbody>
</table>
<p><strong>传统web是三层结构，微信小程序是四层结构，多了一层配置.json</strong></p>
<h2 id="初始化demo结构分析"><a href="#初始化demo结构分析" class="headerlink" title="初始化demo结构分析"></a>初始化demo结构分析</h2><ul>
<li><p>pages 用于存放页面</p>
</li>
<li><p>utils 存放工具类</p>
</li>
<li><p>app.js 小程序入口文件</p>
</li>
<li><p>app.json 公共配置文件，配置小程序大体结构(默认标题等)</p>
</li>
<li><p>app.wxss 全局样式</p>
</li>
<li><p>project.config.json 对应小程序开发工具详情中的内容</p>
</li>
</ul>
<h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>一个小程序应用包括最基本的两种配置文件： 全局设置的app.json和页面自己的page.json</p>
<p><strong>配置文件中不能出现注释</strong></p>
<h3 id="全局配置文件app-json"><a href="#全局配置文件app-json" class="headerlink" title="全局配置文件app.json"></a>全局配置文件app.json</h3><p>全局配置文件可配置小程序的所有页面路径、界面表现、网络超时时间、底部tab等。</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html</a></p>
<p>Demo中的默认配置如下： </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"window"</span>: &#123;</span><br><span class="line">    <span class="attr">"backgroundTextStyle"</span>: <span class="string">"light"</span>,</span><br><span class="line">    <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"WeChat"</span>,</span><br><span class="line">    <span class="attr">"navigationBarTextStyle"</span>: <span class="string">"black"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"style"</span>: <span class="string">"v2"</span>,</span><br><span class="line">  <span class="attr">"sitemapLocation"</span>: <span class="string">"sitemap.json"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>pages 整个小程序中拥有的页面路径</p>
<p>  一般新增页面时需要进行两步操作： 1. 在指定位置新增页面 2. 将新增页面路径填入app.json的pages中</p>
<p>  使用小程序开发工具，直接在app.json中添加pages路径，编译后会自动新增文件和文件夹</p>
<p>  小程序加载顺序是根据页面路径的配置而来</p>
</li>
<li><p>window</p>
<p>  设置小程序的状态栏、导航条、标题、窗口背景色等</p>
<p>  <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window</a></p>
</li>
<li><p>tabBar </p>
<p>  配置底部导航栏</p>
<ul>
<li><p><code>list</code>: tab的列表，最少 2 个、最多 5 个 tab<br>  tab 按数组的顺序排序，每个项都是一个对象，其属性值只有四个：<br>  <code>pagePath</code>、<code>text</code>、<code>iconPath</code>、<code>selectedIconPath</code></p>
</li>
<li><p><code>color</code>: tab 上的文字默认颜色，仅支持十六进制颜色</p>
<p>示例： </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    <span class="attr">"pages"</span>: [<span class="string">"pages/index/index"</span>, <span class="string">"pages/logs/index"</span>],</span><br><span class="line">    <span class="attr">"window"</span>: &#123;</span><br><span class="line">        <span class="attr">"navigationBarTitleText"</span>: <span class="string">"Demo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tabBar"</span>: &#123;</span><br><span class="line">        <span class="attr">"list"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"pagePath"</span>: <span class="string">"pages/index/index"</span>,</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"首页"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"pagePath"</span>: <span class="string">"pages/logs/logs"</span>,</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"日志"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"networkTimeout"</span>: &#123;</span><br><span class="line">        <span class="attr">"request"</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">"downloadFile"</span>: <span class="number">10000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"navigateToMiniProgramAppIdList"</span>: [<span class="string">"wxe5f52902cf4de896"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页面配置文件"><a href="#页面配置文件" class="headerlink" title="页面配置文件"></a>页面配置文件</h3><p>用来表示页面目录下的<code>page.json</code>和小程序页面相关的配置，可以在此独立定义每个页面的一些属性，如顶部颜色、是否允许下拉刷新等。</p>
<p>页面的配置只能设置app.json中部分<code>window</code>配置项的内容，页面中的配置项会覆盖<code>app.json</code>的<code>window</code>中相同的配置项</p>
<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p><code>WXML(WeiXin Markup Language)</code>是框架设计的一套语言，集合基础组件、事件系统可以构建出页面的结构</p>
<h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/view.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/view.html</a></p>
<p>名称|    功能说明<br>-|-<br><code>cover-image</code>|    覆盖在原生组件之上的图片视图<br><code>cover-view</code>|    覆盖在原生组件之上的文本视图<br><code>movable-area</code>|    movable-view的可移动区域<br><code>movable-view</code>|    可移动的视图容器，在页面中可以拖拽滑动<br><code>scroll-view</code>|    可滚动视图区域<br><code>swiper</code>|    滑块视图容器<br><code>swiper-item</code>    |仅可放置在swiper组件中，宽高自动设置为100%<br><code>view</code>|    视图容器</p>
</li>
<li><p><code>view</code> 标签</p>
<p>  类似于<code>div</code>，但有自己的属性</p>
<p>  如<code>hover-class</code>表示 指定按下去的样式类</p>
</li>
<li><p><code>text</code>标签</p>
<p>  显示普通的文本，只能嵌套text</p>
<p>  <code>selectable</code> 表示文本是否可选，默认为否</p>
<p>  <code>decode</code> 表示是否解码，默认为否</p>
</li>
<li><p><code>image</code>图片标签</p>
<p>  默认宽度为320px,高度240px</p>
<p>  <strong>此标签其实是web中的图片标签和背景图片的结合，并且不支持web中的背景图片的写法</strong></p>
<p>  属性名| 类型 | 默认值 | 说明<br>  -|-|-|-<br>  src|string| |图片地址<br>  mode|String|’scaleToFill’|图片裁剪、缩放的模式<br>  lazy-load|Boolean|false|图片懒加载，只针对page与scroll-view下的image起作用</p>
</li>
<li><p><code>swiper</code>标签</p>
<p>  轮播图组件，默认宽度100%,高度150%</p>
<p>  子元素必须有<code>swiper-item</code></p>
</li>
<li><p><code>navigator</code>标签</p>
<p>  导航组件，类似超链接标签</p>
<p>  <code>target</code>: 在哪个目标发生跳转，默认当前小程序，可选值self/miniProgram</p>
<p>  <code>url</code>: 当前小程序内跳转链接</p>
<p>  <code>open-type</code>: 跳转方式</p>
</li>
<li><p><code>video</code></p>
<p>  视频。原生组件，类似于web中的video</p>
</li>
<li><p>自定义组件</p>
<p>  一个组件由<code>json</code> <code>wxml</code> <code>wxss</code> <code>js</code> 4个文件组成</p>
<ol>
<li><p>声明组件</p>
<p> 需要在json文件中进行自定义组件声明</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑组件</p>
</li>
<li><p>使用自定义组件</p>
<p> 在页面的<code>json</code>文件中进行引用声明，并提供对应的组件名和组件路径</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 引用声明</span><br><span class="line">    "usingComponents": &#123;</span><br><span class="line">        // 要使用的组件名称     // 组件的路径</span><br><span class="line">        "component-tag-name": "path/to/the/custom/component"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>WXML文件中使用&#123;&#123;&#125;&#125;</p>
<p>属性中要体现布尔类型的值，也必须加上两个大括号。</p>
<p>错误写法: <code>&lt;checkbox checked=&quot;false&quot;&gt;&lt;/checkbox&gt;</code></p>
<p>正确写法: <code>&lt;checkbox checked=&quot;&amp;#123;&amp;#123;false&amp;#125;&amp;#125flase&quot;&gt;&lt;/checkbox&gt;</code></p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3></li>
<li><p>三元运算</p>
<p>  <code>&lt;view hidden=&quot;&amp;#123;&amp;#123; flag ? true : false &amp;#125;&amp;#125&quot;&gt;Hidden&lt;/view&gt;</code></p>
</li>
<li><p>算术运算</p>
<p>  在&#123;&#123;&#125;&#125;中直接进行算术运算</p>
</li>
<li><p>逻辑判断</p>
<p>  <code>wx:if</code> if条件</p>
<p><strong>花括号和引号之间如果有空格，最终将被解析成字符串</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p><code>wx:for</code></p>
<p>项的变量名默认为<code>item</code>，<code>wx:for-item</code>可以指定数组当前元素的变量名</p>
<p>下标变量名默认为<code>index</code>, <code>wx:for-inidex</code>可以指定数组当前下标的变量名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123;index&#125;&#125;: &#123;&#123;item.meaasge&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        array:[&#123;</span><br><span class="line">            message: 'hello'</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            message:'what'</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h3><p>WXSS(WeiXin Style Sheet)是一套样式语言，用于描述WXML的组件样式，与CSS相比，WXSS扩展的特性有： 尺寸单位、样式导入</p>
<ul>
<li><p>尺寸单位<code>rpx</code></p>
<p>  <code>rpx</code>(responsive pixel): 可根据屏幕宽度进行自适应</p>
</li>
<li><p>样式导入</p>
</li>
</ul>
<p>使用<code>import</code>语句导入</p>
<p><code>@import &quot;被导入文件路径&quot;</code></p>
<p><strong>样式文件wxss中的注释不能用<code>//</code>,只能用`/</strong>/`**</p>
]]></content>
      <categories>
        <category>miniProgram</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>miniProgram</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2020/02/01/Nginx/Nginx/</url>
    <content><![CDATA[<h1 id="Nginx背景"><a href="#Nginx背景" class="headerlink" title="Nginx背景"></a>Nginx背景</h1><p>Nginx与Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符（Uniform Resoucrces Identifier）URI或者统一资源定位符(Uniform Resources Locator)URL作为共同一句，通过HTTP协议提供各种网络服务。</p>
<p><code>REST架构风格</code>: 架构的一种编码规范</p>
<p>普通的请求格式为： 域名:端口号/接口地址 e.g. <a href="http://ip:port/queryUserInfo?id=1" target="_blank" rel="noopener">http://ip:port/queryUserInfo?id=1</a></p>
<p>使用REST风格的请求方式： <a href="http://ip:port/queryUserInfo/1" target="_blank" rel="noopener">http://ip:port/queryUserInfo/1</a></p>
<p><code>Apache</code></p>
<p>优点： 稳定 开源 跨平台</p>
<p>缺点: 重量级 不支持高并发 运行数以万计的并发访问会导致服务器消耗大量内存</p>
<h1 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h1><ul>
<li><p>高性能的HTTP和反向代理web服务器，轻量级</p>
</li>
<li><p>提供IMAP/POP3/SMTP服务</p>
</li>
<li><p>发布于2004年10月4日(第一个公开版本为0.1.0)，稳定版1.4.0与2013年4月24日发布，选择1.4.0之后的版本使用</p>
</li>
<li><p>由C语言编写</p>
</li>
<li><p>跨平台服务器</p>
</li>
<li><p>Nginx有自己的函数库，并且除了zlib PCRE 和OpenSSL之外，标准模块只使用系统库C库函数，如不需要或考虑到潜在的授权冲突，可以不使用这些第三方库</p>
</li>
</ul>
<h1 id="Nginx优势"><a href="#Nginx优势" class="headerlink" title="Nginx优势"></a>Nginx优势</h1><ul>
<li><p>占有内存少，在3w并发的连接中，开启10个nginx进程消耗内存大约为150M</p>
</li>
<li><p>处理高并发能力强，官方测试能支持5w并发连接</p>
</li>
<li><p>简单，配置文件通俗易懂</p>
</li>
<li><p>免费、开源</p>
</li>
<li><p>支持Rewriter重写，能根据域名、URL的不同，将HTPP请求分到不同的后端服务器群组</p>
</li>
<li><p>内置健康检查，如果nginx后端有几个服务器宕机了，不会影响前端访问，能自动检测服务状态</p>
</li>
<li><p>节省带宽，支持GZIP压缩，可以添加浏览器本地缓存的Header头</p>
</li>
<li><p>稳定性高，反向代理，很少宕机</p>
</li>
</ul>
<h1 id="Nginx应用场景"><a href="#Nginx应用场景" class="headerlink" title="Nginx应用场景"></a>Nginx应用场景</h1><h2 id="功能与应用场景"><a href="#功能与应用场景" class="headerlink" title="功能与应用场景"></a>功能与应用场景</h2><ul>
<li><p>web服务器、轻量级 —— 充当代理服务器</p>
</li>
<li><p>负载均衡 —— IP负载、静态负载</p>
</li>
<li><p>支持缓存 —— 动静分离</p>
</li>
<li><p>能处理高并发 —— 限流、健康监控</p>
</li>
</ul>
<h1 id="Linux下Nginx安装-未跟着操作，此段先跳过"><a href="#Linux下Nginx安装-未跟着操作，此段先跳过" class="headerlink" title="Linux下Nginx安装(未跟着操作，此段先跳过)"></a>Linux下Nginx安装(未跟着操作，此段先跳过)</h1><h1 id="Nginx命令-Linux环境下"><a href="#Nginx命令-Linux环境下" class="headerlink" title="Nginx命令(Linux环境下)"></a>Nginx命令(Linux环境下)</h1><h2 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h2><p><code>cd sbin/</code> 切换到安装目录下的<code>/sbin</code>目录，该目录下有<code>nginx</code>的命令</p>
<p><code>./nginx</code> 直接运行<code>nginx</code>命令</p>
<h3 id="查看Nginx是否启动成功"><a href="#查看Nginx是否启动成功" class="headerlink" title="查看Nginx是否启动成功"></a>查看Nginx是否启动成功</h3><p>方法1： <code>ss -tanl</code> </p>
<pre><code>查看正在运行的端口号，找到nginx默认端口号`80`，若`80`端口正常启动，表示Nginx启动成功
</code></pre><p>方法2： <code>ps -ef|grep nginx</code></p>
<pre><code>查看nginx的进程，若启动成功则会出现两个nginx进程，master为主进程，负责接收请求；worker为子进程，负责转发请求
</code></pre><p>方法3： 在浏览器中输入<code>服务器ip</code>,若访问不到，可能是因为当前机器无法访问服务器，若服务器本地访问不到端口，应先开启端口 (虚拟机的防火墙需要通过80端口，自己的电脑关闭防火墙)</p>
<pre><code>开启端口: `/sbin/iptables -I INPUT -p tcp --dport -j ACCEPT`

若端口开启后依旧访问不到，则需要关闭本地防火墙
</code></pre><p>出现<code>Welcome to nginx!</code>界面则表示启动成功</p>
<h2 id="停止Nginx"><a href="#停止Nginx" class="headerlink" title="停止Nginx"></a>停止Nginx</h2><p>使用 <code>./nginx -s stop</code> 或 <code>./nginx -s quit</code>命令都能停止运行</p>
<ul>
<li><p><code>./nginx -s stop</code> 先查出nginx的进程id再使用kill命令强制杀掉进程</p>
</li>
<li><p><code>./nginx -s quit</code> 待nginx进程处理任务完毕进行停止</p>
</li>
</ul>
<h2 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h2><p><code>./nginx -s reload</code></p>
<h1 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h1><p>打开配置文件夹中的<code>nginx.conf</code>文件，默认的配置文件中包含三个大模块：</p>
<ul>
<li><p>基础全局模块： </p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"># nginx进程数，建议设置为CPU总核心数，默认为1</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 定义全局错误日志类型 [debug | info | notice | warn | error | crit]</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line"># 进程pid文件，指定nginx进程运行文件存放地址</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"># 最大打开文件数连接,连接上限，与工作模式相关</span><br><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>事件模块(events)</p>
</li>
</ul>
<p>用于配置网络模块，网络信息</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    # 单个进程最大连接数 最大连接数=连接数*进程数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    # 网络连接超时时间，默认为60s</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    # 头部信息的缓存大小</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>请求(http)模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">		</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       9000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ol>
<li>HTTP模块(代理、缓存、日志定义和第三方模块)</li>
<li>EVENTS模块(网络连接)</li>
<li>全局模块(全局指令，日志路径，PID路径，用户信息等)</li>
</ol>
<h3 id="HTTP模块子模块"><a href="#HTTP模块子模块" class="headerlink" title="HTTP模块子模块"></a>HTTP模块子模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    http &#123;</span><br><span class="line">    </span><br><span class="line">    #### 全局模块 </span><br><span class="line"></span><br><span class="line">    # 文件扩展名与文件类型映射表</span><br><span class="line">    include       mime.types;</span><br><span class="line"></span><br><span class="line">    # 默认的文件类型(stream流类型、text类型、XML、HTML等，默认为字符流)</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 默认编码 默认为utf-8</span><br><span class="line">    # charset utf-8;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    #### FASTCGI模块 用于改善网络性能，减少资源占用，提高访问速度</span><br><span class="line"></span><br><span class="line">    # fastcgi_connect_timeout 300;</span><br><span class="line">    # fastcgi_send_timeout 300;</span><br><span class="line">    # fastcgi_read_timeout 300;</span><br><span class="line"></span><br><span class="line">    #### Gzip模块 </span><br><span class="line"></span><br><span class="line">    # 默认关闭压缩模式</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #### server模块，虚拟主机模块，一个http可以含有多个server</span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听端口</span><br><span class="line">        listen       80;</span><br><span class="line"></span><br><span class="line">        # 域名可以有多个， 用空格隔开</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">		</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       9000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>正向代理、反向代理、透明代理</p>
<p>Ngnix下载安装后默认为正向代理，但Nginx最常用的是反向代理，因此需要手动配置。</p>
<p>Nginx配置中，若<code>http</code>模块配置了<code>upstream servermap</code>则表示反向代理，无则为正向代理，默认为无。</p>
<h1 id="Nginx集群搭建"><a href="#Nginx集群搭建" class="headerlink" title="Nginx集群搭建"></a>Nginx集群搭建</h1><ol>
<li><p>搭建三台tomcat服务器及一台代理服务器nginx，并保证分别可以单独访问</p>
</li>
<li><p>配置nginx</p>
<ul>
<li><p><code>cp nginx.conf nginx.conf.bak</code> </p>
<p>  备份<code>nginx.conf</code>文件，命名为<code>nginx.conf.bak</code></p>
</li>
<li><p><code>vi nginx.conf</code> 修改<code>nginx.conf</code>文件</p>
<p>在<code>nginx.conf</code>文件中的<code>http</code>模块中添加反向代理配置： </p>
<p>a. 配置服务器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    # 将请求转发到以下配置中的服务器中</span><br><span class="line">    upstream localhost &#123;</span><br><span class="line">        server 第一台服务器的ip或域名;</span><br><span class="line">        server 第二台服务器的ip或域名;</span><br><span class="line">        server 第三台服务器的ip或域名;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>b. 修改默认重定向地址

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    # 将请求转发到以下配置中的服务器中</span><br><span class="line">    upstream localhost &#123;</span><br><span class="line">        server 第一台服务器的ip或域名;</span><br><span class="line">        server 第二台服务器的ip或域名;</span><br><span class="line">        server 第三台服务器的ip或域名;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # root html;</span><br><span class="line">            # index index.html index.htm;</span><br><span class="line"></span><br><span class="line">            # 添加请求代理配置</span><br><span class="line">            proxy_pass http://localhost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`proxy_pass`和`updstream`后面跟的都是`server_name`,即上述改动中，浏览器访问`http://localhost:80`时，会先找到代理配置` proxy_pass http://localhost;`,再根据`upstream`中`server_name`为`localhost`的配置启动对应的服务器。
</code></pre><ol start="3">
<li>修改完<code>nginx.conf</code>文件后需要重启<code>nginx</code></li>
</ol>
<h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><p>Nginx支持的负载策略： 轮询法(默认)、加权轮询法(权重法)、源地址哈希法、最小连接数法、第三方法则(Fair、url_hash)</p>
<h2 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h2><p>将请求按照顺序轮流分配到后端服务器上，均衡地对待后端的每一台服务器，不关心服务器实际的连接数和当前的系统负载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">    server 192.168.1.1:8080 weight=1;</span><br><span class="line">    server 192.168.1.2:8080 weight=1;</span><br><span class="line">    server 192.168.1.3:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置中<code>weight</code>表示权重，值越大表示权重越高，接收请求的几率越大，连接数越多。<code>weight</code>相同时，还是轮询法，可不写<code>weight</code></p>
<h2 id="加权轮询法-weight"><a href="#加权轮询法-weight" class="headerlink" title="加权轮询法(weight)"></a>加权轮询法(weight)</h2><p>性能比较强的服务器可以将<code>weight</code>值调高一点</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">    server 192.168.1.1:8080 weight=10;</span><br><span class="line">    server 192.168.1.2:8080 weight=3;</span><br><span class="line">    server 192.168.1.3:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="源地址哈希法"><a href="#源地址哈希法" class="headerlink" title="源地址哈希法"></a>源地址哈希法</h2><p>Nginx获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的个数进行取模运算，得到的结果便是客户端要访问服务器的序号，同一个ip地址最终计算出来的后端服务器的序号是一致的。</p>
<p>哈希法可以保证同一个ip的请求被打到固定的机器上，可以解决集群模式下session共享问题：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">    # 使用哈希法</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.1.1:8080 weight=1;</span><br><span class="line">    server 192.168.1.2:8080 weight=1;</span><br><span class="line">    server 192.168.1.3:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h2><p>由于后台服务器配置不尽相同，对于请求的速度有快有慢，最小连接数法根据后台服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用率，合理分流到每台服务器。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">    # 使用最小连接数法</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.1:8080 weight=1;</span><br><span class="line">    server 192.168.1.2:8080 weight=1;</span><br><span class="line">    server 192.168.1.3:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="第三方模块算法"><a href="#第三方模块算法" class="headerlink" title="第三方模块算法"></a>第三方模块算法</h2><h3 id="第三方模块的下载和安装"><a href="#第三方模块的下载和安装" class="headerlink" title="第三方模块的下载和安装"></a>第三方模块的下载和安装</h3><h4 id="Fair插件安装"><a href="#Fair插件安装" class="headerlink" title="Fair插件安装"></a>Fair插件安装</h4><ul>
<li><p>下载地址： <a href="https://github.com/gnosek/nginx-upstream-fair" target="_blank" rel="noopener">https://github.com/gnosek/nginx-upstream-fair</a></p>
</li>
<li><p>解压zip</p>
</li>
<li><p>增加模块: <code>./configure --prefix=/opt/nginx --add-module=/opt/nginx-upstream-fair-master</code></p>
</li>
<li><p>default_port问题修改： <code>cd nginx-upstream-fair-master</code></p>
</li>
<li><p><code>sed -i &#39;s/default_port/no_port/g&#39; ngx_http_upstream_fair_module.c</code></p>
</li>
<li><p><code>make</code></p>
</li>
<li><p><code>make install</code></p>
</li>
</ul>
<h4 id="hash插件安装"><a href="#hash插件安装" class="headerlink" title="hash插件安装"></a>hash插件安装</h4><ul>
<li><p>下载地址: <a href="https://github.com/evanmiller/nginx_upstream_hash" target="_blank" rel="noopener">https://github.com/evanmiller/nginx_upstream_hash</a></p>
</li>
<li><p>解压zip</p>
</li>
<li><p>增加模块 <code>./configure --prefix=/opt/nginx --add-module=/opt/nginx-upstream-hash-master</code></p>
</li>
<li><p><code>make</code></p>
</li>
<li><p><code>make install</code></p>
</li>
</ul>
<p><strong>此算法在Nginx1.7.2版本中已被废弃</strong></p>
<h3 id="Fair"><a href="#Fair" class="headerlink" title="Fair"></a>Fair</h3><ul>
<li><p>比weight、ip_hash更智能的负载均衡算法</p>
</li>
<li><p>可根据页面大小和加载时间长短智能地进行负载均衡，根据后台服务器响应时间来分配请求，相应时间段的优先分配</p>
</li>
<li><p>Nginx本身不支持fair，需要安装upstream_fair模块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">        # fair</span><br><span class="line">        fair;</span><br><span class="line">        server 192.168.1.1:8080 weight=1;</span><br><span class="line">        server 192.168.1.2:8080 weight=1;</span><br><span class="line">        server 192.168.1.3:8080 weight=1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p><strong>此算法在Nginx1.7.2版本中已被废弃</strong></p>
<p>根据访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可进一步提高后端缓存服务器的效率，使用此算法时，与<code>Fair</code>一样先安装第三方插件</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;</span><br><span class="line">        # url_hash</span><br><span class="line">        hash $request_uri;</span><br><span class="line">        server 192.168.1.1:8080 weight=1;</span><br><span class="line">        server 192.168.1.2:8080 weight=1;</span><br><span class="line">        server 192.168.1.3:8080 weight=1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库</title>
    <url>/2020/10/31/database/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序和数据的访问都有聚集成群的倾向，在一个时间段内仅使用其中一小部分（称<strong>空间局部性</strong>），或者最近访问过的程序代码和数据，很快又会被访问的可能性很大(称<strong>时间局部性</strong>)。</p>
<h3 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h3><p>磁盘预读的长度一般为页(page)的整数倍</p>
<ul>
<li>页(page)是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4k），主存和磁盘以页为单位交换数据。</li>
</ul>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><ul>
<li>索引的目的是为了加速查询</li>
<li>索引是存在磁盘中而不是内存中</li>
<li>索引的文件存储形式与存储引擎有关</li>
<li><p>索引文件的结构</p>
<ul>
<li><p>hash</p>
<p>  哈希表本质上是散列表，可以完成索引的存储，每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置即可。</p>
<p>  适合场景： </p>
<ul>
<li>等值查询</li>
<li><p>表中的数据是无序数据，范围查找的时候比较浪费时间，需要挨个进行便利操作</p>
<p>在企业中多数的查询是范围查询，因此hash表不是特别适合</p>
<p>hash表在使用的时候需要将全部数据加载到内存，比较耗费内存的空间，这点上来说，使用hash表也不是很合适</p>
</li>
</ul>
</li>
<li><p>二叉树</p>
</li>
<li>B树</li>
<li>B+树</li>
</ul>
</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>mysql索引的五种类型： 主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力</p>
<ul>
<li><p>主键索引</p>
<p>  主键索引是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键</p>
</li>
<li><p>唯一索引</p>
<p>  索引列的所有值都只能出现一次，即必须唯一，值可以为空</p>
</li>
<li><p>普通索引</p>
<p>  基本的索引类型，值可以为空，没有唯一性的限制（覆盖索引）</p>
<p>  覆盖索引： sql语句中只select索引字段</p>
<p>  覆盖索引可避免回表操作</p>
</li>
<li><p>全文索引</p>
<p>  MyISAM支持，Innodb在5.6之后支持</p>
<p>  全文索引的索引类型为FULLTEXT。全文索引可以在<code>varchar</code>、<code>char</code>、<code>text</code>类型的列上创建</p>
</li>
<li><p>组合索引</p>
<p>  多列值组成一个索引，专门用于组合搜索(最左匹配原则)</p>
<p>  最左匹配原则：优先匹配前一个字段，例如用<code>name</code>和<code>age</code>作为组合索引，使用<code>name</code>+<code>age</code>组合查询时会先匹配<code>name</code>再匹配<code>age</code>,如果没有<code>name</code>，那么<code>age</code>也无法参与匹配</p>
</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>索引在插入新的值的时候，为了维护索引的有序性，必须要维护</p>
<p>在维护索引的时候需要分以下几种情况：</p>
<ul>
<li><p>如果插入一个比较大的值，直接插入即可，几乎没有成本</p>
</li>
<li><p>如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置</p>
</li>
<li><p>如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做<strong>页分裂</strong>，此时性能会受影响，同时空间的使用率也会降低，除了页分裂之外还包括页合并</p>
</li>
<li><p>尽量使用自增主键作为索引</p>
</li>
</ul>
<h2 id="MySQL整体结构"><a href="#MySQL整体结构" class="headerlink" title="MySQL整体结构"></a>MySQL整体结构</h2><p><img src="/source/data/img/mysql/mysql整体结构.png" alt="MySQL整体结构图"></p>
<p>不同存储引擎，数据文件和索引文件存放的位置是不同的，因此有了分类：</p>
<ul>
<li><p>聚簇索引</p>
<p>数据和文件放在一起： <code>innodb</code></p>
<p><code>.frm</code>后缀文件存放的是表结构<br><code>.ibd</code>后缀文件存放的是数据文件和索引文件</p>
</li>
</ul>
<p>注意： <code>mysql</code>的<code>innodb</code>存储引擎默认情况下会把所有的数据文件放到表空间，不会为每一个单独的表保存一份数据文件，如果需要将每一个表单独使用文件保存，需要执行语句： <code>set global innodb_file_per_table = on;</code></p>
<ul>
<li><p>非聚簇索引</p>
<p>  数据和索引单独一个文件: <code>MyISAM</code></p>
<p>  <code>.frm</code>: 存放表结构<br>  <code>.MYI</code>: 存放索引数据<br>  <code>.MYD</code>: 存放实际数据</p>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li><p>数据库中最常见的慢查询优化方法是什么？</p>
</li>
<li><p>为什么加索引能优化慢查询</p>
</li>
<li><p>你知道哪些数据结构可以提高查询速度</p>
</li>
<li><p>这些数据结构既然都能优化查询速度，MySQL为何选择使用B+树？</p>
</li>
<li><p>索引下推</p>
<p>  在回表前把数据做一次筛选</p>
</li>
</ul>
<p>常见树结构： 多叉树、二叉树、AVL树、红黑树</p>
<p>树结构中，左子树必须小于根节点，右子树必须大于根节点</p>
<p>多叉树(从左到右是有序) –&gt; 二叉树(二分查找) –&gt; AVL树(平衡树) –&gt; 红黑树</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>AVL树：AVL树是一棵严格意义上的平衡树，最高子树和最低子树高度之差不能超过1，因此在进行元素插入的时候会进行1到N次的旋转，严重影响插入的性能</p>
</li>
<li><p>红黑树： 红黑树是基于AVL树的一个升级，损失了部分查询的性能来提升插入的性能，在红黑树中，最低子树跟最高子树之差小于2倍即可，例如最低子树是4层，那么最高子树不能高于8层。在插入时不需要进行N多次的旋转操作，而且还加入了变色的特性来满足插入和查询性能的平衡</p>
</li>
</ul>
<p>二叉树及其N多的变种都不能支撑索引，因为其树的深度无法控制，或者插入数据的性能比较低</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树的特点：</p>
<ol>
<li>所有键值分布在整棵树上</li>
<li>搜索有可能在非叶子节点(一个节点下面没有左右子树称为叶子节点，否则为非叶子节点)结束，在关键字全集内做一次查找性能逼近二叉树</li>
<li>每个节点最多拥有m（阶）个子树</li>
<li>根节点至少有2个子树</li>
<li>分支节点至少拥有m/2棵子树（除根节点和叶子节点外都是分支节点）</li>
<li>所有叶子节点都在同一层，每个节点最多可以有m-1个key，并且以升序排列</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是在B树的基础之上做的一种优化，变化如下：</p>
<ol>
<li>B+树每个节点可以包含更多的节点，这么做的原因有两个，第一是为了降低树的高度；第二是将数据范围变为多个区间，区间越多数据检索越快</li>
<li>非叶子节点存储Key，叶子节点存储key和数据</li>
<li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li>
</ol>
<p>注意事项：</p>
<ol>
<li>InnoDB是通过B+树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id来作为主键</li>
<li>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，此过程称为<strong>回表</strong></li>
</ol>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引类型</td>
<td>非聚簇索引</td>
<td>聚簇索引</td>
</tr>
<tr>
<td>支持事务</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持表锁</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>支持行锁</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持外键</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>是</td>
<td>是(5.6后支持)</td>
</tr>
<tr>
<td>适合操作类型</td>
<td>大量select</td>
<td>大量insert、delete、update</td>
</tr>
</tbody>
</table>
<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><p>客户端 –&gt; 连接器（管理连接，权限验证） –&gt; 查询缓存 –&gt; 分析器（词法分析，语法分析） –&gt; 优化器（执行计划，索引选择） –&gt; 执行器（操作引擎，返回结果） –&gt; 存储引擎（存储数据，提供读写接口）</p>
<p>连接器、查询缓存、分析器、优化器、执行器属于服务端</p>
<ul>
<li><p>连接器</p>
<p>  连接器负责跟客户端建立连接，获取权限、维持和管理连接</p>
<pre><code>- 用户名密码验证
- 查询权限信息，分配对应权限
- 可以使用`show processlist`语句查看现在的连接
- 如果太长时间没有动静就会自动断开，通过`wait_timeout`控制，默认8小时
</code></pre><p>  连接可以分为两类：</p>
<pre><code>- 长连接： 推荐使用，但要周期性断开长连接
- 短连接
</code></pre></li>
<li><p>查询缓存</p>
<p>当执行查询语句的时候，会先去查询缓存中查看结果，之前执行过的sql语句及其结果可能以<code>key-value</code>的形式存储在缓存中，如果能找到则直接返回，如果找不到，就继续执行后续的阶段</p>
<p>不推荐使用查询缓存：</p>
<ol>
<li>查询缓存的失效比较频繁，只要表更新，缓存就会清空</li>
<li>缓存对应新更新的数据命中率比较低</li>
</ol>
</li>
<li><p>分析器</p>
<ul>
<li><p>词法分析：MySQL需要把输入的字符串进行识别每个分代表什么意思。把<code>字符串T</code>识别成<code>表名T</code>；把<code>字符串ID</code>识别成<code>列ID</code></p>
</li>
<li><p>语法分析： 根据语法规则判断这个SQL语句是否满足MySQL的语法，如果不符合就会报错<code>You have an error in your SQL synta</code></p>
</li>
</ul>
</li>
<li><p>优化器</p>
<p>  在具体执行SQL语句之前，要先经过优化器的处理： 当表中有多个索引的时候，决定用哪个索引；当SQL语句需要做多表关联的时候，决定表的连接顺序等等</p>
<p>  不同的执行方式对SQL语句的执行效率影响很大</p>
<ul>
<li><p>RBO： 基于规则的优化</p>
</li>
<li><p>CBO： 基于成本的优化</p>
</li>
</ul>
</li>
<li><p>执行器 </p>
<p>执行语句，返回结果</p>
</li>
<li><p>存储引擎</p>
<p>  存储数据</p>
</li>
</ul>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="Redo日志-——-InnoDB存储引擎的日志文件"><a href="#Redo日志-——-InnoDB存储引擎的日志文件" class="headerlink" title="Redo日志 —— InnoDB存储引擎的日志文件"></a>Redo日志 —— InnoDB存储引擎的日志文件</h3><p>当发生数据修改的时候InnoDB引擎会先将记录写到redo log中，并更新内存，此时更新就算是完成了，同时InnoDB引擎会在何时的时机将记录操作到磁盘中</p>
<p>Redolog是固定大小的，是循环写的过程</p>
<p>有了Redolog后，InnoDB就可以保证及时数据库发生异常重启，之前的记录也不会丢失，叫做<code>crash-safe</code></p>
<h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><p>Undo log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo log来实现多版本并发控制（简称<code>MVCC</code>）</p>
<p>在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为<code>Undo log</code>）。然后进行数据修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo log中的备份将数据恢复到事务开始之前的状态</p>
<p><strong>Undo log是逻辑日志</strong>，可以理解为：</p>
<ul>
<li>当delete一条记录时，undo log中会记录一条多赢的insert记录</li>
<li>当insert一条记录时，Undolog中会记录一条对应的delete记录</li>
<li>当update一条数据时，它记录一条对应相反的update记录</li>
</ul>
<p><strong>Redo log 和 Undo log 都是InnoDB独有的日志，MyISAM中没有。Redo log叫前滚日志，保证数据库回到发生异常(比如突然断电)前的持久化状态；Undo log叫回滚日志，是记录数据更新后的持久化状态。</strong></p>
<h3 id="Binlog-——-服务端的日志文件"><a href="#Binlog-——-服务端的日志文件" class="headerlink" title="Binlog —— 服务端的日志文件"></a>Binlog —— 服务端的日志文件</h3><p>Binglog是服务端(server层)的日志，主要做mysql功能层面的事情</p>
<p>与Redo日志的区别：</p>
<ul>
<li>Redo日志是InnoDB独有的，Binlog是所有引擎都可以使用的</li>
<li>Redo是物理日志，记录的是在某个数据页上做了什么修改；Binlog是逻辑日志，记录的是这个语句的原始逻辑</li>
<li>Redo是循环写的，空间会用完；Binlog是可以追加写的，不会覆盖之前的日志信息</li>
</ul>
<p><strong>MySQL默认不开启Binlog</strong></p>
<p>Binlog会记录所有的逻辑，并且采用追加写的方式，一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置。</p>
<p>恢复数据的过程： </p>
<ol>
<li>找到最近一次的全量备份数据</li>
<li>从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时刻</li>
</ol>
<h2 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h2><p>使用<code>explain</code> + SQL语句来模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的</p>
<h3 id="执行计划中包含的信息（属性）"><a href="#执行计划中包含的信息（属性）" class="headerlink" title="执行计划中包含的信息（属性）"></a>执行计划中包含的信息（属性）</h3><ol>
<li><p>id</p>
<p>select查询的序列号包含一组数字，表示查询中执行select子句或者操作表的顺序</p>
<p>id号分为三种情况：</p>
<ul>
<li><p>如果id相同，那么执行顺序从上到下</p>
</li>
<li><p>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
</li>
<li><p>id相同和不同的同时存在，相同的可以认为是一组，从上往下顺序执行。在所有组中，id值越大优先级越高，越先执行</p>
</li>
</ul>
</li>
<li><p>select_type</p>
<p><code>SIMPLE</code>: 简单查询</p>
<p><code>PRIMARY</code>: 最外层查询</p>
<p><code>UNION</code>: 若第二个语句在union之后则标记为union</p>
<p><code>DEPENDENT UNION</code>: 跟union关联，外层查询依赖内层查询结果</p>
<p><code>UNION RESULT</code>: 从union表中获取结果select</p>
<p><code>SUBQUERY</code>: 子查询</p>
<p><code>DEPENDENT SUBQUERY</code>: 子查询是结果集合是D<code>EPENDENT SUBQUERY</code>,单个值是<code>SUBQUERY</code></p>
<p><code>DERIVED</code>: from子句中出现的子查询，也叫做衍生类</p>
<p><code>UNCACHEABLE SUBQUERY</code>: 表示使用子表查询结果不能被缓存</p>
<p><code>UNCACHEABLE UNION</code>: 表示union的查询结果不能被缓存</p>
</li>
<li><p>table</p>
<p>对应正在访问哪一个表、表名或者别名，可能是临时表挥着union合并结果集</p>
<ul>
<li>如果是具体表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li>
<li>表名是drivedN的形式，表示使用了id为N的查询产生的衍生表，当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li>
</ul>
</li>
<li><p>partitions</p>
<p>分区</p>
</li>
<li><p>type</p>
<p>访问类型，表示当前sql语句执行时是以何种方式访问我们的数据，访问类型有很多，效率从高到低分别是：</p>
<p><code>sysytem &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_of_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p>
<p>一般情况下，得保证查询至少达到<code>range</code>级别，最好能达到<code>ref</code></p>
<ul>
<li><p>ALL: 全表扫描，一般情况下，出现这种sql语句而且数据量比较大的话，那么久需要进行优化</p>
</li>
<li><p>index： 全索引扫描，比All效率好。主要两种情况，一种是当前的查询是覆盖索引，即我们需要的数据在索引中就可以索取；第二种者是使用了索引进行排序，这样就避免数据的重排序</p>
</li>
<li><p>range： 表示利用索引联合查询的时候限制了范围，在指定范围内进行查询</p>
</li>
<li><p>index_subquery: 利用索引关联子查询，不需要再扫描全表</p>
</li>
<li><p>unique_subquery</p>
</li>
<li>index_merge</li>
<li>ref_of_null</li>
<li>fulltext</li>
<li><p>ref<br>使用了非唯一性索引进行查找</p>
</li>
<li><p>eq_ref</p>
</li>
<li><p>const<br>这个表至多有一个匹配行</p>
</li>
<li><p>sysytem</p>
<p>表里面只有一行记录（等于系统表）</p>
</li>
</ul>
</li>
<li><p>possible_keys</p>
<p>显示可能会用到的索引</p>
</li>
<li><p>key</p>
<p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p>
</li>
<li><p>key_len</p>
<p>索引中使用的字节数</p>
</li>
<li><p>ref</p>
<p> 显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
</li>
<li><p>rows</p>
<p>根据表的统计信息及索引使用情况，大致估算出找出所需记录读取的行数，此参数很重要，直接反映的sql找了多少数据，在完成目的的情况下，越少越好</p>
</li>
<li><p>extra</p>
<p>包含额外的信息</p>
</li>
</ol>
<h2 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong></p>
<p>不同的存储引擎支持不同的锁机制。</p>
<ul>
<li><code>MyISAM</code>和<code>MERMORY</code>存储引擎采用的是表级锁(<code>table-level locking</code>)</li>
<li><code>InnoDB</code>存储引擎支持行级锁(<code>row-level locking</code>)，也支持表级锁，但默认情况下采用行级锁</li>
</ul>
<p><strong>表级锁</strong>： 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发度最低</p>
<p><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</p>
<p>仅从锁的角度来说，表级锁更适合以查询为主，只有少量按索引条件更新数据的应用，如web应用；行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理(<code>OLTP</code>)系统</p>
<p><code>OLTP</code>: <code>ONLINE TRANSIATION PROCESS</code> 联机事务处理</p>
<p><code>OLAP</code>: <code>ONLINE ANALYSIS PROCESS</code> 联机分析系统 </p>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>MySQL的表级锁有两种模式： <strong>表共享读锁(Table Read Lock)</strong>、<strong>表独占写锁(Table Write Lock)</strong></p>
<p>对MyISAM表的读操作，不会阻塞其他用户对同一张表的读请求，但会阻塞对同一表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间、以及写操作之间是串行的</p>
<h4 id="MyISAM写阻塞读"><a href="#MyISAM写阻塞读" class="headerlink" title="MyISAM写阻塞读"></a>MyISAM写阻塞读</h4><p>当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p>
<p><code>lock table xxx write;</code>（锁表语句，给表xx加写锁）</p>
<p>…执行一些操作…</p>
<p><code>unlock tables;</code>(释放锁)</p>
<h4 id="MyISAM读阻塞写"><a href="#MyISAM读阻塞写" class="headerlink" title="MyISAM读阻塞写"></a>MyISAM读阻塞写</h4><p>一个session使用<code>lock table</code>给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时另一个session可以查询表中的记录，但更新就会出现锁等待。</p>
<p><code>lock table xxx read;</code> （锁表语句，给表加读锁）</p>
<p><code>unlock tables;</code>（释放锁）</p>
<p><strong>注意：</strong> MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显示加锁。</p>
<h3 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h3><ol>
<li>事务及其ACID属性</li>
</ol>
<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有四属性，通常称为事务的ACID属性。</p>
<p>原子性(<code>Actomicity</code>): 事务是一个原子操作单位，其对数据的修改，要么全都执行，要么全都不执行</p>
<p>一致性(<code>Consistent</code>): 在事务开始和完成时，数据都必须保持一致状态</p>
<p>隔离性(<code>Isolation</code>): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行</p>
<p>持久性(<code>Durable</code>): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p>
<ol start="2">
<li><p>并发事务带来的问题</p>
<p>相对于串行处理来说，并发事务处理能力大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时会带来一下问题：</p>
<ul>
<li><strong>脏读</strong>： 一个事务正在对一条记录做修改，在这个事务提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读</li>
<li><strong>不可重复读</strong>： 一个事务正在读取某些已经发生了改变或某些记录已经被删除了!这种现象叫做“不可重复读”</li>
<li><strong>幻读</strong>： 一个事务按相同的查询条件重新读取以前检所过的数据，却发现其他事务插入了满足其条件的新数据，这种现象就称为”幻读“</li>
</ul>
</li>
</ol>
<p>以上出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证</p>
<ol start="3">
<li><p>InnoDB的行锁模式及加锁情况</p>
<p><strong>共享锁(s)</strong>: 又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能在对A加S锁，而不能加X锁，知道T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何改动</p>
<p><strong>排它锁(x)</strong>: 又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集 共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁</p>
<p>MySQL InnoDB引擎默认的修改数据语句：<code>update</code>,<code>delete</code>,<code>insert</code>都会自动给涉及到的数据加上排他锁，select语句默认不会加任何类型锁。如果加排他锁可以使用<code>select ... for upadte;</code>语句，加共享锁可以使用<code>select ... lock in share mode;</code>语句。所以加排他锁的数据行在其他事务中是不能修改数据的，也不能通过<code>for update</code>和<code>lock in share mode</code>锁的方式查询数据，但可以直接通过<code>select ... from ...</code>查询数据，因为普通查询没有任何锁机制</p>
</li>
</ol>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>给索引上的索引加说来实现行锁。这一点上MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着： <strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于MyISAM的表锁：</p>
<ol>
<li>共享读锁(s)之间是兼容的，但共享读锁(s)与排他写锁(X)之间，以及排他写锁(X)之间是互斥的，也就是说读和写是串行的。</li>
<li>在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和超如的锁争用问题</li>
<li>MyISAM默认的锁调度机制是写优先，但这不一定适合所有应用，用户可以通过设置<code>LOW_PRIORITY_UPDATES</code>参数，或在INSERT、UPDATE、DELETE语句中指定<code>LOW_PRIORITY</code>选项来调节读写锁的争用</li>
<li>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突</li>
</ol>
<p>对于InnoDB表锁：</p>
<ol>
<li>InnoDB行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁</li>
<li>在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同</li>
</ol>
<p>用户可以通过设计和SQL调整等措施减少锁冲突和死锁：</p>
<ul>
<li>尽量使用较低的隔离级别： 精心设计索引并尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会</li>
<li>选择合理的事务大小，小失误发生锁冲突的几率也更小</li>
<li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时在请求排他锁，这样容易产生死锁</li>
<li>不同的程序访问同一组表时，应尽量约定相同的顺序访问各表，对一个表而言尽可能以固定的顺序存取表中的行，这样可以大大减少死锁的机会</li>
<li>尽量使用相等条件范文数据，这样可以避免间隙锁对并发插入的影响；不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li>
</ul>
]]></content>
      <categories>
        <category>Database, MySQL</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Database</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础之CSS</title>
    <url>/2019/10/13/frontend/css/</url>
    <content><![CDATA[<h1 id="CSS一些基本概念"><a href="#CSS一些基本概念" class="headerlink" title="CSS一些基本概念"></a>CSS一些基本概念</h1><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CSS规则 = 选择器 + 声明块</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器： 选中元素</p>
<ol>
<li>ID选择器： 选中的是对应id值的元素</li>
<li>元素选择器</li>
<li>类选择器</li>
</ol>
<h3 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h3><p>出现在<code>{}</code>中，声明块包含很多声明（属性），每一个声明（属性）表达了某一方面的样式</p>
<h2 id="CSS代码书写位置"><a href="#CSS代码书写位置" class="headerlink" title="CSS代码书写位置"></a>CSS代码书写位置</h2><ol>
<li>内部样式表</li>
</ol>
<p>书写在<code>&lt;style&gt;</code>元素中，一般放在<code>&lt;head&gt;</code>里面</p>
<ol start="2">
<li>内联样式表（元素样式表）</li>
</ol>
<p>直接书写在元素的style属性中</p>
<ol start="3">
<li>外部样式表[推荐]</li>
</ol>
<p>将样式书写到独立的css文件中</p>
<p>1) 外部样式表可以解决多页面样式重复的问题<br>2) 有利于浏览器缓存，从而提高页面响应速度<br>3) 有利于代码分离(HTML和CSS)，更容易阅读和维护</p>
<h1 id="常见样式声明"><a href="#常见样式声明" class="headerlink" title="常见样式声明"></a>常见样式声明</h1><ol>
<li><code>color</code></li>
</ol>
<p>元素内部的文字颜色</p>
<p><strong>预设值</strong>： 定义好的单词</p>
<p><strong>三原色(色值)</strong>： 光学三原色（红、绿、蓝），每个颜色可以使用0-255之间的数字来表达色值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rgb表示法：</span><br><span class="line">rgb(0,255,0)</span><br><span class="line">hex(16进制)表示法：</span><br><span class="line">#红绿蓝</span><br></pre></td></tr></table></figure>
<p>常用的颜色色号：</p>
<p>淘宝红： #ff4400,#f40<br>黑色： #000000，#000<br>白色： #ffffff, #fff<br>红： #f00<br>绿： #0f0<br>蓝： #00f<br>紫： #f0f<br>青： #0ff<br>黄： #ff0<br>灰色： #ccc</p>
<ol start="2">
<li><code>background-color</code></li>
</ol>
<p>元素背景颜色</p>
<ol start="3">
<li><code>font-size</code></li>
</ol>
<p>元素内部文字的尺寸大小</p>
<p>1) 像素尺寸 px<br>2) 相对单位 em 相对父元素的字体大小 </p>
<p>每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小；若果没有父元素(即html元素)，则使用基准字号，即浏览器中设置的字体大小</p>
<blockquote>
<p>user agent:  UA, 用户代理（浏览器）</p>
</blockquote>
<ol start="4">
<li><code>font-weight</code></li>
</ol>
<p>文字粗细程度，可以取值数字，可以取值为预设值</p>
<p><strong>预设值</strong></p>
<p>normal–&gt;400 (不加粗)<br>bold–&gt;700 (加粗)</p>
<blockquote>
<p>strong元素默认显示加粗字体</p>
</blockquote>
<ol start="5">
<li><code>font-family</code></li>
</ol>
<p>文字类型</p>
<p>必须用户计算机中存在的字体才会有效</p>
<p>使用多个字体，以匹配不同环境</p>
<p>最后一般会加上<code>sans-serif</code>,非衬线字体。 当用户计算机未安装指定的所有字体时，使用计算机自带字体</p>
<ol start="6">
<li><code>font-style</code></li>
</ol>
<p>字体样式，通常用它设置斜体</p>
<blockquote>
<p>i、em 元素默认样式是斜体; 实际使用中，通常用它表示一个图标</p>
</blockquote>
<ol start="7">
<li><code>text-decoration</code></li>
</ol>
<p>文本修饰，给文本加斜线(删除线、下划线等)</p>
<blockquote>
<p>a元素默认带有下划线；  del元素 表示错误内容 默认带有删除线； s元素 表示废弃/过期内容(比如商品原价等) 默认带有删除线</p>
</blockquote>
<ol start="8">
<li><code>text-indent</code></li>
</ol>
<p>表示首行文本缩进，可以写像素<code>px</code>，也可以写<code>em</code></p>
<ol start="9">
<li><code>line-height</code></li>
</ol>
<p>行高，每行文本的高度，该值越大，每行文本的距离越大</p>
<p>设置行高为容器的高度，可以让单行文本垂直居中</p>
<p>行高可以设置为纯数字，表示相对于当前元素的字体大小 [多行文字时推荐此写法]</p>
<ol start="10">
<li>width</li>
</ol>
<p>宽度</p>
<ol start="11">
<li><code>height</code></li>
</ol>
<p>高度</p>
<ol start="12">
<li><code>letter-spacing</code></li>
</ol>
<p>文字间隙</p>
<ol start="13">
<li><code>text-align</code></li>
</ol>
<p>文字水平对齐样式，默认左对齐</p>
<h1 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h1><p>选择器： 帮助你精准的选中想要的元素</p>
<h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><ol>
<li><p>ID选择器</p>
</li>
<li><p>元素选择器</p>
</li>
<li><p>类选择器</p>
</li>
<li><p>通配符选择器</p>
</li>
</ol>
<p><code>*</code> : 表示选择所有</p>
<ol start="5">
<li>属性选择器</li>
</ol>
<p>根据属性名和属性值选择</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中所有具有href属性的元素 */</span></span><br><span class="line"><span class="selector-attr">[href]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选中href属性=https://www.baidu.com的元素 */</span></span><br><span class="line"><span class="selector-attr">[href="https://www.baidu.com"]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多写法参见官方文档： <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Attribute_selectors" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Attribute_selectors</a></p>
<ol start="6">
<li>伪类选择器</li>
</ol>
<p>选中某些元素的某种状态,书写格式： <code>:</code></p>
<p><code>link</code>: 超链接未访问时的状态</p>
<p><code>visited</code>: 超链接点击后的状态</p>
<p><code>hover</code> : 鼠标悬停状态</p>
<p><code>active</code>: 激活状态，鼠标按下时的状态</p>
<p>书写顺序： 爱恨法则 L V H A </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中鼠标悬停时的a元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标按下时的a元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>伪元素选择器</li>
</ol>
<p>书写格式： <code>::</code></p>
<p>before</p>
<p>after</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在span元素前面加"《" 后面加 "》" content为before和after 伪元素选择器特有的属性 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" 《"</span>; </span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"》 "</span>; </span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择器的组合"><a href="#选择器的组合" class="headerlink" title="选择器的组合"></a>选择器的组合</h2><ol>
<li>并且</li>
</ol>
<p>将两个选择器连着写，中间不加空格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 选中class=red的p元素 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>后代元素 —— 空格</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 选中class=red后代的li元素 */</span></span><br><span class="line"><span class="selector-class">.red</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>子元素 —— &gt;</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 选中class=abc的子元素中class=bcd的元素 */</span></span><br><span class="line"><span class="selector-class">.abc</span>&gt;<span class="selector-class">.bcd</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>相邻兄弟元素 —— +</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 选中class=special的元素下一个兄弟li元素 */</span></span><br><span class="line"><span class="selector-class">.special</span>+<span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>后面出现的所有兄弟元素 —— ~</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 选中class=special的元素后面所有的兄弟li元素 */</span></span><br><span class="line"><span class="selector-class">.special</span>~<span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CSS选择器中不提供选择元素之前的选择器，跟CSS渲染有关</strong></p>
<h2 id="选择器的并列"><a href="#选择器的并列" class="headerlink" title="选择器的并列"></a>选择器的并列</h2><p>多个选择器用逗号分隔</p>
<p>语法糖(Syntactic sugar): 指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.special</span>~<span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.special</span>~<span class="selector-tag">li</span>, <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><p>声明冲突： 同一个样式，多次应用到同一个元素</p>
<p>层叠： 解决声明冲突的过程，浏览器自动处理（权重计算）</p>
<p>冲突最终值只能胜出一个</p>
<h2 id="比较重要性"><a href="#比较重要性" class="headerlink" title="比较重要性"></a>比较重要性</h2><p>重要性由高到低： </p>
<blockquote>
<p>作者样式表： 开发者书写的样式</p>
</blockquote>
<p>1) 作者样式表中的<code>!important</code>样式<br>2) 作者样式表的普通样式<br>3) 浏览器默认样式表中的样式</p>
<h2 id="比较特殊性"><a href="#比较特殊性" class="headerlink" title="比较特殊性"></a>比较特殊性</h2><p>总体规则： 选择器选择的范围越窄，越特殊</p>
<p>具体规则： 通过选择器计算出一个四位数(XXXX)，值越大表示越特殊</p>
<ol>
<li>千位数： 如果是内联样式，记1，否则0</li>
<li>百位数： 等于选择器中所有id选择器的数量</li>
<li>十位数： 等于选择器中所有类选择器、属性选择器、伪类选择器的数量</li>
<li>个位数： 等于选择器中所有元素选择器、伪元素选择器的数量</li>
</ol>
<p><strong>此四位数不是严格意义上的四位数，不会逢十进一，而是逢256进一</strong></p>
<h2 id="比较源次序"><a href="#比较源次序" class="headerlink" title="比较源次序"></a>比较源次序</h2><p>代码书写靠后的胜出</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><p>重置样式表</p>
<p> 书写一些作者样式，覆盖浏览器的默认样式，解决不同浏览器默认样式不同使界面显示不同的问题。</p>
<p> 常见的重置样式表： normalize.css、 reset.css、 meyer.css</p>
</li>
<li><p>爱恨法则</p>
<p> link &gt; visited &gt; hover &gt; active</p>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>子元素会继承父元素的某些CSS属性</p>
<p>通常跟字体相关的属性都能被继承</p>
<h1 id="属性值的计算过程"><a href="#属性值的计算过程" class="headerlink" title="属性值的计算过程"></a>属性值的计算过程</h1><p>浏览器是一个元素一个元素依次渲染页面的，顺序按照页面文档的树形目录结构</p>
<p>渲染每个元素的前提条件： 该元素的所有CSS属性必须有值</p>
<p>一个元素从所有属性都没有值，到所有的属性都有值，这个计算过程叫做属性值计算过程。</p>
<h2 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h2><ol>
<li><p>确定声明值</p>
<p> 声明值： 开发者写的样式或者浏览器默认的样式</p>
<p> 参考样式表中没有冲突的声明直接作为CSS属性值</p>
</li>
<li><p>层叠冲突</p>
<p> 对样式表中有冲突的声明使用层叠规则，确定CSS属性值</p>
</li>
<li><p>使用继承</p>
<p> 对仍然没有值的属性，若可以继承则继承父元素的值</p>
</li>
<li><p>使用默认值</p>
<p> 对仍然没有值的属性使用默认值，每个CSS属性都有自己的默认值</p>
</li>
</ol>
<p>特殊的两个CSS取值：</p>
<ul>
<li><code>inherit</code>: 手动（强制）继承，将父元素的值取出应用到该元素</li>
<li><code>initial</code>: 初始值，将该属性设置为默认值 </li>
</ul>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>box: 盒子，每个元素在页面中都会生成一个矩形区域(盒子)</p>
<p>盒子类型： </p>
<ol>
<li>行盒， <code>display=inline</code>的元素</li>
<li>块盒， <code>display=block</code>的元素</li>
</ol>
<p>行盒在页面中不换行，块盒独占一行</p>
<p>浏览器默认样式设置的块盒： 容器元素(div header footer…)、h1~h6、p</p>
<p>常见的行盒： span、 a、 img、video、audio</p>
<h2 id="盒子的组成部分"><a href="#盒子的组成部分" class="headerlink" title="盒子的组成部分"></a>盒子的组成部分</h2><p>无论是行盒还是块盒都由下面几个部分组成，从内到外分别是：</p>
<ol>
<li><p>内容 content</p>
<p> <code>width</code>、 <code>height</code> 设置的是盒子内容的宽度和高度</p>
<p> 内容部分通常叫做整个盒子的<strong>内容盒 content-box</strong></p>
</li>
<li><p>填充 padding</p>
<p> 盒子边框到盒子内容的距离</p>
<p> <code>padding-left</code> <code>padding-right</code> <code>padding-top</code> <code>padding-bottom</code></p>
<p> <code>padding</code> 简写属性</p>
<p> <code>padding: 上 右 下 左</code></p>
<p> 填充区+内容区叫做 <strong>填充盒 padding-box</strong> </p>
</li>
<li><p>边框 border</p>
<p> 边框 = 边框样式 + 边框宽度 + 边框颜色</p>
<p> 边框样式：<code>border-style</code> (可以取<code>solid</code> <code>dotted</code> <code>dashed</code>等样式值) 简写属性<br> 边框宽度: <code>border-width</code>  简写属性<br> 边框颜色: <code>border-color</code> 默认为字体颜色</p>
<p> border: 边框宽度 边框样式 边框颜色</p>
<p> 边框 + 填充区 + 内容区 = <strong>边框盒 border-box</strong></p>
</li>
<li><p>外边距 margin</p>
<p> 边框到其他盒子的距离</p>
<p> <code>margin-top</code> <code>margin-left</code> <code>margin-right</code> <code>margin-bottom</code></p>
<p> 可简写成： <code>margin: 上 由 下 左</code></p>
</li>
</ol>
<h1 id="盒模型的应用"><a href="#盒模型的应用" class="headerlink" title="盒模型的应用"></a>盒模型的应用</h1><h2 id="改变框高范围"><a href="#改变框高范围" class="headerlink" title="改变框高范围"></a>改变框高范围</h2><p>默认情况下，width和height设置的是内容盒的宽高</p>
<blockquote>
<p>页面重构师： 将psd文件（设计稿）制作为静态页面</p>
</blockquote>
<p>衡量页面设计稿尺寸的时候，往往使用的是边框盒，但设置width和height则设置的是内容盒</p>
<p>解决办法：</p>
<ol>
<li>精确计算</li>
<li>只用CSS3中的<code>box-sizing</code>指定宽高的影响范围</li>
</ol>
<h2 id="改变背景覆盖范围"><a href="#改变背景覆盖范围" class="headerlink" title="改变背景覆盖范围"></a>改变背景覆盖范围</h2><p>默认情况下背景覆盖边框盒</p>
<p>可以通过<code>background-clip</code>修改边框覆盖范围</p>
<h2 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h2><p><code>overflow : visible</code> 可见(默认值)</p>
<p><code>overflow : hidden</code> 溢出部分隐藏</p>
<p><code>overflow : scroll</code> 生成滚动条</p>
<p><code>overflow-y : scroll</code> 竖向滚动条</p>
<p><code>overflow-x : scroll</code> 横向滚动条</p>
<p><code>overflow : auto</code> 自动控制出现滚动条</p>
<h2 id="断词规则"><a href="#断词规则" class="headerlink" title="断词规则"></a>断词规则</h2><p><code>word-break</code>, 影响文字在什么位置被截断换行，有以下值：</p>
<p>normal: 普通。 CJK(中日韩)字符在文字位置截断，非CJK字符在单词位置截断</p>
<p>break-all： 截断所有。 所有字符在文字处截断，比如英文会在单词中截断</p>
<p>keep-all: 保持所有。 所有字符在单词间截断，中文字符若无空格则会挤在一行</p>
<h2 id="空白处理"><a href="#空白处理" class="headerlink" title="空白处理"></a>空白处理</h2><p><code>white-space: nowrap</code>： 不换行</p>
<p>常用处理方式： </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap; <span class="comment">/* 不换行 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 溢出隐藏 */</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/* 文字部分溢出用圆点代替 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="行盒的盒模型"><a href="#行盒的盒模型" class="headerlink" title="行盒的盒模型"></a>行盒的盒模型</h1><p>常见的行盒： 包含具体内容的元素</p>
<p><code>span</code> <code>strong</code> <code>em</code> <code>i</code> <code>img</code> <code>video</code> <code>audio</code></p>
<h2 id="显著特点"><a href="#显著特点" class="headerlink" title="显著特点"></a>显著特点</h2><ol>
<li>盒子沿着内容延伸</li>
<li>行盒不能设置宽高，因为行盒的宽高是根据内容来的，只能通过字体大小、行高、字体类型等间接调整</li>
<li><p>内边距(填充区)</p>
<p> 水平方向有效，垂直方向只会影响背景，不会实际占据空间 (内容盒不会垂直方向移动)</p>
</li>
<li><p>边框</p>
<p> 水平方向有效，垂直方向可以看见效果，但不会实际占据空间(内容盒不会垂直方向移动)</p>
</li>
<li><p>外边距</p>
<p> 水平方向有效，垂直方向不会实际占据空间(内容盒不会垂直方向移动)</p>
</li>
</ol>
<h2 id="行块盒"><a href="#行块盒" class="headerlink" title="行块盒"></a>行块盒</h2><p><code>display: inline-block</code> 的盒子</p>
<ol>
<li>不独占一行</li>
<li>盒模型中所有尺寸都有效</li>
</ol>
<h2 id="空白折叠"><a href="#空白折叠" class="headerlink" title="空白折叠"></a>空白折叠</h2><p>空白折叠发生在行盒(行块盒)内部或行盒之间(行块盒)</p>
<h2 id="可替换元素和非可替换元素"><a href="#可替换元素和非可替换元素" class="headerlink" title="可替换元素和非可替换元素"></a>可替换元素和非可替换元素</h2><p>大部分元素页面上显示的结果取决于元素内容，称为<strong>非可替换元素</strong></p>
<p>少部分元素页面上显示的结果取决于元素属性，称为<strong>可替换元素</strong></p>
<p>可替换元素： img video audio</p>
<p>绝大部分可替换元素为行盒</p>
<p>可替换元素类似于行块盒，盒模型中所有尺寸都有效。</p>
<p>图片<code>img</code>特殊性属性：<code>object-fit</code></p>
<pre><code>- fill : 默认值，表示填充，不能保证图片的宽高比

- cover: 保证填充满区域并保持宽高比，但会丢失部分图片信息

- contain: 保持图片宽高比并显示图片所有信息
</code></pre><h1 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h1><p>盒模型： 规定单个盒子的规则</p>
<p>视觉格式化模型(布局规则)： 页面中的多个盒子排列规则</p>
<p>视觉格式化模型大体上将页面中盒子的排列分为三种方式</p>
<ol>
<li>常规流</li>
<li>浮动</li>
<li>定位</li>
</ol>
<h2 id="常规流布局"><a href="#常规流布局" class="headerlink" title="常规流布局"></a>常规流布局</h2><p>常规流、文档流、普通文档流、常规文档流</p>
<p>所有元素默认情况下都属于常规流布局</p>
<p>总体规则： 块盒独占一行，行盒水平依次排序</p>
<p>包含块(containing block): 每个盒子都有它的包含块，包含块决定了盒子的排列区域</p>
<p>绝大部分情况下： 盒子的包含块为其父元素的内容盒</p>
<p><strong>块盒</strong></p>
<ol>
<li><p>每个块盒的总宽度必须 = 包含块的宽度(父元素内容盒的宽度)</p>
<p> <strong>以下margin为水平方向的margin</strong></p>
<p> 宽度的默认值是<code>auto</code>,表示将剩余空间吸收掉</p>
<p> <code>margin</code>的默认值是<code>0</code>,设置为<code>auto</code>时会根据实际情况计算</p>
<p> 宽度吸收能力强于<code>margin</code>，当两者为<code>auto</code>时，宽度默认撑满</p>
<p> 若宽度、边框、内边距、外边距计算后仍然有剩余空间，则剩余空间会被<code>margin-right</code> 全部吸收</p>
<p> 在常规流中，若要使块盒在包含块中居中，可以先固定宽度，然后左右<code>margin</code>设置为<code>0</code></p>
</li>
<li><p>每个块盒垂直方向上的<code>auto</code>值</p>
<p> <code>height: auto</code>: 适应内容的高度</p>
<p> <code>margin:auto</code>: 表示为0</p>
</li>
<li><p>百分比取值</p>
<p> <code>padding</code>、<code>宽高</code>、<code>margin</code> 可以取值为百分比</p>
<p> 以上所有的百分比(垂直方向和竖直方向)都是相对于包含块的宽度，与包含块的高度无关</p>
<p> 高度的百分比：</p>
<p> 1). 包含块的高度未设置而是取决于子元素的高度时，设置百分比无效</p>
<p> 2). 包含块的高度设置为定值时，百分比相对于父元素的高度</p>
</li>
<li><p>上下外边距的合并</p>
<p> 两个常规流块盒，上下外边距相邻会进行合并，取两个外边距最大值</p>
<p> 父子元素之间外边距相邻时也会出现合并的现象，若不想合并，可以设置父元素的<code>border</code>或者<code>padding</code></p>
</li>
</ol>
<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>视觉格式化模型，大体上将页面中盒子的排列分三种方式：</p>
<ol>
<li>常规流</li>
<li>浮动</li>
<li>定位</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>文字环绕</li>
<li>横向排列</li>
</ol>
<h2 id="浮动的基本特点"><a href="#浮动的基本特点" class="headerlink" title="浮动的基本特点"></a>浮动的基本特点</h2><p>修改CSS<code>float</code>属性值为:</p>
<ul>
<li><code>left</code>: 左浮动，元素靠上靠左</li>
<li><code>right</code>: 右浮动， 元素靠上靠右</li>
<li>默认为<code>none</code></li>
</ul>
<ol>
<li>当一个元素设置浮动后，元素必定为块盒(更改display属性为block)</li>
<li>浮动元素的包含块和常规流一样，为父元素的内容盒</li>
</ol>
<h2 id="盒子尺寸"><a href="#盒子尺寸" class="headerlink" title="盒子尺寸"></a>盒子尺寸</h2><ol>
<li>宽度为<code>auto</code>时，表示适应内容宽度，即宽度由内容撑开</li>
<li>高度为<code>auto</code>时，与常规流一致，适应内容高度</li>
<li><code>margin</code>为<code>auto</code>时，表示为0</li>
<li>边框、内边距、百分比的设置与常规流一样</li>
</ol>
<h2 id="盒子排列"><a href="#盒子排列" class="headerlink" title="盒子排列"></a>盒子排列</h2><ol>
<li>左浮动的盒子靠上靠左</li>
<li>右浮动的盒子靠上靠右</li>
<li>浮动盒子在包含块中排列，会避开常规流盒子</li>
<li>常规流块盒在排列时会无视浮动盒子</li>
<li>行盒排列时会避开浮动盒子</li>
<li>浮动盒子不会发生外边距合并</li>
</ol>
<h2 id="高度坍塌"><a href="#高度坍塌" class="headerlink" title="高度坍塌"></a>高度坍塌</h2><p>高度坍塌根源： 常规流盒子的自动高度在计算时，不会考虑浮动盒子</p>
<p>解决方式： 清除浮动，涉及CSS属性<code>clear</code>,取值为：</p>
<ul>
<li>默认值: none</li>
<li><code>left</code>: 清除左浮动，该元素必须出现在前面所有左浮动盒子的下方</li>
<li><code>right</code>: 清除右浮动，该元素必须出现在前面所有右浮动盒子的下方</li>
<li><code>both</code>: 清除所有浮动，该元素必须出现在前面所有浮动盒子的下方</li>
</ul>
<p>方案1：</p>
<p>在<strong>浮动元素后面</strong>添加空元素，为其设置样式<code>clear: both</code></p>
<p>方案2： </p>
<pre><code>为发生高度坍塌的容器添加伪元素： 

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><hr>
<p>参考视频</p>
<p> <a href="https://www.bilibili.com/video/av57100756?from=search&amp;seid=2646463889570770154" target="_blank" rel="noopener">https://www.bilibili.com/video/av57100756?from=search&amp;seid=2646463889570770154</a> (2019年 HTML+CSS 零基础权威入学宝典【渡一教育】p16~p58)</p>
]]></content>
      <categories>
        <category>web,CSS</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础之canvas</title>
    <url>/2020/03/21/frontend/canvas/</url>
    <content><![CDATA[<p>canvas最早由Apple引入WebKit，用于Mac OS X的dashboard，后来又在safari和Google Chrome被实现。基于Geoko 1.8的浏览器（如firefox1.5）支持此元素。</p>
<p><code>&lt;canvas&gt;</code>元素是WhatWG Web applications 1.0规范的一部分，也包含于HTML5中。<code>&lt;canvas&gt;</code>不再是语义化标签，存在兼容性问题，因此使用语义化标签兼容插件无法解决兼容问题。</p>
<h1 id="canvas体验"><a href="#canvas体验" class="headerlink" title="canvas体验"></a>canvas体验</h1><p>绘图步骤：</p>
<ol>
<li><p>准备画布</p>
<p> 使用<code>&lt;canvas&gt;</code>标签定义一个画布，默认画布为透明色(<code>rgba(0, 0, 0, 0)</code>)，大小为300*150</p>
<p> 可在<code>&lt;canvas&gt;</code>的样式中设置边框，但不设置大小，画布大小在<code>&lt;canvas&gt;</code>属性中设置</p>
<h2 id="canvas尺寸设置"><a href="#canvas尺寸设置" class="headerlink" title="canvas尺寸设置"></a>canvas尺寸设置</h2><ul>
<li><p>在样式中设置<code>canvas</code>尺寸：</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
<p>  <img src="/source/data/img/html/canvas/canvas尺寸样式.png" alt="canvas使用样式设置尺寸"></p>
</li>
<li><p>使用<code>canvas</code>属性设置画布尺寸</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
<p>  <img src="/source/data/img/html/canvas/canvas尺寸属性.png" alt="canvas使用属性设置尺寸"></p>
<p>可以看出虽然两种方法设置的画布最终大小是一致的，但画布中的内容却不一样。</p>
<p><strong>使用样式设置画布大小，相当于对画布进行了放大操作，画布中的内容也会被拉伸；使用canvas自带属性设置画布大小设置的是画布的实际大小，内容不会有影响</strong></p>
</li>
</ul>
</li>
<li><p>准备绘图工具</p>
<p> <code>&lt;canvas&gt;</code>标签中不能写内容，因此绘图工具只能在js中设置</p>
</li>
<li><p>利用工具绘图</p>
<p> 绘图步骤也需写在JS中</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取canvas元素</span></span><br><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取上下文(此处上下文为canvas的回执工具箱)</span></span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 移动画笔</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绘制直线(轨迹/绘制路径)</span></span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 描边</span></span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>canvas不支持3d效果，一般使用web gl绘制3d效果的网页</strong></p>
<h1 id="绘制平行线"><a href="#绘制平行线" class="headerlink" title="绘制平行线"></a>绘制平行线</h1><h2 id="绘制两条平行线"><a href="#绘制两条平行线" class="headerlink" title="绘制两条平行线"></a>绘制两条平行线</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第一条线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第二条线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描边</span></span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<h2 id="关于描边"><a href="#关于描边" class="headerlink" title="关于描边"></a>关于描边</h2><p>描边默认的宽度是1px,默认颜色为黑色，但实际在浏览器显示为2px,浅黑色</p>
<p>描边线的中心位置与刻度线对齐，因此描边线会占据浏览器上下各0.5px，但浏览器无法解析0.5px，只能解析1px，因此最终显示结果是宽度为2px,颜色饱和度降低</p>
<p>解决方案： 前后(Y轴)移动0.5px</p>
<h3 id="绘制三条不同颜色的平行线"><a href="#绘制三条不同颜色的平行线" class="headerlink" title="绘制三条不同颜色的平行线"></a>绘制三条不同颜色的平行线</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第一条蓝线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"><span class="comment">// 绘制第二条红线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"><span class="comment">// 绘制第三条绿线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">30</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<p>绘制不同属性的线条时，需要用<code>ctx.beginPath();</code>来开启新路径解决样式覆盖问题</p>
<h1 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<p>使用此方法绘制出的三角形会出现起始点和lineto的连接点无法闭合产生缺角的问题:</p>
<p><img src="/source/data/img/html/canvas/canvas手动闭合三角形.png" alt="canvas绘制手动闭合三角形"></p>
<p>解决方案：使用<code>ctx.closePath()</code>让canvas自动闭合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">// ctx.lineTo(200,100);</span></span><br><span class="line">ctx.closePath();<span class="comment">// 关闭路径</span></span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;    </span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<p><img src="/source/data/img/html/canvas/canvas自动闭合三角形.png" alt="canvas绘制自动闭合三角形"></p>
<h2 id="绘制填充的三角形"><a href="#绘制填充的三角形" class="headerlink" title="绘制填充的三角形"></a>绘制填充的三角形</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#FF4040'</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>
<p>绘制结果：</p>
<p><img src="/source/data/img/html/canvas/canvas填充三角形.png" alt="canvas绘制填充三角形"></p>
<p><strong>填充时不再使用<code>ctx.stroke()</code>而是使用<code>ctx.fill()</code>,同样的，填充样式属性用的是<code>fillStyle</code>而不是<code>strokeStyle</code></strong></p>
<h1 id="绘制镂空正方形"><a href="#绘制镂空正方形" class="headerlink" title="绘制镂空正方形"></a>绘制镂空正方形</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺时针绘制100*100小正方形</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆时针绘制200*200大正方形</span></span><br><span class="line">ctx.moveTo(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">250</span>,<span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">50</span>,<span class="number">250</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line">ctx.fill();<span class="comment">// 非零环绕填充规则进行填充</span></span><br></pre></td></tr></table></figure>
<p>绘制结果：</p>
<p><img src="/source/data/img/html/canvas/canvas绘制镂空正方形.png" alt="canvas绘制镂空正方形"></p>
<p><strong>非零环绕规则</strong>：从区域内往外画一条足够长的线，线与顺时针路径相交，计数器+1，与逆时针路径相交，计数器-1，计数器最终不为0则填充</p>
<p><img src="/source/data/img/html/canvas/非零环绕规则图解.png" alt="非零环绕规则图解"></p>
<h2 id="与线条相关的属性-画笔状态"><a href="#与线条相关的属性-画笔状态" class="headerlink" title="与线条相关的属性(画笔状态)"></a>与线条相关的属性(画笔状态)</h2><ul>
<li><p><code>lineWidth</code>: 线宽，默认1px</p>
</li>
<li><p><code>lineCap</code>: 线末端属性： butt、round、square</p>
</li>
<li><p><code>lineJoin</code>: 相交线的拐点： miter(默认)、round、bevel</p>
</li>
<li><p><code>strokeStyle</code>: 线的颜色</p>
</li>
<li><p><code>fillStyle</code>: 填充颜色</p>
</li>
<li><p><code>setLineDash()</code>: 设置虚线</p>
<p>  <code>setLineDash()</code>方法中需要传一个数组，用来描述虚线的排列方式,如<code>ctx.setLineDash([5,10,15,20])</code></p>
</li>
</ul>
<ul>
<li><p><code>getLineDash()</code>: 获取虚线宽度集合</p>
</li>
<li><p><code>lineDashOffset</code>: 设置虚线偏移量(负值向右偏移)</p>
</li>
</ul>
<h1 id="绘制渐变色矩形"><a href="#绘制渐变色矩形" class="headerlink" title="绘制渐变色矩形"></a>绘制渐变色矩形</h1><p>绘制思路： 绘制点组成线，为每个点上色</p>
<h1 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h1><p>绘制流程： 绘制网格 –&gt; 绘制坐标系 –&gt; 绘制点 –&gt; 连点成线</p>
<p>具体实现： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造函数</span></span><br><span class="line"><span class="keyword">var</span> LineChart = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取绘制工具</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx || <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置画布大小</span></span><br><span class="line">    <span class="keyword">this</span>.canvasWidth = <span class="keyword">this</span>.ctx.canvas.width;</span><br><span class="line">    <span class="keyword">this</span>.canvasHeight = <span class="keyword">this</span>.ctx.canvas.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置网格大小</span></span><br><span class="line">    <span class="keyword">this</span>.gridSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置坐标系的间距</span></span><br><span class="line">    <span class="keyword">this</span>.space = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置坐标原点位置</span></span><br><span class="line">    <span class="keyword">this</span>.x0 = <span class="keyword">this</span>.space;</span><br><span class="line">    <span class="keyword">this</span>.y0 = <span class="keyword">this</span>.canvasHeight - <span class="keyword">this</span>.space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置箭头大小</span></span><br><span class="line">    <span class="keyword">this</span>.arrowSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置点的大小</span></span><br><span class="line">    <span class="keyword">this</span>.dotSize = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 行为和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">LineChart.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.drawGrid();</span><br><span class="line">    <span class="keyword">this</span>.drawCoordinate();</span><br><span class="line">    <span class="keyword">this</span>.drawDots(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制网格</span></span><br><span class="line">LineChart.prototype.drawGrid = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// X轴方向线条数 = 画布高度 / 网格大小  向下取整</span></span><br><span class="line">    <span class="keyword">var</span> xLine = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.canvasHeight / <span class="keyword">this</span>.gridSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制x轴方向线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= xLine; i++) &#123;</span><br><span class="line">       <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">       <span class="keyword">this</span>.ctx.moveTo(<span class="number">0</span>, i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth, i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'#eee'</span>;</span><br><span class="line">       <span class="keyword">this</span>.ctx.stroke();            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y轴方向线条数 = 画布宽度 / 网格大小 向下取整</span></span><br><span class="line">    <span class="keyword">var</span> yLine = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.canvasWidth / <span class="keyword">this</span>.gridSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制Y轴方向线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= yLine; i++) &#123;</span><br><span class="line">       <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">       <span class="keyword">this</span>.ctx.moveTo(i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.lineTo(i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>, <span class="keyword">this</span>.canvasHeight);</span><br><span class="line">       <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'#eee'</span>;</span><br><span class="line">       <span class="keyword">this</span>.ctx.stroke();            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制坐标系</span></span><br><span class="line">LineChart.prototype.drawCoordinate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制X轴</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">    <span class="keyword">this</span>.ctx.moveTo(<span class="keyword">this</span>.x0, <span class="keyword">this</span>.y0);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space, <span class="keyword">this</span>.y0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X轴箭头</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space - <span class="keyword">this</span>.arrowSize, <span class="keyword">this</span>.y0 - <span class="keyword">this</span>.arrowSize / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space - <span class="keyword">this</span>.arrowSize, <span class="keyword">this</span>.y0 + <span class="keyword">this</span>.arrowSize / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space, <span class="keyword">this</span>.y0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill();</span><br><span class="line">    <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'black'</span>;</span><br><span class="line">    <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制Y轴</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">    <span class="keyword">this</span>.ctx.moveTo(<span class="keyword">this</span>.x0, <span class="keyword">this</span>.y0);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.space, <span class="keyword">this</span>.space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y轴箭头</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.x0 + <span class="keyword">this</span>.arrowSize / <span class="number">2</span>, <span class="keyword">this</span>.space + <span class="keyword">this</span>.arrowSize);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.x0 - <span class="keyword">this</span>.arrowSize / <span class="number">2</span>, <span class="keyword">this</span>.space + <span class="keyword">this</span>.arrowSize);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.space, <span class="keyword">this</span>.space);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill();</span><br><span class="line">    <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制点</span></span><br><span class="line">LineChart.prototype.drawDots = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 传入数据的坐标不是canvas坐标，因此需要先转换成canvas坐标，再进行绘制和连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = data[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> canvasX = _this.x0 + item.x;<span class="comment">// canvas x轴坐标 = canvas原点X轴坐标 + 数据X轴坐标</span></span><br><span class="line">        <span class="keyword">var</span> canvasY = _this.y0 - item.y;<span class="comment">// canvas y轴坐标 = canvas原点y轴坐标 - 数据Y轴坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制点</span></span><br><span class="line">        _this.ctx.beginPath();</span><br><span class="line">        _this.ctx.moveTo(canvasX - _this.dotSize / <span class="number">2</span>, canvasY - _this.dotSize / <span class="number">2</span>);<span class="comment">// 起始位置为点的左上角位置</span></span><br><span class="line">        _this.ctx.lineTo(canvasX + _this.dotSize / <span class="number">2</span>, canvasY - _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.lineTo(canvasX + _this.dotSize / <span class="number">2</span>, canvasY + _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.lineTo(canvasX - _this.dotSize / <span class="number">2</span>, canvasY + _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.closePath();</span><br><span class="line"></span><br><span class="line">        _this.ctx.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将点连成线 (第一个点起点为(x0,y0),其他坐标起点为上一个点)</span></span><br><span class="line">        _this.ctx.beginPath();</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">            _this.ctx.moveTo( _this.x0,  _this.y0);                </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            _this.ctx.moveTo( _this.x0 + data[i<span class="number">-1</span>].x, _this.y0 - data[i<span class="number">-1</span>].y);</span><br><span class="line">        &#125;</span><br><span class="line">        _this.ctx.lineTo(canvasX, canvasY);</span><br><span class="line"></span><br><span class="line">        _this.ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化</span></span><br><span class="line"><span class="keyword">var</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">100</span>,</span><br><span class="line">        y: <span class="number">120</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">150</span>,</span><br><span class="line">        y: <span class="number">300</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">400</span>,</span><br><span class="line">        y: <span class="number">360</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">430</span>,</span><br><span class="line">        y: <span class="number">200</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">470</span>,</span><br><span class="line">        y: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lineChart = <span class="keyword">new</span> LineChart();</span><br><span class="line">lineChart.init(data);</span><br></pre></td></tr></table></figure>
<h1 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h1><p>矩形：</p>
<ul>
<li><p><code>rect(x轴坐标,Y轴坐标,长度,高度)</code> </p>
<ul>
<li><p>X轴坐标、Y轴坐标表示矩形左上角的点的位置</p>
</li>
<li><p>此方法绘制的是轨迹，要显示出来还必须使用<code>stroke()</code>或<code>fill()</code>进行描边或填充</p>
</li>
<li><p>绘制的路径不是独立路径</p>
</li>
</ul>
</li>
<li><p><code>strokeRect(x轴坐标,Y轴坐标,长度,高度)</code></p>
<ul>
<li><p>绘制描边矩形</p>
</li>
<li><p>此方法绘制有自己的独立路径，即默认自带<code>beginPath()</code>，不会被其他路径样式覆盖</p>
</li>
</ul>
</li>
<li><p><code>fillRect(x轴坐标,Y轴坐标,长度,高度)</code></p>
<ul>
<li><p>绘制填充矩形</p>
</li>
<li><p>此方法绘制有自己的独立路径，即默认自带<code>beginPath()</code>，不会被其他路径样式覆盖</p>
</li>
</ul>
</li>
<li><p><code>clearRect(x轴坐标,Y轴坐标,长度,高度)</code></p>
<ul>
<li>清除矩形内容</li>
</ul>
</li>
</ul>
<h2 id="绘制渐变矩形"><a href="#绘制渐变矩形" class="headerlink" title="绘制渐变矩形"></a>绘制渐变矩形</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> linearGradient = ctx.createLinearGradient(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">100</span>);<span class="comment">// 设置渐变方向，以两点的坐标来定</span></span><br><span class="line">linearGradient.addColorStop(<span class="number">0</span>,<span class="string">'pink'</span>);<span class="comment">// 起始颜色，若中间需要加别的颜色可以调整第一个参数为0~1之间</span></span><br><span class="line">linearGradient.addColorStop(<span class="number">1</span>,<span class="string">'blue'</span>);<span class="comment">// 结束颜色</span></span><br><span class="line"></span><br><span class="line">ctx.fillStyle = linearGradient;</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h1 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h1><h2 id="弧形"><a href="#弧形" class="headerlink" title="弧形"></a>弧形</h2><p>一个弧度 = 一个半径的长度</p>
<ul>
<li><p><code>arc(圆心x轴,圆心y轴,起始弧度,结束弧度,绘制方向)</code></p>
<ul>
<li><p>圆心x轴,圆心y轴为圆心坐标，类型为<code>number</code></p>
</li>
<li><p>起始弧度与结束弧度类型为<code>number</code>,π用<code>Math.PI</code>表示</p>
</li>
<li><p>绘制方向类型为<code>boolean</code>，默认为顺时针</p>
</li>
<li><p>此方法绘制的是路径，需要使用描边才能显示</p>
<h2 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h2></li>
</ul>
</li>
</ul>
<p>起始点放在弧线的圆心位置，绘制弧线，闭合路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.arc(<span class="number">100</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="built_in">Math</span>.PI * <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>
<p>起始点若不设置直接闭合，则绘制出的为扇形</p>
<h2 id="n等分随机颜色的圆"><a href="#n等分随机颜色的圆" class="headerlink" title="n等分随机颜色的圆"></a>n等分随机颜色的圆</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;<span class="comment">// 等分数</span></span><br><span class="line"><span class="keyword">var</span> angle = <span class="built_in">Math</span>.PI * <span class="number">2</span> / num;<span class="comment">// 每份弧度</span></span><br><span class="line"><span class="keyword">var</span> startAngle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> w = ctx.canvas.width;<span class="comment">// 画布宽度</span></span><br><span class="line"><span class="keyword">var</span> h = ctx.canvas.height;<span class="comment">// 画布高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机颜色</span></span><br><span class="line"><span class="keyword">var</span> getRandomColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'rgb('</span>+ r + <span class="string">','</span> + g + <span class="string">','</span> + b +<span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机等分圆形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    startAngle = i * angle;</span><br><span class="line">    <span class="keyword">var</span> endAngle = (i + <span class="number">1</span>) * angle;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(w / <span class="number">2</span>,h / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(w / <span class="number">2</span>,h / <span class="number">2</span>, h / <span class="number">2</span>,startAngle,endAngle);</span><br><span class="line">    ctx.closePath();</span><br><span class="line">    ctx.fillStyle = getRandomColor();</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据数据绘制饼图"><a href="#根据数据绘制饼图" class="headerlink" title="根据数据绘制饼图"></a>根据数据绘制饼图</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">3</span>];<span class="comment">// 动态数据    </span></span><br><span class="line"><span class="keyword">var</span> w = ctx.canvas.width;<span class="comment">// 画布宽度</span></span><br><span class="line"><span class="keyword">var</span> h = ctx.canvas.height;<span class="comment">// 画布高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机颜色</span></span><br><span class="line"><span class="keyword">var</span> getRandomColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'rgb('</span>+ r + <span class="string">','</span> + g + <span class="string">','</span> + b +<span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取总数</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    total = total + data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据每份比例绘制饼图</span></span><br><span class="line"><span class="keyword">var</span> startAngle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;      </span><br><span class="line">    <span class="keyword">var</span> endAngle = startAngle +  <span class="built_in">Math</span>.PI * <span class="number">2</span> * (data[i] / total);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(w / <span class="number">2</span>,h / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(w / <span class="number">2</span>,h / <span class="number">2</span>, h / <span class="number">2</span>,startAngle,endAngle);</span><br><span class="line">    ctx.closePath();</span><br><span class="line">    ctx.fillStyle = getRandomColor();</span><br><span class="line">    ctx.fill();</span><br><span class="line"></span><br><span class="line">    startAngle = endAngle;<span class="comment">// 下一区域起始弧度为本区域结束弧度，此处必须要赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><ul>
<li><p><code>strokeText(文本内容,x坐标,y坐标)</code></p>
<ul>
<li><p>文本绘制的起点在左下角，矩形绘制的起点在左上角</p>
</li>
<li><p><code>strokeText</code>绘制出的是描边的文字，字体为空心，若要实心则使用<code>fillText</code>绘制</p>
</li>
</ul>
</li>
<li><p><code>textAlign</code></p>
<ul>
<li>文本对齐方式，基于起始坐标的对齐方式</li>
</ul>
</li>
<li><p><code>font</code></p>
<ul>
<li>设置文本大小、字体</li>
</ul>
</li>
<li><p><code>textBaseline</code></p>
<ul>
<li><p>设置基线（垂直对齐方式），基于起始坐标的对齐方式</p>
</li>
<li><p>可取值： <code>top</code>、<code>middle</code>、 <code>bottom</code>、 <code>hanging</code>、 <code>alphabetic</code>、 <code>ideographic</code></p>
</li>
<li><p><code>hanging</code> 文本的基线处于文本的正上方并且和文本相粘合(适用于印度文)</p>
</li>
<li><p><code>alphabetic</code> 默认值，基线处于文本下方，并穿过文字(适用于英文)</p>
</li>
<li><p><code>ideographic</code> 与 <code>bottom</code> 相似(适用于中文)</p>
</li>
</ul>
</li>
<li><p><code>measureText(文本内容)</code></p>
<ul>
<li><p>获取文本的宽度对象</p>
</li>
<li><p><strong>若取文本长度则需要xxx.ctx.measureText(xx).width</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="绘制带文本的饼图"><a href="#绘制带文本的饼图" class="headerlink" title="绘制带文本的饼图"></a>绘制带文本的饼图</h1><p><a href="https://garden.aezo.cn/demos/canvas饼状图.html">https://garden.aezo.cn/demos/canvas饼状图.html</a></p>
<h1 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h1><p>绘制图片使用方法<code>drawImage()</code>,可传三个参数、五个参数、九个参数</p>
<h2 id="绘制思路"><a href="#绘制思路" class="headerlink" title="绘制思路"></a>绘制思路</h2><ol>
<li><p>加载图片至内存,创建image对象</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">var</span> img = doucment.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();<span class="comment">// Image()为JS提供的内置构造函数</span></span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片加载完成才能执行代码，因此必须写在onload函数里面</p>
<p> <strong>部分浏览器如果有缓存时，图片可能会在onload函数触发之前就已经加载完毕，第一次加载图片时已经触发了onload事件，含有缓存时不再触发onload事件，为保证兼容性，最好把onload事件写在图片加载之前</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();<span class="comment">// Image()为JS提供的内置构造函数</span></span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处实现图片绘制</span></span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三种绘制方法"><a href="#三种绘制方法" class="headerlink" title="三种绘制方法"></a>三种绘制方法</h2><ul>
<li><p>三个参数 <code>darwImage(img, x, y)</code></p>
<ul>
<li><p><code>img</code> 图片对象、canvas对象、 video对象</p>
</li>
<li><p><code>x</code>、<code>y</code> 图片绘制的左上角</p>
</li>
</ul>
</li>
<li><p>五个参数 <code>darwImage(img, x, y, w, h)</code></p>
<ul>
<li><p><code>img</code> 图片对象、canvas对象、 video对象</p>
</li>
<li><p><code>x</code>、<code>y</code> 图片绘制的左上角</p>
</li>
<li><p><code>w</code>、<code>h</code> 图片绘制尺寸设置，会对图片进行缩放而不是裁剪</p>
</li>
</ul>
</li>
<li><p>九个参数 <code>drawImage(img, x, y, w, h, x1, y1, w1, h1)</code></p>
<ul>
<li><p><code>img</code> 图片对象、canvas对象、 video对象</p>
</li>
<li><p><code>x</code>、<code>y</code>、<code>w</code>、<code>h</code> 图片中的一个矩形区域</p>
</li>
<li><p><code>x1</code>、<code>y1</code>、<code>w1</code>、<code>h1</code> 画布中的一个矩形区域, <code>w1</code>、<code>h1</code>是图片的缩放尺寸而不是裁剪</p>
</li>
</ul>
</li>
</ul>
<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><h3 id="绘制关键思路"><a href="#绘制关键思路" class="headerlink" title="绘制关键思路"></a>绘制关键思路</h3><ol>
<li><p>动态获取当前图片的尺寸</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imageWidth = image.width;</span><br><span class="line"><span class="keyword">var</span> imageHeight = image.height;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算出每个小人物的尺寸</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://garden.aezo.cn/demos/canvas帧动画.html">https://garden.aezo.cn/demos/canvas帧动画.html</a></p>
<h3 id="方向键控制精灵行走的帧动画"><a href="#方向键控制精灵行走的帧动画" class="headerlink" title="方向键控制精灵行走的帧动画"></a>方向键控制精灵行走的帧动画</h3><p><a href="https://garden.aezo.cn/demos/canvas方向键控制行走动画.html">https://garden.aezo.cn/demos/canvas方向键控制行走动画.html</a></p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><hr>
<p>参考视频</p>
<p> <a href="https://www.bilibili.com/video/av53813293?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av53813293?p=2</a> (canvas视频【高级教程】)</p>
]]></content>
      <categories>
        <category>web,CSS</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/06/22/frontend/vue/</url>
    <content><![CDATA[<h1 id="Vue使用"><a href="#Vue使用" class="headerlink" title="Vue使用"></a>Vue使用</h1><p>使用Vue的两种方式：</p>
<ul>
<li><p>在页面中引入vue的js文件</p>
</li>
<li><p>脚手架 </p>
<ul>
<li><p>官方脚手架vue-cli</p>
</li>
<li><p>其他民间脚手架，如<code>webpack-simple</code></p>
</li>
<li><p>手动搭建</p>
</li>
</ul>
</li>
</ul>
<h1 id="ES6相关"><a href="#ES6相关" class="headerlink" title="ES6相关"></a>ES6相关</h1><ul>
<li><p>速写属性</p>
<p>语法糖,属性名和变量名相同时可简写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"测试"</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person对象可以简写成如下样子</span></span><br><span class="line">person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>速写方法</p>
<p>语法糖，在对象中写方法时可以简化写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"测试"</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hellllo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于如下写法</span></span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  name: <span class="string">"测试"</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hellllo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串</p>
<p>为了解决字符串的拼接问题和转换问题</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"测试"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hellllo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通写法</span></span><br><span class="line">  <span class="keyword">var</span> str1 = <span class="string">"my name is "</span> + person.name + <span class="string">"\n my age is "</span> + person.age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模板字符串，可以简化拼接，支持换行</span></span><br><span class="line">  <span class="keyword">var</span> str2 = <span class="string">`my name is <span class="subst">$&#123;person.name&#125;</span> </span></span><br><span class="line"><span class="string">  my age is <span class="subst">$&#123;person.age&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><p>配置对象中的部分内容会被提取到vue实例中：</p>
<ul>
<li><p>data</p>
</li>
<li><p>methods</p>
</li>
</ul>
<p>该过程称为注入</p>
<p>注入的目的有两个：</p>
<ul>
<li><p>完成数据响应式</p>
<p>vue2.0是通过<code>Object.defineProperty</code>方法完成了数据响应式，Vue3.0是通过<code>Class Proxy</code>完成的数据响应式</p>
<p><code>Class Proxy</code>效率会高于<code>Object.defineProperty</code>，<code>Object.defineProperty</code>无法感知新增和删除的属性，会无法完成数据响应式</p>
</li>
<li><p>绑定<code>this</code></p>
</li>
</ul>
<h1 id="虚拟DOM树"><a href="#虚拟DOM树" class="headerlink" title="虚拟DOM树"></a>虚拟DOM树</h1><p>为了提高渲染效率，vue会把模板编译成虚拟DOM树，然后再生成真实的Dom树</p>
<p>对于vue而言，提升效率的重点在于：</p>
<ul>
<li><p>减少新的虚拟DOM的生成</p>
</li>
<li><p>保证对比之后只有必要的结点有变化</p>
</li>
</ul>
<p>Vue提供了多种方式生成虚拟DOM树：</p>
<ol>
<li><p>在挂载的元素内部直接书写，此时将使用元素的outerHTML作为模板 </p>
</li>
<li><p>在template配置中书写</p>
</li>
<li><p>在render配置中用函数直接创建虚拟节点树，此时，完全脱离模板，将省略编译步骤</p>
</li>
</ol>
<p>以上步骤从上到下，优先级逐步提升，写在render配置中的会覆盖前面两种情况生成的</p>
<p><strong>虚拟节点树必须是单根的</strong></p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><p>将生成的DOM树放置到某个元素位置，称之为挂载。</p>
<p>挂载的方式： </p>
<ol>
<li><p>通过<code>el: &quot;css选择器&quot;</code>进行配置</p>
</li>
<li><p>通过<code>vue实例.$mount(&quot;css选择器&quot;)</code>进行配置</p>
</li>
</ol>
<h1 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h1><p>实例被创建 –&gt; 注入 –&gt; 编译生成虚拟DOM树 –&gt; 挂载 –&gt; 已挂载</p>
<p>数据变动时，已挂载的DOM会重新生成DOM树 –&gt; 对比新旧两树差异 –&gt; 将差异应用到真实DOM</p>
<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>vue中的元素内容使用mustache模板引擎进行解析</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a><code>v-html</code></h3><p>设置元素的innerHtml，该指令会导致元素的模板内容失效</p>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><code>v-bind</code></h3><p>绑定动态属性，此指令因为十分常用，因此提供了简写<code>:</code></p>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><code>v-on</code></h3><p>注册事件</p>
<ul>
<li><p>此功能非常常用，因此提供了简写<code>@</code></p>
</li>
<li><p>事件支持一些指令修饰符，如<code>prevent</code></p>
</li>
<li><p>事件参数会自动传递</p>
</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><code>v-for</code></h3><p>html代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-<span class="keyword">for</span>=<span class="string">"item in list"</span>&gt; &#123;&#123; item &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>javascript代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;<span class="attr">id</span> : <span class="number">1</span>, <span class="attr">name</span>: zs1&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span> : <span class="number">2</span>, <span class="attr">name</span>: zs2&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span> : <span class="number">3</span>, <span class="attr">name</span>: zs3&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span> : <span class="number">4</span>, <span class="attr">name</span>: zs4&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>v-for</code>指令除了能遍历数组还能遍历对象，遍历对象时，要写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-<span class="keyword">for</span>=<span class="string">"(value, key) in user"</span>&gt; 值是:&#123;&#123; value &#125;&#125; --- 键是&#123;&#123; key &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了value和key之外，在第三个位置还有索引。<code>v-for</code>指令中，<code>in</code>后面可以是普通数组、对象数组、对象、数字，若为数字时，<code>count in 10</code>的<code>count</code>从1开始</p>
<p>注意事项： </p>
<ol>
<li>vue 2.20+ 版本中，使用v-for指令时，需要指定key，保证数据的唯一性</li>
<li>key属性只能用number或者String</li>
<li>key在使用时必须使用<code>v-bind</code>属性的形式绑定</li>
</ol>
<h3 id="v-if和-v-show指令"><a href="#v-if和-v-show指令" class="headerlink" title="v-if和 v-show指令"></a><code>v-if</code>和 <code>v-show</code>指令</h3><p><code>v-if</code> 每次都会重新删除或创建元素，有较高的切换性能消耗<br><code>v-show</code> 每次不会重新进行DOM的删除和创建操作，只是切换了元素的display:none样式，有较高的初始渲染消耗</p>
<p>如果元素涉及到频繁的切换，最好不要用<code>v-if</code>,如果元素可能永远不会被显示出来，则推荐使用<code>v-if</code></p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h3><p>双向数据绑定，常用语表单元素，该指令是<code>v-on</code>和<code>v-bind</code>的复合版</p>
<h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><ul>
<li><p><code>key</code> </p>
<p>该属性可以干预diff算法，在同一层级，key值相同的节点会进行比对，key值不同的则不会</p>
<p>虚拟dom生成真实dom使用的就是diff算法</p>
<p>在循环生成的节点中，Vue强烈建议给予每个节点唯一且稳定的key值，建议key值用id而不是下标</p>
</li>
</ul>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>计算属性写在computed配置中，是本身不存在而需要靠计算出来的属性，与方法<code>methods</code>的区别在于：</p>
<ol>
<li><p>计算属性可以赋值，而方法不行</p>
</li>
<li><p>计算属性会进行缓存，只有其依赖的属性发生变化是才会变化，否则直接使用缓存结果，不会重新计算</p>
</li>
<li><p>方法只要调用一次，无论依赖的值有没有变化都会执行</p>
</li>
<li><p>凡是根据已有数据计算的到的新数据的无参函数，都应该尽量写成计算属性而不是方法</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 仅访问器 写法</span></span><br><span class="line">  prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器 + 设置其器写法</span></span><br><span class="line">  fullProp: &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set(val) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组的新方法"><a href="#数组的新方法" class="headerlink" title="数组的新方法"></a>数组的新方法</h1><p><code>forEach</code> <code>some</code> <code>filter</code> <code>findIndex</code> 都属于数组的新方法，都会对数组中的每一项进行遍历，执行相关操作 </p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="过滤器调用时的格式"><a href="#过滤器调用时的格式" class="headerlink" title="过滤器调用时的格式"></a>过滤器调用时的格式</h2><figure class="highlight javascript"><figcaption><span>&#123;&#123; data | 过滤器的名称 &#125; ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 过滤器的定义语法</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">// 过滤器的第一个参数被定死，永远是管道符`</span>|<span class="string">`前面传递过来的数据</span></span><br><span class="line"><span class="string">Vue.filter('过滤器的名称', function(data) &#123;&#125;)</span></span><br></pre></td></tr></table></figure>
<p><code>Vue.filter()</code>定义的是全局的过滤器，所有的vm实例共享</p>
<h2 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#xx'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line">    <span class="comment">// 定义私有过滤器，过滤器两个条件 【过滤器名称和处理函数】</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注： 过滤器调用的时候采用就近原则，如果私有过滤器和全局过滤器名称一致，优先调用私有过滤器</p>
<h1 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h1><p>官方文档提供默认的按键修饰符，除此之外还可以自定义按键修饰符(2.x版本)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.config.keyCodes.自定义名称 = 对应键盘码码值</span></span><br><span class="line">Vue.config.keyCodes.f2 = <span class="number">113</span>;</span><br></pre></td></tr></table></figure>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>vue中所有的指令，在调用时都以<code>v-</code>开头,自定义指令的时候，指令名称的前面不需要加<code>v-</code>前缀，但是调用时必须加上<code>v-</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用v-derective()定义全局的指令</span></span><br><span class="line">Vue.derective(指令的名称, &#123;</span><br><span class="line">  <span class="comment">// 在每个函数中，第一个参数永远是el,表示被绑定了指令的元素，这个el参数是一个原生的JS对象</span></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次</span></span><br><span class="line">    <span class="comment">// 和样式相关的可以放在bind中</span></span><br><span class="line">  &#125;,</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 元素插入到DOM中的时候，会执行insert函数，只触发一次</span></span><br><span class="line">  &#125;,</span><br><span class="line">  updated: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当VNode更新的时候，会执行updated,可能会触发多次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>更多钩子函数的参数具体可见官方文档: <a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0</a></p>
<h2 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#xx'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  directive: &#123;</span><br><span class="line">    <span class="comment">// 定义私有指令</span></span><br><span class="line">    指令名: &#123;</span><br><span class="line">      bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子，可以简写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>生命周期钩子 = 生命周期函数 = 生命周期时间 = Vue实例从创建、运行到销毁期间运行的各种各样的事件</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>创建期间的生命周期函数、运行期间的生命周期函数、销毁创建期间的生命周期函数</p>
<p><img src="/data/img/vue/lifecycle.png" alt="Vue生命周期图解"> </p>
<h3 id="创建生命周期"><a href="#创建生命周期" class="headerlink" title="创建生命周期"></a>创建生命周期</h3><p>第一个生命周期函数: <code>beforeCreate()</code>,与<code>data</code>和<code>methods</code>平级，在实例完全被创建出来之前执行，执行时，<code>data</code>和<code>methods</code>都还没初始化</p>
<p>第二个生命周期函数： <code>created()</code>,与<code>data</code>和<code>methods</code>平级，此时<code>data</code>和<code>methods</code>已初始化，可以操作<code>data</code>中的数据，也可以调用<code>methods</code>中的方法</p>
<p>第三个生命周期函数： <code>beforeMount()</code>,表示模板已经在内存中编译完成，但尚未把模板输出到页面中。<code>beforeMount()</code>执行时，页面中的元素没有被真正替换过来，只是之前写的一些模板字符，如在<code>beforeMount()</code>中打印对应页面中的<code>javascript </code>出现的结果是插值表达式<code>javascript </code>，而不是<code>data</code>中定义的<code>msg</code>的值</p>
<p>第四个生命周期函数: <code>mounted()</code>，表示内存中的模板已经挂载到了页面中，用户可以看到渲染好的页面，在<code>mounted()</code>中打印对应页面中的<code>javascript </code>不再是差值表达式，而是<code>data</code>中定义的<code>msg</code>的值；<code>mounted()</code>是实例创建期间的最后一个生命周期函数，当执行完<code>mounted()</code>就表示实例已经被完全创建好了，此时组件已经脱离了创建阶段，进入运行阶段。如果要通过某些插件操作页面上的DOM节点，最早要在<code>mounted()</code>中进行。</p>
<h3 id="运行期间的生命周期"><a href="#运行期间的生命周期" class="headerlink" title="运行期间的生命周期"></a>运行期间的生命周期</h3><p>运行期间的生命周期函数的触发条件是数据被改变</p>
<ul>
<li><p><code>beforeUpdate()</code> 界面还没有被更新，页面上显示的数据还是旧数据，但data中的数据被更新了，此时页面尚未和最新数据保持同步</p>
</li>
<li><p><code>updated()</code>,执行时，页面和data数据已经保持同步了，都是最新的</p>
</li>
</ul>
<h3 id="销毁阶段的生命周期"><a href="#销毁阶段的生命周期" class="headerlink" title="销毁阶段的生命周期"></a>销毁阶段的生命周期</h3><ul>
<li><p><code>beforeDestory()</code> 当执行此钩子函数时，Vue实例已经从运行阶段进入到了销毁阶段，此时所有的<code>data</code>和所有的<code>methods</code>以及过滤器、指令都处于可用状态，还没有真正执行销毁</p>
</li>
<li><p><code>destoryed()</code> 此时组件中所有的<code>data</code>和所有的<code>methods</code>以及过滤器、指令都处于不可用状态</p>
</li>
</ul>
<h1 id="vue-resource实现get-post-jsonp请求"><a href="#vue-resource实现get-post-jsonp请求" class="headerlink" title="vue-resource实现get,post,jsonp请求"></a>vue-resource实现get,post,jsonp请求</h1><p>除了vue-resource之外，还可以使用叫做<code>axios</code>的第三方包实现数据的请求。目前使用<code>axios</code>比较多，<code>vue-resource</code>此部分只做了解，嘿嘿~</p>
<h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.get(请求地址).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过result.body拿到服务器返回的成功数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.post(请求地址,请求数据,&#123; <span class="attr">emulateJSON</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求数据不能省略，手动发起的post请求默认没有表单格式，所以有的服务器接收不了</span></span><br><span class="line">    <span class="comment">// 将post的第三个参数 &#123; emulateJSON: true &#125;设置提交内容为普通表达数据格式，防止以上情况发生</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="jsonp请求"><a href="#jsonp请求" class="headerlink" title="jsonp请求"></a>jsonp请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(请求地址).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Vue中的动画-此部分先跳过，用到时再看"><a href="#Vue中的动画-此部分先跳过，用到时再看" class="headerlink" title="Vue中的动画(此部分先跳过，用到时再看)"></a>Vue中的动画(此部分先跳过，用到时再看)</h1><h2 id="使用第三方类实现动画-animate-css"><a href="#使用第三方类实现动画-animate-css" class="headerlink" title="使用第三方类实现动画(animate.css)"></a>使用第三方类实现动画(animate.css)</h2><p>引入<code>animate.css</code>后直接使用</p>
<h2 id="动画钩子函数"><a href="#动画钩子函数" class="headerlink" title="动画钩子函数"></a>动画钩子函数</h2><ol>
<li>动画钩子的第一个参数el，表示要执行动画的DOM元素，那个是原生的JS DOM 对象，可认为是通过document.getElementById(‘’)方式获取到的原生Js对象</li>
<li>beforeEnter表示动画入场之前，此时，动画尚未开始，可以在beforeEnter中，设置元素开始动画之前的起始样式</li>
</ol>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><ol>
<li><p>箭头函数</p>
<ul>
<li><p>任何可以书写匿名函数的位置均可以书写箭头函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当只有一个参数时，可以进一步简化成： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当返回语句只有一条内容时可以省略<code>{}</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数将会绑定<code>this</code>为函数书写位置的<code>this</code>值</p>
</li>
</ul>
</li>
<li><p>模块化</p>
<ul>
<li><p>没有模块化的世界：全局变量污染、难以管理依赖</p>
</li>
<li><p>常见的模块化标准： CommonJs、ES6 Module、AMD、CMD、UMD</p>
</li>
</ul>
</li>
</ol>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>每一个JS文件可以认为是一个模块，引入时加上<code>type=&quot;module&quot;</code>就能将此js文件模块化，此方式引入后，界面使用windows.xxx(xxx为引入js文件的方法名)将无法访问，以此保证不污染全局变量。</p>
<p>使用<code>export default function...</code> 可以将自身模块暴露出去供别的模块使用，使用时需要用<code>import</code>进行导入</p>
<p>为了拆分Vue实例的代码量，能以不同的组件来划分不同的功能模块。</p>
<h3 id="组件化和模块化的区别"><a href="#组件化和模块化的区别" class="headerlink" title="组件化和模块化的区别"></a>组件化和模块化的区别</h3><ul>
<li><p>模块化是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的职能单一</p>
</li>
<li><p>组件化是从UI界面的角度进行划分的，方便UI组件的重复利用</p>
</li>
</ul>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>一个完整的网页是复杂的，如果将其作为一个整体来进行开发，将会遇到以下困难：</p>
<ul>
<li><p>代码凌乱臃肿</p>
</li>
<li><p>不易协作</p>
</li>
<li><p>难以复用</p>
</li>
</ul>
<p>vue推荐使用一种更加精细的控制方案——组件化开发</p>
<p>所谓组件化就是吧一个页面中区域功能细分，每一个区域成为一个组件，每个组件包含：</p>
<ul>
<li><p>功能（js代码）</p>
</li>
<li><p>内容（模板代码）</p>
</li>
<li><p>样式（css代码）</p>
</li>
</ul>
<p>由于没有构建工具的支撑，css代码暂时无法放到组件中</p>
<h2 id="创建组件的方式"><a href="#创建组件的方式" class="headerlink" title="创建组件的方式"></a>创建组件的方式</h2><ol>
<li>使用<code>Vue.extend</code>创建全局Vue组件，通过<code>template</code>属性指定组件要展示的html结构</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组件模板对象</span></span><br><span class="line"><span class="keyword">var</span> com1 = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;这是用 Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Vue.component('组件的名称', 创建出来的组件模板对象)</span></span><br><span class="line">Vue.component(<span class="string">'myCom1'</span>, com1);</span><br></pre></td></tr></table></figure>
<p>如果要使用组件，直接把组件的名称以HTML标签的形式引用。如果使用<code>Vue.component</code>定义全局组件，组件名称使用了驼峰命名，在引用时，需要将大写的驼峰改成小写字母，并加上<code>-</code>。<br>例如： 组件名称<code>myCom1</code>,在引用时，页面的标签应为<code>&lt;my-com1&gt;&lt;/my-com1&gt;</code>;组件名称<code>mycom1</code>,在引用时，页面的标签应为<code>&lt;mycom1&gt;&lt;/mycom1&gt;</code></p>
<p>简化写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Vue.component(<span class="string">'myCom1'</span>, Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;这是用 Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用<code>Vue.component</code>注册组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'myCom2'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;这是用 Vue.extend 创建的组件&lt;/h3&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h2><ol>
<li>使用 <code>v-if</code>、<code>v-else</code> 实现组件的切换</li>
<li>使用 <code>component</code> 标签控制组件的切换(Vue内置组件： <code>component</code> <code>template</code> <code>transition</code> <code>transitionGroup</code>)</li>
<li>使用组件切换动画切换</li>
</ol>
<h2 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h2><h3 id="父组件向子组件传值-通过属性传值，通过事件绑定v-on传递方法"><a href="#父组件向子组件传值-通过属性传值，通过事件绑定v-on传递方法" class="headerlink" title="父组件向子组件传值(通过属性传值，通过事件绑定v-on传递方法)"></a>父组件向子组件传值(通过属性传值，通过事件绑定<code>v-on</code>传递方法)</h3><p>父组件可以在引用子组件时，通过属性绑定的形式(:)把需要传递给子组件的数据，以属性绑定的形式传递到子组件内部，供子组件使用。</p>
<p>父组件传递的数据放在子组件的<code>props</code>数组中，组件中的所有<code>props</code>中的数据都是通过父组件传递给子组件的。 </p>
<p>注： </p>
<ol>
<li>子组件中的<code>data</code>数据并不是通过父组件传递过来的，而是子组件本身私有的，比如子组件通过Ajax请求回来的数据都可以放在data中</li>
<li><code>data</code>中的数据都是可读可写的，<code>props</code>中的数据都是只读的</li>
</ol>
<p>父组件传递方法给子组件，使用事件绑定机制<code>v-on</code>定义需要传递的方法，子组件通过<code>this.$emit(&#39;传递的方法名&#39;，&#39;参数1&#39;， &#39;参数2&#39;...)</code>进行调用。</p>
<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>通过事件回传</p>
<h1 id="webpack-version-3-6"><a href="#webpack-version-3-6" class="headerlink" title="webpack(version 3.6)"></a>webpack(version 3.6)</h1><h2 id="webpack-dev-server-自动编译打包工具"><a href="#webpack-dev-server-自动编译打包工具" class="headerlink" title="webpack-dev-server(自动编译打包工具)"></a>webpack-dev-server(自动编译打包工具)</h2><p>用于实现自动打包编译功能，依赖于webpack，因此安装此工具前即使全局已经装过webpack，在本地项目中也必须安装webpack以保证正常使用。</p>
<ol>
<li>运行 <code>npm i webpack-dev-server -D</code>命令，将此工具安装到项目的本地开发依赖</li>
<li>安装完毕后，在终端输入<code>webpack-dev-server</code>即可使用</li>
<li><code>webpack-dev-server</code>安装在本地项目中，无法把它当成脚本命令，因此在<code>powershell</code>命令中无法直接使用，因此要在项目的<code>package.json</code>中加入依赖。</li>
<li><code>webpack-dev-server</code>打包生成的<code>bundle.js</code>文件并没有存放到实际的物理磁盘中，而是直接托管到电脑的内存中，所以在项目的根目录中找不到这个打包好的<code>bundle.js</code></li>
</ol>
<h3 id="webpack-dev-server常用命令参数"><a href="#webpack-dev-server常用命令参数" class="headerlink" title="webpack-dev-server常用命令参数"></a>webpack-dev-server常用命令参数</h3><p>第一种方式（推荐写法）： 在<code>package.json</code>中配置<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span> : &#123;</span><br><span class="line">  <span class="string">"dev"</span> : <span class="string">"webpack-dev-server --open --port 3000 --contentBase src --hot"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>open</code>——编译完成后自动打开浏览器</p>
<p><code>port</code>—— 自定义端口</p>
<p><code>contentBase</code> —— 设置托管目录</p>
<p><code>hot</code> —— 打补丁；热部署，实现浏览器的不刷新重载</p>
<p>第二种方式（了解即可）：在<code>webpack.config.js</code>中配置<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="comment">// 启用热更新的第2步</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">  devServer : &#123;</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    contBase: <span class="string">'src'</span>,</span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// 启用热更新的第1步</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="comment">// 配置插件的节点</span></span><br><span class="line">    <span class="comment">// 启用热更新的第3步</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()<span class="comment">// new一个热更新的模块对象</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>在内存中，根据index模板页面生成内存页面</p>
<ol>
<li>安装<code>html-webpack-plugin</code>插件(<code>npm i html-webpack-plugin -D</code>)</li>
<li><p>在<code>webpack.config.js</code>中导入此插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要是插件，都需要放到plugins节点中</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">  plugins: [<span class="comment">// 配置插件的节点</span></span><br><span class="line">    <span class="comment">// 创建一个在内存中生成html页面插件</span></span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定模板页面，将来会根据指定页面路径去生成内存中的页面</span></span><br><span class="line">      template: path.join(_dirname, <span class="string">'./src/index.html'</span>),</span><br><span class="line">      <span class="comment">// 指定生成的页面名称</span></span><br><span class="line">      filename: <span class="string">'index123.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>html-webpack-plugin</code>会自动把打包好的<code>bundle.js</code>追加到页面中</p>
</li>
</ol>
<h2 id="loader-第三方处理器"><a href="#loader-第三方处理器" class="headerlink" title="loader(第三方处理器)"></a>loader(第三方处理器)</h2><p>webpack默认只能打包处理js类型的文件，不能处理其它非js类型的文件，如果需要处理非js类型的文件，则需要手动安装一些合适的第三方loader加载器。如需要打包处理css文件，需要安装<code>style-loader</code>和<code>css-loader</code></p>
<ol>
<li>安装命令： <code>npm i style-loader css-loader -D</code></li>
<li>在<code>webpack.config.js</code>的<code>module</code>节点中配置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">module</span>: &#123;<span class="comment">// 此节点用于配置所有第三方木块加载器</span></span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 配置处理.css文件第三方loader规则,webpack1.x版本的use中可省略-loader，2.x及以后的版本都不能省略</span></span><br><span class="line">      &#123;<span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>webpack</code>处理第三方文件类型的过程：</p>
<ol>
<li>发现这个文件的类型不是js，去配置文件中查找是否有第三方loader规则</li>
<li>若能找到对应规则，调用对应的loader处理此文件类型</li>
<li>调用loader时，是从后往前调用(如上述<code>[&#39;style-loader&#39;, &#39;css-loader&#39;]</code>,先调用的是<code>css-loader</code>后调用<code>style-loader</code>)</li>
<li>当最后一个loader调用完毕时，会把处理结果直接交给webpack进行打包合并，最终输出到<code>bundle.js</code>中</li>
</ol>
<h3 id="处理less文件的loader"><a href="#处理less文件的loader" class="headerlink" title="处理less文件的loader"></a>处理less文件的loader</h3><ol>
<li>安装<code>less</code>: <code>npm i less</code></li>
<li>安装<code>less-loader</code>: <code>npm i less-loader -D</code></li>
<li>在上述<code>module.rules</code>中配置<code>less-loader</code>规则： <code>{test: /\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;,&#39;less-loader&#39;]}</code></li>
</ol>
<p>注： less是less-loader内部依赖，因此需要先安装less，但无需将less配置到<code>webpack.config.js</code>中</p>
<h3 id="处理scss文件的loader"><a href="#处理scss文件的loader" class="headerlink" title="处理scss文件的loader"></a>处理scss文件的loader</h3><p><code>node-sass</code>是<code>sass-loader</code>内部依赖，需要先安装<code>node-sass</code>，但无需将<code>node-sass</code>配置到<code>webpack.config.js</code>中</p>
<ol>
<li>安装<code>node-sass</code>: <code>cnpm i node-sass -D</code>(<code>node-sass</code>一般都用cnpm安装，npm一般比较难装成功)</li>
<li>安装<code>sass-loader</code>:  <code>npm i sass-loader -D</code></li>
<li>在<code>module.rules</code>中配置<code>sass-loader</code>规则：<code>{test: /\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;,&#39;sass-loader&#39;]}</code></li>
</ol>
<h3 id="处理css文件中的url地址的loader"><a href="#处理css文件中的url地址的loader" class="headerlink" title="处理css文件中的url地址的loader"></a>处理css文件中的url地址的loader</h3><p>默认情况下webpack无法处理文件中的url地址，无论是图片还是字体库，只要是url地址都处理不了，需要安装<code>url-loader</code></p>
<p><code>file-loader</code>是<code>url-loader</code>内部依赖，需要先安装<code>file-loader</code>，但无需将<code>file-loader</code>配置到<code>webpack.config.js</code>中</p>
<ol>
<li>安装<code>file-loader</code>和<code>url-loader</code>: <code>cnpm i url-loader file-loader -D</code></li>
<li>在<code>module.rules</code>中配置<code>url-loader</code>规则：<code>{test: /\.jpg|png|gif|bmp|jpeg$/, use: &#39;url-loader?limit=7631&amp;name=[name].[ext]&#39;}</code></li>
</ol>
<p>注： 配置<code>url-loader</code>时，<code>&#39;url-loader?limit=7631&amp;name=[name].[ext]&#39;</code>中:</p>
<ul>
<li><code>?</code>后面表示传参数</li>
<li><code>limit=7631</code>表示limit给定的图片大小值，单位为kb; 当图片的大小&gt;7631kb时，图片路径会被base64加密，当图片大小&lt;=limit时，则不会被转为base64的字符串</li>
<li><code>name=[name].[ext]</code> 表示文件名沿用原始名称，而不用自动生成的hash值</li>
</ul>
<h4 id="使用url-loader处理字体文件"><a href="#使用url-loader处理字体文件" class="headerlink" title="使用url-loader处理字体文件"></a>使用<code>url-loader</code>处理字体文件</h4><p>在<code>module.rules</code>中配置<code>url-loader</code>规则：<code>{test: /\.ttf|eot|svg|woff|woff2$/, use: &#39;url-loader&#39;}</code></p>
<p>一般不要把图片文件和字体文件的url-loader配置写一起，而是分成两条规则写。</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="填充字符串"><a href="#填充字符串" class="headerlink" title="填充字符串"></a>填充字符串</h2><p>ES6中的字符串新方法<code>String.prototype.padStart(maxLength, filterString= &#39; &#39;)</code> 或 <code>String.prototype.padEnd(maxLength, filterString= &#39; &#39;)</code>来填充字符串</p>
<ul>
<li><code>maxLength</code> 表示填充完毕的总长度</li>
<li><code>filterString= &#39; &#39;</code> 表示填充的字符</li>
<li><code>padStart</code>表示从前面填充，<code>padEnd</code>从后面填充</li>
</ul>
<p>例如填充时间格式中的月</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="使用脚手架搭建工程"><a href="#使用脚手架搭建工程" class="headerlink" title="使用脚手架搭建工程"></a>使用脚手架搭建工程</h2><p>vue-cli</p>
<hr>
<p>参考视频: <a href="https://www.bilibili.com/video/av27969216/?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av27969216/?p=1</a></p>
]]></content>
      <categories>
        <category>web</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>web</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2020/10/25/java/beforeArchitect/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><p><code>ODBC</code>: 一套连接数据源的标准</p>
</li>
<li><p><code>JDBC</code>: <code>Java Database Connectivity</code></p>
<p>  基于Java语言访问数据库的一种技术。</p>
<p>  JDBC是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时JDBC也是个商标名</p>
<p>  JDBC设计思想： 由SUN公司提供访问数据库的接口，由数据库厂商提供对这些接口的实现，程序员编程时都是针对接口进行编程的。</p>
<p>  JDBC包括一套JDBC的API和一套程序员和数据库厂商都必须去遵守的规范。</p>
<pre><code>- java.sql包： 提供访问数据库基本的功能
- javax.sql包： 提供扩展的功能
</code></pre><p>  JDBC是数据库的中间件</p>
<p>  JDBC可以做什么？</p>
<pre><code>- 连接到数据库
- 在java app中执行SQL命令
- 处理结果
</code></pre></li>
<li><p><code>SPI</code></p>
<p><code>Service Provider Interface</code><br>。是JDK内置的一种服务提供发现机制，SPI是一种动态替换发现的机制，比如有个接口，想运行时动态给它添加实现，你只需要添加一个实现。我们经常遇到的就是<code>java.sql.Driver</code>接口，其他不同厂商可以针对同一接口做出不同的实现，<code>mysql</code>和<code>posthresql</code>都有不同的实现提供给客户，而Java的SPI机制可以为某个接口寻找服务实现</p>
</li>
</ul>
<h2 id="面向接口编程-java-sql"><a href="#面向接口编程-java-sql" class="headerlink" title="面向接口编程 java.sql"></a>面向接口编程 java.sql</h2><p>如果需要建立连接，java中提供了一套标准，数据库厂商来进行实现，包含实现子类，实现子类的jar文件一般放在数据库安装目录下</p>
<ol>
<li>java.sql.Driver 驱动</li>
<li>java.sql.Connection 连接</li>
<li><p>java.sql.Statement 静态处理快</p>
<p>java.sql.PreparedStatement 预处理块</p>
</li>
<li><p>java.sql.ResultSet 结果集</p>
</li>
<li>java.sql.ResultSetMetaData 结果集元数据</li>
</ol>
<h3 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 加载驱动</span></span><br><span class="line"><span class="comment">/* 当执行了当前代码之后，会返回一个class对象，在此对象的创建过程中，会调用具体类的静态代码块 */</span></span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接</span></span><br><span class="line"><span class="comment">/** 第一步已经将driver对象注册到了drivermanager中，所以此时可以直接通过DriverManager来获取数据库连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要输入连接数据库的参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- url: 数据库的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- username： 用户名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- password： 密码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"scott"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 测试连接是否成功</span></span><br><span class="line">System.out.println(connection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义sql语句</span></span><br><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 准备静态处理块对象，需要一个对象来存放sql语句，将对象进行执行的时候调用的是数据库的服务，数据库会从当前对象中拿到对应的sql语句进行执行</span></span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 执行sql语句，返回值对象是结果集合</span></span><br><span class="line">ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 循环处理</span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 通过下标索引编号获取值，索引从1开始</span></span><br><span class="line">    <span class="keyword">int</span> anInt = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过列名获取值</span></span><br><span class="line">    String ename = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 关闭连接</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/10/27/java/beforeArchitect/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JAVA反射机制是在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法功能称为Java语言的反射机制。 </p>
<p>想要解剖一个类，必须先要获取到该类的字节码文件对象。而而解剖使用的就是Class类中的方法，所以现在要获取到每一个字节码文件对应的Class类型的对象。</p>
<h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><ol>
<li><p>通过class.forName()来获取Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.xx.entity.Emp"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>类名.class</code>来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Emp&gt; <span class="class"><span class="keyword">class</span> </span>= Emp.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象的<code>getClass()</code>来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends Emp&gt; clazz = <span class="keyword">new</span> Emp().getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本数据类型可以通过TYPE的方式获取class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐第1、2种方式</p>
<h2 id="Class对象方法"><a href="#Class对象方法" class="headerlink" title="Class对象方法"></a>Class对象方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.xx.xx.类名"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>getFields()</code></p>
<p>获取成员变量，包括子类、父类，同时只能包含公共的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field: fields) &#123;</span><br><span class="line">    <span class="comment">// 字段名称</span></span><br><span class="line">    field.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段类型</span></span><br><span class="line">    field.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段修饰符</span></span><br><span class="line">    field.getModifiers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getDeclaredFields()</code></p>
<p>获取当前类的所有属性，不仅仅是公共访问修饰符，所有的访问修饰符都可以拿到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// xx表示该类中的某个字段名</span></span><br><span class="line">Field xx = clazz.getDeclaredField(<span class="string">"xx"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象设值</p>
<p>假设有一个类<code>Student</code>，含有私有属性<code>address</code>(用<code>private</code>修饰的字段)，正常情况下<code>private</code>修饰的属性无法被外界访问，但是通过反射能够为<code>address</code>字段设值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.xx.entity.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取address字段</span></span><br><span class="line">Field address = clazz.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将address字段的访问权限设置为可访问，true表示能访问</span></span><br><span class="line">address.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为address字段赋值</span></span><br><span class="line">Object o = clazz.newInstance();</span><br><span class="line">address.set(o, <span class="string">"上海市"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>反射在一定程度上破坏了封装性，需要合理使用</strong></p>
</li>
<li><p><code>getMethods()</code></p>
<p>获取对象中的普通方法，包含当前对象和父类对象的公共方法</p>
</li>
<li><p><code>getDeclaredMethods()</code></p>
<p>获取当前类中的所有方法，包括私有方法</p>
</li>
<li><p><code>getConstructors()</code></p>
<p>获取对象所有的公有构造方法,不包含父类构造方法</p>
</li>
<li><p><code>getDeclaredConstructors()</code></p>
<p>获取对象的所有构造方法，包括私有,不包含父类构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用私有的构造方法</span></span><br><span class="line">Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object o2 = declaredConstructor.newInstance(<span class="string">"参数1"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>UML</title>
    <url>/2020/02/26/others/UML/starUml/</url>
    <content><![CDATA[<h1 id="UML基础-1"><a href="#UML基础-1" class="headerlink" title="UML基础 ^1"></a>UML基础 <a href="https://www.bilibili.com/video/av34973179?from=search&amp;seid=955581513016587565" title="熟练使用UML" target="_blank" rel="noopener">^1</a></h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><code>OO(Object-Orientation)</code> 面向对象，一种系统建模技术 </p>
</li>
<li><p><code>OOP(Object-Orientation Programming)</code> 按照<code>OO</code>的方法来开发程序的过程</p>
</li>
<li><p><code>OOAD(Object Oriented Analysis and Design)</code> 面向对象的分析与设计，根据<code>OO</code>的方法学，对软件系统进行分析和设计的过程(分析阶段<code>OOA</code>、设计阶段<code>OOD</code>)</p>
<ul>
<li><p><code>OOA</code>阶段需要解决的核心问题是 <code>what to do</code></p>
<ul>
<li><p>建立针对业务问题域的清晰视图</p>
</li>
<li><p>列出系统必须要完成的核心任务</p>
</li>
<li><p>针对问题域建立公共词汇表</p>
</li>
<li><p>列出针对此问题域的最佳解决方案</p>
</li>
</ul>
</li>
<li><p><code>OOD</code>阶段需要解决的核心问题是 <code>How to do</code></p>
<ul>
<li><p>如何解决具体的业务问题</p>
</li>
<li><p>引入系统工作所需的支持元素</p>
</li>
<li><p>定义系统的实现策略</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>对象</code>: </p>
<ul>
<li><p>客观存在的、唯一的实体</p>
</li>
<li><p>是面向对象编程过程中分析与解决问题的出发点与基础</p>
</li>
<li><p>拥有自己的标识、数据与行为</p>
</li>
<li><p>可以简单或复杂</p>
</li>
<li><p>可以抽象或具体</p>
</li>
<li><p>在<code>OOP</code>中是一个类的动态实例</p>
</li>
</ul>
</li>
</ul>
<h3 id="OOP主要特征"><a href="#OOP主要特征" class="headerlink" title="OOP主要特征"></a>OOP主要特征</h3><ul>
<li><p>抽象(abstract)</p>
<ul>
<li><p>忽略一个对象或实体的细节而只关注其本质特征的过程</p>
</li>
<li><p>简化功能与格式</p>
</li>
<li><p>帮助用户与对象交互</p>
</li>
</ul>
</li>
<li><p>封装(encapsulation)</p>
<ul>
<li><p>隐藏数据和实现</p>
</li>
<li><p>提供公共方法供用户调用功能</p>
</li>
<li><p>对象的两种视图： 外部视图(对象能做的工作)、内部视图(对象如何完成工作)  </p>
</li>
</ul>
</li>
<li><p>继承(inheritance)</p>
<ul>
<li><p>通过存在的类型定义新类型的机制</p>
</li>
<li><p>通常在两个类型之间存在<code>is a</code>或<code>kind of</code>这样的关系</p>
</li>
<li><p>通过继承可实现代码重用，是多态的基础</p>
</li>
</ul>
</li>
<li><p>多态(polymorphism)</p>
<ul>
<li><p>一个名称，多种形式</p>
</li>
<li><p>基于继承的多态</p>
</li>
<li><p>调用方法时根据所给对象的不同，选择不同的处理方式</p>
</li>
</ul>
</li>
<li><p>关联(association)</p>
<ul>
<li><p>对象之间交互时的一种引用方式</p>
</li>
<li><p>当一个对象通过对另一个对象的引用去使用另一个对象的服务或操作时，两个对象之间便产生了关联</p>
</li>
</ul>
</li>
<li><p>聚合(aggregation)</p>
<ul>
<li><p>一种关系较强的关联关系，一个对象成为另一个对象的组成部分</p>
</li>
<li><p>两个对象之间存在<code>has a</code>的关系，一个对象作为另一个对象的属性存在，在外部对象被生产时可由客户端指定与其关联的内部对象</p>
</li>
<li><p>e.g. 汽车与轮胎的关系： 轮胎作为汽车的一部分可以和汽车分别生产后装配起来，但汽车也可换别新轮胎，轮胎也可与其他汽车装配使用</p>
</li>
</ul>
</li>
<li><p>组合(composition)</p>
<ul>
<li><p>关联关系中最为强烈的一种关系</p>
</li>
<li><p>当一个对象包含另一个对象时，外部对象负责管理内部对象的生命周期情况</p>
</li>
<li><p>内部对象的创建又由外部对象自己控制</p>
</li>
<li><p>外部对象不存在时内部对象也不能存在</p>
</li>
</ul>
</li>
<li><p>内聚与耦合(cohesion &amp; coupling)</p>
<p>内聚： 度量一个类独立完成某项工作的能力</p>
<p>耦合： 度量系统内或系统之间依赖关系的复杂度</p>
<p>设计原则： 增加内聚，减少耦合(高内聚低耦合)</p>
</li>
</ul>
<h3 id="域模型"><a href="#域模型" class="headerlink" title="域模型"></a>域模型</h3><p>在面向对象术语中也可称为设计模型，由具有状态和行为的域对象组成。</p>
<p>域对象之间的关系：</p>
<ul>
<li><p>关联(Association)</p>
</li>
<li><p>依赖(Dependency)</p>
</li>
<li><p>聚集(Aggregation)</p>
<p>整体和部分之间的关系</p>
</li>
<li><p>一般化(泛化)(Generalization)</p>
<p>类之间的继承关系</p>
</li>
</ul>
<h3 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h3><p>传统开发过程： 瀑布模型</p>
<p><img src="/source/data/img/uml/瀑布模型.png" alt="传统开发过程"></p>
<p>OOAD开发过程：</p>
<ul>
<li><p>大项目分解成子项目</p>
</li>
<li><p>使用UML工具</p>
</li>
<li><p>统一软件开发过程是迭代、递增的开发过程</p>
</li>
</ul>
<h3 id="迭代、递增的项目生命周期"><a href="#迭代、递增的项目生命周期" class="headerlink" title="迭代、递增的项目生命周期"></a>迭代、递增的项目生命周期</h3><p>在每一个迭代的阶段应该做以下工作：</p>
<ul>
<li><p>选择并分析相关用例</p>
</li>
<li><p>根据所选架构进行设计</p>
</li>
<li><p>在组件层次实现设计</p>
</li>
<li><p>验证组件满足用例的需要</p>
</li>
</ul>
<p>当一次迭代满足目标后，开发进入下一个迭代周期。</p>
<p>主要阶段：</p>
<p>Inception - start up</p>
<p>Elaboration - refine</p>
<p>Constructon - implement</p>
<p>Transition - promotion</p>
<p>每个周期包含一次或多次迭代</p>
<p>一个阶段的结束称之为“里程碑(milestone)”</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>此阶段的增量集中于：</p>
<ul>
<li><p>项目启动</p>
</li>
<li><p>建立业务模型</p>
</li>
<li><p>定义业务问题域</p>
</li>
<li><p>找出主要的风险因素</p>
</li>
<li><p>定义项目需求的外延</p>
</li>
<li><p>创建业务问题域的相关说明文档</p>
</li>
</ul>
<h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>此阶段增量集中于： </p>
<ul>
<li><p>高层的分析与设计</p>
</li>
<li><p>建立项目的基础框架</p>
</li>
<li><p>监督主要的风险因素</p>
</li>
<li><p>制定达成项目目标的创建计划</p>
</li>
</ul>
<h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>代码及功能的实现</p>
<h4 id="移交阶段"><a href="#移交阶段" class="headerlink" title="移交阶段"></a>移交阶段</h4><p>此阶段增量集中于：</p>
<ul>
<li><p>向用户发布产品</p>
</li>
<li><p>beta测试</p>
</li>
<li><p>执行性能调优，用户培训和接收测试</p>
</li>
</ul>
<h4 id="每个阶段包含的工作流"><a href="#每个阶段包含的工作流" class="headerlink" title="每个阶段包含的工作流"></a>每个阶段包含的工作流</h4><p>每一次递增都由5部分组成： 需求与初始分析、分析、设计、实现、测试。</p>
<p>每一次迭代执行工作流的深度不同，早期的迭代在深度上覆盖初始工作流，后期迭代在深度上覆盖后期工作流。</p>
<h4 id="迭代、递增生命周期的优势"><a href="#迭代、递增生命周期的优势" class="headerlink" title="迭代、递增生命周期的优势"></a>迭代、递增生命周期的优势</h4><ul>
<li><p>降低成本</p>
</li>
<li><p>便于更好地维护项目进度</p>
</li>
<li><p>便于团队的协作开发</p>
</li>
<li><p>便于适应用户需求的动态变化</p>
</li>
</ul>
<h2 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h2><p><code>Unified Modeling Language</code>: 统一建模语言。图形化语言表示。</p>
<h3 id="UML图的分类"><a href="#UML图的分类" class="headerlink" title="UML图的分类"></a>UML图的分类</h3><h4 id="静态模型-static-model"><a href="#静态模型-static-model" class="headerlink" title="静态模型(static model)"></a>静态模型(static model)</h4><ul>
<li><p>创建并记录一个系统的静态特征</p>
</li>
<li><p>反映一个软件系统基础、固定的框架结构</p>
</li>
<li><p>创建相关问题域主要元素的视图</p>
</li>
</ul>
<p>静态建模包括： 用例图(user case diagrams)、类图(class diagrams)、对象图(object diagrams)、组件图(component diagrams)、部署图(deployment diagrams)</p>
<h4 id="动态模型-dynamic-model"><a href="#动态模型-dynamic-model" class="headerlink" title="动态模型(dynamic model)"></a>动态模型(dynamic model)</h4><p>动态建模用以展示系统的行为</p>
<p>动态建模包括： 时序图(sequence diagrams)、协作图(collaboration diagrams)、状态图(state chart diagrams)、活动图(activity diagrams)</p>
<h2 id="九大核心UML图"><a href="#九大核心UML图" class="headerlink" title="九大核心UML图"></a>九大核心UML图</h2><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>展示系统的核心功能与其交互的用户，用户被称之为<code>&quot;活动者(Actor)&quot;</code></p>
<p>用例使用椭圆表示，为简化建模过程，用例图可标注优先级</p>
<h3 id="使用starUML绘制用例图"><a href="#使用starUML绘制用例图" class="headerlink" title="使用starUML绘制用例图"></a>使用starUML绘制用例图</h3><ol>
<li>在 <code>Model Explorer</code>工具栏中选中<code>Model</code>–&gt;右键选择<code>Add Diagram</code> –&gt; 选择 <code>Use Case Diagram</code></li>
</ol>
<p><img src="/source/data/img/uml/用例图绘制1.png" alt="用例图绘制步骤1"></p>
<ol start="2">
<li>在<code>Tool Box</code>工具栏中选择模板进行绘制</li>
</ol>
<p><img src="/source/data/img/uml/用例图绘制2.png" alt="用例图绘制步骤2"></p>
<p>上图表示 <code>活动者admin</code>可执行<code>add</code> <code>update</code> <code>delete</code> <code>query</code>操作，<code>活动者guest</code>只能执行<code>query</code>操作</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>表现类的特征，描述多个类、接口特征以及对象之间的协作与交互。</p>
<p>类图由一个或多个矩形区域构成，包括类型(类名)、属性(可选)、操作(可选)</p>
<h3 id="使用starUML绘制类图"><a href="#使用starUML绘制类图" class="headerlink" title="使用starUML绘制类图"></a>使用starUML绘制类图</h3><p><img src="/source/data/img/uml/类图示例.png" alt="类图示例"></p>
<hr>
<p>参考文章</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2020/04/29/java/beforeArchitect/springboot/</url>
    <content><![CDATA[<h1 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h1><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>SpringBoot主要解决的是在微服务架构下简化配置（有快速配置）、前后端分离、快速开发</p>
<p>优点： </p>
<ul>
<li>提供了快速启动入门</li>
<li>开箱即用、提供默认配置</li>
<li>内嵌容器化web项目</li>
<li>没有冗余代码生成和XML配置要求</li>
</ul>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>模板引擎： 如 <code>Thymeleaf</code>, <code>FreeMarker</code></p>
<p>有嵌套和解析的过程，先加载静态页面，在静态页面上添加一些标记，模板引擎的内核会根据添加的标记动态渲染数据</p>
<p><strong>计算向数据移动</strong></p>
<h3 id="MVC架构思想"><a href="#MVC架构思想" class="headerlink" title="MVC架构思想"></a>MVC架构思想</h3><p>? JVM垃圾回收机制现在已经不是引入计数器的方式，改为GCroot</p>
<p>? Spring不支持循环引用，主要是因为其自身结构问题。</p>
<h3 id="基于SpringBoot的MVC"><a href="#基于SpringBoot的MVC" class="headerlink" title="基于SpringBoot的MVC"></a>基于SpringBoot的MVC</h3><ul>
<li>数据的展示查询</li>
</ul>
<h3 id="分层解释"><a href="#分层解释" class="headerlink" title="分层解释"></a>分层解释</h3><ul>
<li><p><code>Controller</code>层</p>
<p>一般写业务逻辑跳转</p>
</li>
<li><p><code>Service</code>层</p>
<p>业务层逻辑代码</p>
</li>
<li><p><code>DAO</code>层</p>
<p>操作持久层</p>
</li>
</ul>
<h3 id="各种依赖"><a href="#各种依赖" class="headerlink" title="各种依赖"></a>各种依赖</h3><h4 id="JPA-Java-Persistence-API"><a href="#JPA-Java-Persistence-API" class="headerlink" title="JPA(Java Persistence API)"></a>JPA(Java Persistence API)</h4><p>  添加依赖 <code>Spring-data-jpa</code>, 用于访问数据源的框架，可以把数据库的表映射成对象，一一对应</p>
<h3 id="注释解说"><a href="#注释解说" class="headerlink" title="注释解说"></a>注释解说</h3><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a><code>@RequestMapping</code></h4><p>请求路径</p>
<h4 id="PathVariable-quot-key-quot"><a href="#PathVariable-quot-key-quot" class="headerlink" title="@PathVariable(&quot;key&quot;)"></a><code>@PathVariable(&quot;key&quot;)</code></h4><p>取URI中<code>key</code>对应的值</p>
<h1 id="实践中报错记录"><a href="#实践中报错记录" class="headerlink" title="实践中报错记录"></a>实践中报错记录</h1><h2 id="下载依赖包速度过慢"><a href="#下载依赖包速度过慢" class="headerlink" title="下载依赖包速度过慢"></a>下载依赖包速度过慢</h2><p>解决方法： 配置阿里云镜像地址</p>
<p>全局配置步骤： </p>
<ol>
<li>找到maven的<code>setting.xml</code>文件，若没有可以新建</li>
<li><p>在<code>setting.xml</code>文件的<code>mirrors</code>节点下面添加子节点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="运行成功并退出"><a href="#运行成功并退出" class="headerlink" title="运行成功并退出"></a>运行成功并退出</h2><p><code>Process finished with exit code 0</code></p>
<p>原因： <code>Pom.xml</code>文件缺少依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="引入spring-security每次调用需要输入登录名密码"><a href="#引入spring-security每次调用需要输入登录名密码" class="headerlink" title="引入spring-security每次调用需要输入登录名密码"></a>引入<code>spring-security</code>每次调用需要输入登录名密码</h2><p>解决办法： 关闭验证</p>
<ol>
<li><p><code>springboot 2.0</code> 之前可通过yml配置关闭验证：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">security.basic.enabled=false</span></span><br><span class="line"><span class="string">management.security.enabled=false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>springboot 2.x</code>后关闭验证</p>
<p> <code>springboot 2.x</code> 后上述配置被废除，需要在启动类前的 <code>@SpringBootApplication</code> 注解中加入 <code>exclude</code> 属性 <code>scurityAutoConfiguration</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = SecurityAutoConfiguration.class)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据库连接报错"><a href="#数据库连接报错" class="headerlink" title="数据库连接报错"></a>数据库连接报错</h2><p>报错内容: <code>java.sql.SQLException: The server time zone value &#39;�й���׼ʱ��&#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the &#39;serverTimezone&#39; configuration property) to use a more specifc time zone value if you want to utilize time zone support.</code></p>
<p>报错原因： 数据库连接时区配置问题</p>
<p>解决方法： 数据库配置添加时区配置 <code>serverTimezone=UTC</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">$&#123;MYSQL_USER:root&#125;</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">$&#123;MYSQL_PASSWORD:123456&#125;</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:$&#123;MYSQL_PORT:3306&#125;/$&#123;MYSQL_DATABASE:dbname&#125;?serverTimezone=UTC&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料：</p>
]]></content>
      <categories>
        <category>framework,Springboot</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>framework</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/08/17/java/beforeArchitect/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC初识"><a href="#SpringMVC初识" class="headerlink" title="SpringMVC初识"></a>SpringMVC初识</h1><h2 id="什么是MVC？"><a href="#什么是MVC？" class="headerlink" title="什么是MVC？"></a>什么是MVC？</h2><p><code>MVC</code>是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。将业务逻辑、数据、显示分离方法来组织代码。MVC主要作用是降低了视图与业务逻辑间的双向耦合。是一种<strong>架构模式</strong></p>
<p><code>Model</code>(模型): 数据模型。提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都是分离开来： Value Object（数据DAO） 和服务层（行为Service），也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><code>View</code>(视图)： 负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西</p>
<p><code>Controller</code>（控制器）： 接收用户请求、委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。控制器做了个调度员的工作</p>
<p><strong>最典型MVC: JSP + Servlet + JavaBean</strong></p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是Spring框架的一个模块</p>
<p>SpringMVC运行流程：</p>
]]></content>
      <categories>
        <category>framework,SpringMVC</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>framework</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识</title>
    <url>/2020/08/10/java/beforeArchitect/networkBase/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>什么是服务器？</p>
<p>服务器又称伺服器，只要是一台功能、性能差不多的电脑就能作为服务器。</p>
<p>服务器的主要作用是提供数据来源</p>
<p>Apache服务器： 世界排名第一的Web服务器软件</p>
<p>Nginx服务器： 高性能Http和反向代理web服务器</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>域名解析： 目的是让服务器认识域名，让域名也认识服务器</p>
<h2 id="超文本传输协议-HTTP协议"><a href="#超文本传输协议-HTTP协议" class="headerlink" title="超文本传输协议(HTTP协议)"></a>超文本传输协议(HTTP协议)</h2><h3 id="认知HTTP协议"><a href="#认知HTTP协议" class="headerlink" title="认知HTTP协议"></a>认知HTTP协议</h3><p>在网络请求别人网站的时候，地址(URL)必须以HTTP或HTTPs开头</p>
<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ol>
<li><p>当用户在浏览器地址栏中输入网址(URL)后按回车后到底发生了什么？</p>
<p> 用户输入地址按回车 –&gt; 浏览器向服务器端发起一次<strong>上行请求</strong> –&gt; 服务器收到上行请求做出<strong>下行响应</strong> –&gt; 浏览器拿到下行响应渲染页面</p>
</li>
<li><p>HTTP与HTTP有何异同</p>
<p> 相同点： 都是超文本传输协议，但是HTTPS相对更安全一点</p>
</li>
</ol>
<ol start="3">
<li><p>一个网址的URL是由什么组成的</p>
<ul>
<li><p><code>http</code>: 超文本传输协议</p>
</li>
<li><p><code>www</code>: 别名</p>
</li>
<li><p><code>taobao</code>: 域名</p>
</li>
<li><p><code>.com</code>: 域名尾缀</p>
</li>
</ul>
<p>常用的域名尾缀</p>
<p> | 域名尾缀 | 描述 |<br> | – | — |<br> | .cn | 中国国家顶级域名 |<br> | .gov | 政府机构域名尾缀 |<br> | .com | 盈利商业组织（公司） |<br> | .me | 前南斯拉夫地区西南部的国家黑山共和国的国家域名 (饿了么网站使用的域名尾缀就是.me)</p>
<ul>
<li><p><code>:8080</code> :端口号,范围（0~65535）</p>
<p>  服务器默认端口8080</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>network,basic</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>basic</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2019/05/12/java/javase/</url>
    <content><![CDATA[<h1 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h1><p>面向对象</p>
<p>函数式编程 </p>
<p>JVM： Java Virtual Machine</p>
<p>虚拟的用于执行bytecode字节码的计算机</p>
<p>JDK： Java Development Kit</p>
<p>JRE: Java Runtime Environment</p>
<h2 id="安装与配置环境变量"><a href="#安装与配置环境变量" class="headerlink" title="安装与配置环境变量"></a>安装与配置环境变量</h2><ul>
<li><p>安装包地址 </p>
<p>  链接：<a href="https://pan.baidu.com/s/19j-EKoXEQP_BnWTcu1fmiw" target="_blank" rel="noopener">https://pan.baidu.com/s/19j-EKoXEQP_BnWTcu1fmiw</a></p>
<p>  提取码：9ys5</p>
</li>
<li><p>JDK12安装完成后不再自动生成<code>jre</code>文件夹，需要在JDK12安装目录下自行运行命令生成</p>
<p>  命令行输入： <code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code></p>
</li>
<li><p>JDK 9版本之前类和资源文件存储在<code>lib/rt.jar</code>、<code>tools.jar</code>中，JDK 9版本开始 <code>lib/dt.jar</code> 和其他各种内部JAR文件都存储在一个更有效的格式在实现特定的文件lib目录。<br>因此<code>CLASS PATH</code>变量中不再需要配置<code>lib/rt.jar</code>、<code>tools.jar</code></p>
</li>
</ul>
<h1 id="网络编程-IP、TCP、UDP"><a href="#网络编程-IP、TCP、UDP" class="headerlink" title="网络编程-IP、TCP、UDP"></a>网络编程-IP、TCP、UDP</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>网络： 一组相互连接的计算机</p>
<ul>
<li><p>多台计算机组成</p>
</li>
<li><p>使用物理线路进行连接</p>
</li>
</ul>
<h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><ul>
<li><p>IP地址： 唯一标识网络上的每一台计算机</p>
<p>  两台计算机之间通信的必备要素</p>
</li>
<li><p>端口号： 计算机中应用的标号（代表一个应用程序）</p>
<p>  0-1024系统使用或保留端口</p>
<p>  有效端口0-65536</p>
</li>
<li><p>通信协议： 通信的规则</p>
<p>  TCP，UDP</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul>
<li><p>OSI参考模式： 开放系统互连参考模型（Open System Interconnect）</p>
</li>
<li><p>TCP/IP参考模型： 传输控制/网际协议 (Transfer Control Protocol/Internet Protocol)</p>
</li>
</ul>
<p>OSI为逻辑上的参考模式，常用还是TCP/IP</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>32位，由4个8位二进制数组成</p>
<p>表示方法： 点分十进制</p>
<p>IP地址 = 网络ID + 主机ID</p>
<ul>
<li><p>网络ID: 标识计算机或网络设备所在的网段</p>
</li>
<li><p>主机ID：标识特定主机或网络设备</p>
</li>
</ul>
<h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><ul>
<li><p>地址类用于指定网络ID并在网络ID和主机ID之间提供分隔方法</p>
</li>
<li><p>IANA负责分配A，B， C类网络地址，具体主机地址由机构组织自行分配</p>
</li>
<li><p>IP地址包括A、B、C、D、E类</p>
<p>A类地址供军方使用，范围： 1.0.0.0~126.0.0.0 </p>
<p>B类地址供普通用户使用，范围： 128.0.0.0~1191.255.255.255</p>
<p>C类地址供普通用户使用，范围： 192.0.0.0~223.255.255.255</p>
<p>D类地址供广播地址或一些通用服务地址使用，范围： 224.0.0.0~239.255.255.255</p>
<p>E类地址范围： 240.0.0.0~247.255.255.255</p>
</li>
</ul>
</li>
</ul>
<h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ul>
<li><p><code>0.0.0.0</code>: 本机,阻断与外网通信</p>
</li>
<li><p><code>127.0.0.1</code>: 本机回环地址(Local Loopback)，用于本机测试</p>
</li>
<li><p><code>255.255.255.255</code>: 当前子网，一般用于向当前子网广播信息</p>
</li>
</ul>
<h4 id="IP地址对应的对象"><a href="#IP地址对应的对象" class="headerlink" title="IP地址对应的对象"></a>IP地址对应的对象</h4><p>类<code>InetAddress</code></p>
<ul>
<li><code>getLocalHost()</code>: 获取本机主机名+IP地址</li>
</ul>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口是一个虚拟的概念，通过端口可以在一个主机上运行多个网络应用程序</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><ul>
<li><p>TCP</p>
<p>  相当于打电话，需要建立连接，效率比较低，数据传输安全。</p>
<p>  三次握手协议完成。</p>
</li>
<li><p>UDP</p>
<p>  相当于发短信(有字数限制)，不需要建立连接，数据包的大小限制在64k内，效率高，不安全，容易丢包</p>
</li>
</ul>
<h4 id="三次握手协议和四次分手协议"><a href="#三次握手协议和四次分手协议" class="headerlink" title="三次握手协议和四次分手协议"></a>三次握手协议和四次分手协议</h4><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul>
<li>网络上的两个程序</li>
</ul>
<h4 id="基于TCP协议的Socket编程"><a href="#基于TCP协议的Socket编程" class="headerlink" title="基于TCP协议的Socket编程"></a>基于TCP协议的Socket编程</h4><ol>
<li><p>创建客户端</p>
<p> new一个socket对象，开启实现IO的虚拟接口，发送数据</p>
</li>
<li><p>创建服务端</p>
<ul>
<li><p>new一个serverSocket对象，开放端口</p>
</li>
<li><p>创建服务端的一个搜socket对象</p>
</li>
</ul>
</li>
</ol>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP传输方式和TCP不同，UDP传输的是数据包</p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JDK8中最重要的新功能之一。使用lambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，使代码看起来简单易懂。</p>
<p>Lambda表达式同时还提升了对集合、框架的迭代、遍历、过滤数据的操作</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>函数式编程</p>
</li>
<li><p>参数类型自动推断</p>
</li>
<li><p>代码量少，简洁</p>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>任何有<strong>函数式接口</strong>的地方</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>只有一个抽象方法(Object类中的方法除外)的接口是函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">()-&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>java提供了一系列的函数式接口，用于接收后续传入的参数，但是对输入和输出类型有要求</p>
<h2 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h2><p>方法引用是用来直接访问类或实例的已经存在的方法或者构造方法，方法引用提供了一种引用而不执行方法的方式，如果抽象方法的实现恰好可以使用调用另外一个方法来实现，就有可能可以使用方法引用。</p>
<h3 id="方法引用的分类"><a href="#方法引用的分类" class="headerlink" title="方法引用的分类"></a>方法引用的分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应的Lambda表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态方法引用</td>
<td>类名::staticMethod</td>
<td>(args) -&gt; 类名.staticMethod(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>inst::instMethod</td>
<td>(args) -&gt; inst.instMethod(args)</td>
</tr>
<tr>
<td>对象方法引用</td>
<td>类名::instMethod</td>
<td>(inst.args) -&gt; 类名.instMethod(args)</td>
</tr>
<tr>
<td>构造方法引用</td>
<td>类名::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
</tbody>
</table>
<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>Stream是一组用来处理数组、集合的API</p>
<p>JDK8引入函数式编程原因： </p>
<ul>
<li><p>代码简洁且意图明确，使用Stream接口让你从此告别for村换</p>
</li>
<li><p>多核友好</p>
</li>
</ul>
<h2 id="Stream特性"><a href="#Stream特性" class="headerlink" title="Stream特性"></a>Stream特性</h2><ul>
<li><p>不是数据结构，没有内部储存</p>
</li>
<li><p>不支持索引访问</p>
</li>
<li><p>延迟计算</p>
</li>
<li><p>支持并行</p>
</li>
<li><p>很容易生成数组或集合(List, Set)</p>
</li>
<li><p>支持过滤、查找、转换、汇总、聚合等操作</p>
</li>
</ul>
<h2 id="Stream运行机制"><a href="#Stream运行机制" class="headerlink" title="Stream运行机制"></a>Stream运行机制</h2><p>Stream分为源source，中间操作，终止操作</p>
<p>流的源可以是一个数组、一个集合、一个生成器方法、一个I/O通道等等</p>
<p>一个留可以有零个和或者多个中间操作，每一个中间操作都会返回一个新的流供下一个操作使用。</p>
<p>一个流只会有一个终止操作。</p>
<p>Stream只有遇到终止操作，它的源才开始执行遍历操作</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><h3 id="三元运算符与if语句"><a href="#三元运算符与if语句" class="headerlink" title="三元运算符与if语句"></a>三元运算符与if语句</h3><p>三元运算符能实现的都可采用if语句实现，反之不成立。因为三元运算符不能执行输出语句。<br>若只需赋值，可用三元运算符简化代码。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><h3 id="switch表达式可接收类型"><a href="#switch表达式可接收类型" class="headerlink" title="switch表达式可接收类型"></a>switch表达式可接收类型</h3><ol>
<li>基本数据类型可以接收byte,short,char,int</li>
<li>引用数据类型可以接收枚举(JDK1.5) String类型(JDK1.7)</li>
</ol>
<h3 id="swith语句注意事项"><a href="#swith语句注意事项" class="headerlink" title="swith语句注意事项"></a>swith语句注意事项</h3><ul>
<li>case后面只能是常量，不能是变量。多个case的值不能相同</li>
<li>每个case后面都要加break，否则会出现case穿透</li>
<li>default可以放在任何位置，但建议放最后</li>
</ul>
<h2 id="if语句和switch语句的各自使用场景"><a href="#if语句和switch语句的各自使用场景" class="headerlink" title="if语句和switch语句的各自使用场景"></a>if语句和switch语句的各自使用场景</h2><p>switch在判断固定值时使用，if建议判断区间和范围时使用</p>
<h2 id="for语句、while语句和do-while语句"><a href="#for语句、while语句和do-while语句" class="headerlink" title="for语句、while语句和do while语句"></a>for语句、while语句和do while语句</h2><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><ul>
<li>do while 先执行循环体再判断，至少会执行一次循环体</li>
<li>for语句执行后，变量会被释放，不能再使用；while执行后，初始化变量还能继续使用</li>
</ul>
<p>如果想在循环结束后继续使用控制条件的变量，用while语句，否则尽量用for循环，以提高内存的使用效率</p>
<h3 id="无限循环语句"><a href="#无限循环语句" class="headerlink" title="无限循环语句"></a>无限循环语句</h3><p>while语句无限循环：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  System.out.println(<span class="string">"This is a loop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for语句的无限循环:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ;) &#123;</span><br><span class="line">  System.out.println(<span class="string">"This is a loop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p><code>\x</code> x表示任意，\是转义符号，这种做法叫转义字符</p>
<ul>
<li><code>\t</code> 表示tab键(制表符)</li>
<li><code>\r</code> 表示回车</li>
<li><code>\n</code> 表示换行</li>
<li><code>\&quot;</code> 表示转义双引号</li>
<li><code>\&#39;</code> 表示转义单引号</li>
</ul>
<h2 id="方法的概述和格式说明"><a href="#方法的概述和格式说明" class="headerlink" title="方法的概述和格式说明"></a>方法的概述和格式说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型2 参数名2...) &#123;</span></span><br><span class="line"><span class="comment">*    方法体语句</span></span><br><span class="line"><span class="comment">*    return 返回值;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="方法的注意事项"><a href="#方法的注意事项" class="headerlink" title="方法的注意事项"></a>方法的注意事项</h3><ul>
<li>方法不调用不执行</li>
<li>方法与方法是平级关系，不能嵌套定义</li>
<li>方法定义的时候参数之间用逗号隔开</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>重载： 方法名相同，参数列表不同，与返回值类型无关<br>重载的分类： </p>
<ul>
<li>参数的个数不同</li>
<li>参数的类型不同</li>
<li>参数的顺序不同</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>同时存储同一种数据类型多个元素的集合，既可存储基本数据类型，也可存储引用数据类型。</p>
<p>格式： <code>数据类型[] 数组名 = new 数据类型[数组的长度]</code></p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p><code>数据类型[] 数组名 = new 数据类型[数组的长度]</code></p>
<p>e.g: int[] arr = new int[5]</p>
<p>相当于在内存中开辟5个连续的储存空间</p>
<h3 id="java中的内存分配以及栈和堆的区别"><a href="#java中的内存分配以及栈和堆的区别" class="headerlink" title="java中的内存分配以及栈和堆的区别"></a>java中的内存分配以及栈和堆的区别</h3><p>栈： 存储局部变量(定义在方法声明上和方法中的变量)，每个方法是一个栈针形式<br>堆： 存储new出来的数组或对象<br>方法区：<br>本地方法区： 和系统相关<br>寄存器: 给CPU用</p>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>格式： <code>数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, ...}</code><br>简化格式： <code>数据类型[] 数组名 = {元素1, 元素2, ...}</code></p>
<p>简化格式的声明和赋值只能在同一行，否则编译不通过。  </p>
<h3 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h3><p>基本数据类型的值传递，不改变原值，因为调用后会弹栈，局部变量随之消失<br>引用数据类型的值传递，改变原值，因为即使方法弹栈，但是堆内存数组对象还在，可以通过地址继续访问</p>
<p>java中只有传值，因为地址值也是值</p>
<h2 id="构造方法、static关键字-day-07"><a href="#构造方法、static关键字-day-07" class="headerlink" title="构造方法、static关键字 (day 07)"></a>构造方法、static关键字 (day 07)</h2><h3 id="构造方法特点"><a href="#构造方法特点" class="headerlink" title="构造方法特点"></a>构造方法特点</h3><ul>
<li>方法名和类名相同</li>
<li>没有返回值类型，连void也没有</li>
<li>没有具体的返回值，直接return</li>
<li>若无构造方法，系统会自动提供一个无参的构造方法</li>
<li><p>若有有参构造方法，则必须自己写一个无参的构造方法</p>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><ol>
<li>Student.class加载进内存</li>
<li>声明一个Student类型引用s</li>
<li>在堆内存创建对象</li>
<li>给对象中属性默认初始化值</li>
<li>属性进行显示初始化</li>
<li>构造方法进栈，对对象中的属性赋值，构造方法弹栈</li>
<li>将对象的地址赋值给s</li>
</ol>
<p><img src="/data/img/javase/创建对象的步骤.jpg" alt="创建对象步骤图解"></p>
<h3 id="static关键字及内存图-day07-07-09"><a href="#static关键字及内存图-day07-07-09" class="headerlink" title="static关键字及内存图(day07 07.09)"></a>static关键字及内存图(day07 07.09)</h3><p><img src="/data/img/javase/static内存图.png" alt="static内存图"></p>
<h4 id="static关键字的特点"><a href="#static关键字的特点" class="headerlink" title="static关键字的特点"></a>static关键字的特点</h4><ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>被类的所有对象共享<br>当某个成员变量是被所有对象所共享，那么它就应该送一位静态的</li>
<li>可以通过类名调用，推荐使用类名调用；静态修饰的内容，一般我们称其为与类相关的，类成员</li>
</ul>
<h4 id="static的注意事项"><a href="#static的注意事项" class="headerlink" title="static的注意事项"></a>static的注意事项</h4><p>a. 在静态方法中是没有this关键字的，因为静态是随着累的加载而加载，优先于对象的存在，而this是随着对象的创建而存在的<br>b. 静态方法只能访问静态的成员变量和静态的成员方法</p>
</li>
</ul>
<h4 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h4><p>a. 所属不同</p>
<pre><code>* 静态变量属于类，所以也称为类变量
* 成员变量属于对象，所以也称为实例变量(对象变量)
</code></pre><p>b. 内存中的位置不同</p>
<pre><code>* 静态变量存储于方法区的静态区
* 成员变量存储于堆内存
</code></pre><p>c. 内存出现时间不同</p>
<pre><code>* 静态变量随着类的加载而加载，随着类的消失而消失
* 成员变量随着对象的创建而存在，随着对象的消失而消失
</code></pre><p>d. 调用不同</p>
<pre><code>* 静态变量可以通过类名调用，也可以通过对象调用
* 成员变量只能通过对象名调用
</code></pre><h3 id="main方法的格式和详细解释"><a href="#main方法的格式和详细解释" class="headerlink" title="main方法的格式和详细解释"></a>main方法的格式和详细解释</h3><p>public : 被jvm调用，所以需要权限足够大<br>static : 被jvm调用，不需要创建对象，直接类名.调用即可<br>void : 被jvm调用，不需要有任何的返回值<br>main : 只有这样写才能被jvm识别，main不是关键字<br>String[] args : 以前用来接收启动时的键盘录入，现在用System.Scanner(System.in)来接收键盘录入</p>
<p> <img src="/data/img/javase/main方法String[].jpg" alt="main方法String[]"></p>
<h3 id="工具类中使用静态"><a href="#工具类中使用静态" class="headerlink" title="工具类中使用静态"></a>工具类中使用静态</h3><p>工具类中使用静态方法，可不用创建对象直接调用；若一个类中所有的方法都为静态方法，则需要将构造方法私有化，目的是不让其他类创建本类，直接用类名.方法调用即可</p>
<h3 id="说明书的制作过程"><a href="#说明书的制作过程" class="headerlink" title="说明书的制作过程"></a>说明书的制作过程</h3><ol>
<li>使用多行注释在类和方法中进行注释，写明版本、作者、参数、返回值等信息</li>
<li>对需要生成api的文件进行javadoc命令</li>
</ol>
<p><img src="/data/img/javase/generateApi.png" alt="生成说明文档"></p>
<p><code>javadoc -d api -version -author ArrayTools.java</code></p>
<ul>
<li><code>javadoc</code> 生成文档命令</li>
<li><code>-d api</code> 文件生成保存路径</li>
<li><code>-version</code> 版本</li>
<li><code>-author</code> 作者</li>
<li><p><code>ArrayTools.java</code> 源文件类的名字</p>
<p>文件生成后，直接打开<code>index.html</code>既可</p>
</li>
</ul>
<h2 id="代码块、继承、方法重写、final关键字-day-08"><a href="#代码块、继承、方法重写、final关键字-day-08" class="headerlink" title="代码块、继承、方法重写、final关键字(day 08)"></a>代码块、继承、方法重写、final关键字(day 08)</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>java中使用<code>{}</code>括起来的代码称为代码块，分为局部代码块、构造代码块、静态代码块、同步代码块</p>
<ul>
<li>局部代码块： 在方法中出现，限定变量的生命周期，及早释放，提高内存效率</li>
<li>构造代码块(初始化代码块)：在类中方法外出现；多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
<li>静态代码块： 在类中方法外出现，加了static修饰；用于给类进行初始化，在加载时执行，并且只执行一次，一般用于加载驱动</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>关键字： extends<br>让类与类之间产生关系，子父类关系<br>好处： </p>
<ul>
<li>提高代码的复用性</li>
<li>提高了代码的维护性</li>
<li>让类与类之间产生了关系，是多态的前提<br>弊端：<ul>
<li>增强类的耦合性</li>
</ul>
</li>
</ul>
<p>开发的原则： 高内聚，低耦合</p>
<ul>
<li>耦合是指类与类的关系</li>
<li><p>内聚是指自己完成某件事情的能力</p>
<h4 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h4><p>java只支持单继承不支持多继承，但支持多层继承(B extends A, C extends B)</p>
<h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4></li>
<li>子类只能继承父类所有非私有成员(成员方法和成员变量)</li>
<li>子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法</li>
<li><p>不要为了部分功能而去继承</p>
<h4 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h4><p><code>this.成员变量</code> ：既可以调用本类的成员变量，也可调用父类成员变量(本类无成员变量)<br><code>super.成员变量</code> : 调用父类成员变量</p>
<h4 id="继承中构造方法的关系"><a href="#继承中构造方法的关系" class="headerlink" title="继承中构造方法的关系"></a>继承中构造方法的关系</h4><p>子类中所有的构造方法默认都会访问父类中空参数的构造方法。<br>每一个构造方法的第一条语句默认都是 super() Object类最顶层的父类</p>
<h4 id="继承中构造方法的注意事项"><a href="#继承中构造方法的注意事项" class="headerlink" title="继承中构造方法的注意事项"></a>继承中构造方法的注意事项</h4><p>父类没有无参构造方法，子类只能通过super或者this来访问父类的有参构造方式。super和this不能共用，因为两者都必须放在构造器中的第一个语句。</p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>子父类出现了一模一样的方法<br>子类可以重写父类中的方法，这样既沿袭了父类的功能，又定义了自己特有的功能</p>
<h4 id="方法重写的注意事项"><a href="#方法重写的注意事项" class="headerlink" title="方法重写的注意事项"></a>方法重写的注意事项</h4></li>
</ul>
<ol>
<li>父类的思想方法不能被重写</li>
<li>子类重写父类方法时，访问权限不能更低</li>
<li>父类静态方法，子类也必须通过静态方法重写(静态方法只能覆盖静态方法)</li>
</ol>
<h4 id="方法的重载-overload-和重写-overload"><a href="#方法的重载-overload-和重写-overload" class="headerlink" title="方法的重载(overload)和重写(overload)"></a>方法的重载(overload)和重写(overload)</h4><p>方法重写： 子父类出现一模一样的方法，与返回值类型有关，返回值是一致的<br>方法重载： 在本类中出现的方法名一样，参数列表不同，与返回值无关</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>修饰类，类不能被继承</li>
<li>修饰变量， 变量变为常量，只能被赋值一次</li>
<li>修饰方法， 方法不能被重写 </li>
</ul>
<p>final修饰基本数据类型，值不能被改变；<br>final修饰引用数据类型，地址值不能被改变，但对象中的属性可以改变。</p>
<p>成员变量的从默认初始化值是无效值，因此final修饰的成员变量初始化时需要赋值或者利用构造方法初始化。</p>
<h2 id="多态、抽象类"><a href="#多态、抽象类" class="headerlink" title="多态、抽象类"></a>多态、抽象类</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的前提"><a href="#多态的前提" class="headerlink" title="多态的前提"></a>多态的前提</h4><ol>
<li>要有继承关系</li>
<li>要有方法重写</li>
<li>要有父类引用指向子类方法</li>
</ol>
<h4 id="多态中的成员访问特点"><a href="#多态中的成员访问特点" class="headerlink" title="多态中的成员访问特点"></a>多态中的成员访问特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>编译看左边(父类)，运行看左边(父类)</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>编译看左边(父类)，运行看右边(子类)  (动态绑定)</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>编译看左边(父类)，运行看左边(父类)</p>
<h4 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h4><p>引用数据类型会先向上转型，才能向下转型。</p>
<h4 id="好处和弊端"><a href="#好处和弊端" class="headerlink" title="好处和弊端"></a>好处和弊端</h4><p>好处：</p>
<ul>
<li>提高代码的可维护性</li>
<li>提高代码的扩展性</li>
</ul>
<p>弊端：</p>
<ul>
<li>不能使用子类的特有属性和行为<br>多态一般用于当做参数，因为其拓展性强</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>关键字abstract修饰</p>
<ul>
<li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或接口</li>
<li>抽象类不能实例化，只能通过子类实例化</li>
<li>抽象的子类只能是抽象类或重写抽象类的所有方法</li>
</ul>
<h4 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h4><ul>
<li>成员变量既可以是变量也可以是常量。</li>
<li>有构造方法，便于子类访问父类数据的初始化</li>
<li>成员方法，既可以是抽象也可以是非抽象(非抽象需要重写父类所有方法)</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol>
<li>一个抽象类如果没有抽象方法，可以定义为抽象类，这样做是为了不让其他类创建本类的对象，只能通过此抽象的子类实例化</li>
<li><p>abstract不能和那些关键字共存</p>
<ul>
<li><p><code>static</code></p>
<p>被<code>abstract</code>修饰的方法没有方法体，被<code>static</code>修饰的可以用类名.调用，调用抽象方法是没有意义的</p>
</li>
<li><p><code>final</code></p>
<p>被<code>abstract</code>修饰的方法强制子类重写，被<code>final</code>修饰的不让子类重写</p>
</li>
<li><p><code>private</code></p>
<p>被<code>abstract</code>修饰的是为了让子类看到并强制重写，被<code>private</code>修饰不让子类访问</p>
</li>
</ul>
</li>
</ol>
<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><ol>
<li>使用关键字<code>interface</code>表示，接口中的方法都是抽象的。</li>
<li>类实现接口用<code>implement</code>表示： <code>class 类名 implement 接口名 {}</code></li>
<li>接口不能实例化</li>
<li>接口的子类可以是抽象类，也可以是具体类，但是具体类需要重写接口中的所有抽象方法</li>
</ol>
<h4 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h4><ol>
<li>成员变量: 只能是常量，并且是静态、公共的，默认修饰符: <code>public static final</code>,建议手动给出</li>
<li>构造方法： 接口没有构造方法</li>
<li>成员方法： 只能是抽象方法，默认修饰符： <code>public abstract</code>，建议手动给出</li>
</ol>
<h3 id="类与类、类与接口、接口与接口的关系"><a href="#类与类、类与接口、接口与接口的关系" class="headerlink" title="类与类、类与接口、接口与接口的关系"></a>类与类、类与接口、接口与接口的关系</h3><p>类与类： 继承关系，只能是单继承，可以多层继承<br>类与接口： 实现关系，可以单实现，也可以多实现并且能在继承一个类的同时实现多个接口<br>接口与接口： 继承关系，可以是单继承，也可以是多继承</p>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>成员区别： </p>
<ul>
<li>成员变量： 抽象类的可以是变量，也可以是常量；接口的只能是常量</li>
<li>构造方法： 抽象类有构造方法，接口无</li>
<li>成员方法： 抽象类的可以是抽象方法，也可以是非抽象；接口的只可以是抽象</li>
</ul>
<p>设计理念区别：</p>
<ul>
<li>抽象类被继承，体现的是<code>is a</code>的关系，抽象类定义的是该继承体系的共性功能</li>
<li>接口，被实现的是<code>like a</code>的关系，接口中定义的是该继承体系的扩展功能</li>
</ul>
<h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><p><code>public</code>、<code>defalut</code>、 <code>protected</code>、 <code>private</code></p>
<ul>
<li><code>private</code> 只能在本类中访问</li>
<li><code>default</code> 默认不写，能在本类和同包下访问</li>
<li><code>protected</code>在不同包下的无关类无法访问</li>
<li><code>public</code> 均能访问</li>
</ul>
<p>状态修饰符： <code>static</code>、 <code>final</code></p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>方法中的内部类；<br>局部内部类访问局部变量，局部变量需要用final修饰。(JDK 1.8中取消了此事)</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类只针对重写一个方法的时候使用。匿名内部类当做参数传递，本职是把匿名内部类看做一个对象。<br>链式编程，调用方法后还能继续调用方法，证明调用方法后返回的是一个对象</p>
<h2 id="eclipse、Object类"><a href="#eclipse、Object类" class="headerlink" title="eclipse、Object类"></a>eclipse、Object类</h2><h3 id="eclipse快捷键"><a href="#eclipse快捷键" class="headerlink" title="eclipse快捷键"></a>eclipse快捷键</h3><p><code>alt + /</code> 提示代码<br><code>ctrl + n</code> 新建<br><code>ctrl + shift +f</code> 格式化<br><code>ctrl + shif +o</code> 整理包<br><code>ctrl + /</code>单行注释<br><code>ctrl+shift+/</code> 多行注释<br><code>ctrl + shift +\</code><br><code>alt + 上下箭头</code> 上下移动代码<br><code>F3</code>或按住<code>ctrl</code>点击类名可以查看源码<br><code>ctrl + shift + t</code> 查找具体的类<br><code>ctrl + o</code>查找具体类的具体方法<br><code>ctrl + d</code> 删除代码<br><code>ctrl + shift + m</code> 抽取方法<br><code>alt + shift + r</code> 改名<br><code>alt + shift + s</code> 快速生成getter、setter等方法<br><code>ctrl + alt + 上下键</code> 向上/下复制一行代码</p>
<h3 id="打jar包"><a href="#打jar包" class="headerlink" title="打jar包"></a>打jar包</h3><p>选中项目–&gt;右键–&gt;Export–&gt;java–&gt;Jar–&gt;指定路径和名称–&gt;finish</p>
<h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>选中jar包–&gt;右键–&gt;build path</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ol>
<li><p>hashcode()方法： 返回对象的地址值。</p>
</li>
<li><p>getClass()方法： 返回对象的class文件。</p>
</li>
<li><p>toString()方法： 更方便的显示属性值。如果直接打印对象的引用，会默认调用toString方法。</p>
</li>
<li><p>equals方法： 判断两个对象是否相等(比较的是地址值)，返回布尔值。Object的equals方法比较的是地址值，因此开发中没什么意义，一般都要重写此方法，重写后一般比较的是对象中的属性值。</p>
</li>
</ol>
<h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="== 和equals的区别"></a>== 和equals的区别</h3><p>共同点： 都可以做比较，返回值都是布尔值<br>区别：</p>
<ol>
<li><p><code>==</code>是比较运算符，即可以比较基本数据类型，也可以比较引用数据类型。基本数据类型比较的是值，引用数据类型比较的是地址值</p>
</li>
<li><p>equals方法只能比较引用数据类型，equals方法在没重写之前比较的是地址值，底层依赖的是==号，但是比较地址值是没有意义的，需要重写equals方法比较对象中的属性值</p>
</li>
</ol>
<h2 id="Scanner、String-类-day-12"><a href="#Scanner、String-类-day-12" class="headerlink" title="Scanner、String 类(day 12)"></a>Scanner、String 类(day 12)</h2><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><p>一般方法：<br>hasNextXXX() 判断是否有下一个输入项，XXX可以是Int double等<br>nextXxx() 获取下一个输入项，nextLine()用于获取一个String类型的值</p>
<p>nextLine()遇到键盘输入的/r/n时会自动停止，获取键盘输入自动会有/r/n</p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>字符串是常量，一旦被赋值就不能被改变</p>
<h4 id="常见构造方法"><a href="#常见构造方法" class="headerlink" title="常见构造方法"></a>常见构造方法</h4><ol>
<li>空构造 String()</li>
<li>把字节数组转成字符串 String(byte[] bytes)</li>
<li>把字节数组的一部分转成字符串 Sting(byte[] bytes, int index, int length)</li>
<li>把字符数组转成字符串 String(char[] value)</li>
<li>把字符数组的一部分转成字符串 String(char[] value, int index, int length)</li>
<li>把字符串常量值转成字符串 String(String original)</li>
</ol>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><p>常量池中若无某字符串对象，则创建一个，如有则直接使用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 记录的是堆里面的地址值</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;<span class="comment">// 记录的是常量池里的地址值</span></span><br><span class="line">s1 == s2;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="String类的判断功能"><a href="#String类的判断功能" class="headerlink" title="String类的判断功能"></a>String类的判断功能</h4><ol>
<li>比较字符串的内容是否相同，区分大小写: equals(Object obj)</li>
<li>比较字符串的内容是否相同，忽略大小写: equalsIgnoreCase(String str)</li>
<li>判断大字符串是否包含小字符串: contains(String str)</li>
<li>判断字符串是否以某个指定的字符串开头: startsWith(String str)</li>
<li>判断字符串是否以某个指定的字符串结尾: endsWith(String str)</li>
<li>判断是否为空: isEmpty()</li>
</ol>
<h4 id="String类的获取功能"><a href="#String类的获取功能" class="headerlink" title="String类的获取功能"></a>String类的获取功能</h4><ol>
<li>获取字符串的长度: int length();</li>
<li>获取指定索引位置的字符: char charAt(int index)</li>
<li>返回指定字符在此字符串中第一次出现处的索引: int indexOf(int ch)</li>
<li>返回指定字符串在此字符串中第一次出现处的索引: int indexOf(String str)</li>
<li>返回指定字符在此字符串中从指定位置后第一次出现处的索引: int indexOf(int ch, int fromIndex)</li>
<li>返回指定字符串在此字符串中从指定位置后第一次出现处的索引: int indexOf(String str, int fromIndex)</li>
<li>从后向前找，第一次出现指定字符的索引: lastIndexOf</li>
<li>从指定位置开始截取字符串，默认到末尾 String substring(int start) (substring会产生新的字符串)</li>
<li>从指定位置开始到指定位置结束截取字符串 String substring(int start, int end)</li>
</ol>
<h4 id="String类的转换功能"><a href="#String类的转换功能" class="headerlink" title="String类的转换功能"></a>String类的转换功能</h4><p>valueOf(Object obj); 将对象转为String<br>toLowerCase(): 把字符串转小写(返回新的字符串)<br>toUpperCase(): 把字符串转成大写(返回新的字符串)<br>concat(String str): 把字符串拼接</p>
<h1 id="StringBuffer-amp-数组排序-Day13"><a href="#StringBuffer-amp-数组排序-Day13" class="headerlink" title="StringBuffer &amp; 数组排序 (Day13)"></a>StringBuffer &amp; 数组排序 (Day13)</h1><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>无参构造方法 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.length();<span class="comment">// 0,容器中字符的个数，实际值</span></span><br><span class="line">sb.capacity();<span class="comment">// 16,容器的初始容量，理论值</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指定容量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="number">10</span>);</span><br><span class="line">sb2.length();<span class="comment">// 0</span></span><br><span class="line">ab2.capacity();<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指定字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb3 = <span class="keyword">new</span> StringBuffer(<span class="string">"test"</span>);</span><br><span class="line">sb3.length();<span class="comment">// 5, 实际字符个数</span></span><br><span class="line">sb3.capacity();<span class="comment">// 20, 字符串的length + 初始容量</span></span><br></pre></td></tr></table></figure>
<h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><p>StringBuffer是字符串缓冲区，当new的时候，是在堆内存创建一个对象，底层是一个长度为16的字符数组，当调用添加方法时，不会再重新创建对象，在不断向原缓冲区添加字符;</p>
<p>StringBuffer类中重写了toString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以把任意类型数据添加到字符串缓冲区里面，并返回字符串返回区* 本身</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">StringBuffer sb2 = sb.append(<span class="keyword">true</span>);</span><br><span class="line">StringBuffer sb3 = sb.append(<span class="string">"test"</span>);</span><br><span class="line">StringBuffer sb4 = sb.append(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sb.toString());<span class="comment">// truetest100</span></span><br><span class="line">System.out.println(sb2.toString());<span class="comment">// truetest100</span></span><br><span class="line">System.out.println(sb3.toString());<span class="comment">// truetest100</span></span><br><span class="line">System.out.println(sb4.toString());<span class="comment">// truetest100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符* 串缓冲区本身</span></span><br><span class="line"><span class="comment">* 在指定位置添加元素，如果没有指定位置，则会报指针异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offser, String str)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><p>当缓冲区中无索引时，报字符串越界异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除指定位置的字符，并返回本身</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">sb,delete(<span class="number">0</span>, sb.length());<span class="comment">// 清空缓冲区</span></span><br></pre></td></tr></table></figure>
<h3 id="替换和反转"><a href="#替换和反转" class="headerlink" title="替换和反转"></a>替换和反转</h3><p>StringBuffer replace(int start, int end, String str);</p>
<p>StringBuffer reverse();</p>
<p>字符串的反转：</p>
<ol>
<li>将字符串转换成StringBuffer对象<br> StringBuffer sb = new StringBuffer(Str);</li>
<li>使用reverse()方法反转<br> sb.reverse();</li>
<li>将StringBuffer对象转换成String<br> sb.tostring();</li>
</ol>
<h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>String substring(int start);<br>String substring(int start, int end);</p>
<p>注： 截取返回值不再是StringBuffer本身，而是String</p>
<h3 id="StringBuffer和String的转换"><a href="#StringBuffer和String的转换" class="headerlink" title="StringBuffer和String的转换"></a>StringBuffer和String的转换</h3><ol>
<li>String转StringBuffer</li>
</ol>
<ul>
<li>通过构造方法<br>StringBuffer sb = new StringBuffer(“XXX”);</li>
<li>通过append()方法<br>StringBuffer sb2 = new StringBuffer();<br>sb2.append(“XXX”);</li>
</ul>
<ol start="2">
<li>StringBuffer转String</li>
</ol>
<ul>
<li>通过构造方法<br>StringBuffer sb = new StringBuffer(“XXX”);<br>String s1 = new String(sb);</li>
<li>通过toString()方法<br>String s2 = sb.toString();</li>
<li>通过substring截取<br>String s3 = sb.substring(0, sb.length());</li>
</ul>
<h3 id="String和StringBuffer作为参数传递"><a href="#String和StringBuffer作为参数传递" class="headerlink" title="String和StringBuffer作为参数传递"></a>String和StringBuffer作为参数传递</h3><p>基本数据类型的值传递，不改变其值；<br>引用数据类型的值传递，改变其值；<br>String类虽然是引用数据类型，但是它作为参数传递时和基本数据类型是一样的，一旦被初始化，就不会被改变</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuffer和StringBuilder类中的方法是一样的<br>StringBuffer是JDK1.0版本的，线程安全，效率低；<br>StringBuilder是JDK1.5版本的，线程不安全，效率高；<br>String是一个不可变的字符序列，StringBuffer和StringBuilder是可变的字符序列</p>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="数组转成字符串"><a href="#数组转成字符串" class="headerlink" title="数组转成字符串"></a>数组转成字符串</h3><p>遍历时用StringBuffer接收，减少创建对象次数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  sb.append(<span class="string">"["</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 若写成sb.append(arr[i] + ", "), 在运行+的命令时，会在底层创建StringBuffer对象 </span></span><br><span class="line">      sb.append(arr[i].append(<span class="string">"]"</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      sb.append(arr[i].append(<span class="string">", "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数组冒泡排序"><a href="#数组冒泡排序" class="headerlink" title="数组冒泡排序"></a>数组冒泡排序</h3><p>冒泡排序： 轻的上浮，沉的下降<br>原理： 两个相邻位置比较，如果前面的元素比后面的元素大，就换位置<br>代码思路： 使用嵌套循环，外层循环arr.length-1次，内循环arr.length-1-i次</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序： 用一个索引位置上的元素，依次与其他索引位置上的元素比较，小在前面，大在后面</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>前提： 数组有序<br>二分查找： 查找元素对应的索引</p>
<h3 id="Arrays类的概述和方法使用"><a href="#Arrays类的概述和方法使用" class="headerlink" title="Arrays类的概述和方法使用"></a>Arrays类的概述和方法使用</h3><ol>
<li>数组转字符串<br> Arrays.toString(arr);</li>
<li>数组排序<br> Arrays.sort(arr);</li>
<li>二分查找<br> Arrays.binarySearch(arr);// 此处的arr为已排序数组，若无所查值，返回负的插入点-1 </li>
</ol>
<h2 id="Integer和String类型的相互转换"><a href="#Integer和String类型的相互转换" class="headerlink" title="Integer和String类型的相互转换"></a>Integer和String类型的相互转换</h2><ol>
<li>int转String<ul>
<li>String.valueof</li>
<li>toString</li>
<li>int值+””</li>
<li>int转换为Integer类，再调用Integer.toString()</li>
</ul>
</li>
<li><p>String转int</p>
<ul>
<li>Integer.parseInt(str);// 推荐使用</li>
</ul>
<p>基本数据类型包装类有八种，其中七种都有parseXxx的方法，可以将这七种字符串表现形式转换成基本数据类型；char的包装类Character中没有parseXXX的方法</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>自动装箱： 把基本数据类型转换成对象<br>Integer i = 100;<br>自动拆箱： 把对象转换为基本数据类型<br>int z = i + 200;<br>注： Integer为null时，会出现空指针异常</p>
<h2 id="Integer类相关"><a href="#Integer类相关" class="headerlink" title="Integer类相关"></a>Integer类相关</h2><p>byte的取值范围为-128~127：</p>
<ul>
<li>若在此取值范围内，自动装箱不会新创建对象，而是从常量池中获取</li>
<li>若超过byte的取值范围，自动装箱会创建新对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">i1 == i2;<span class="comment">// true</span></span><br><span class="line">i1.equals(i2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="number">128</span>;</span><br><span class="line">Integer i4 = <span class="number">128</span>;</span><br><span class="line">i3 == i4;<span class="comment">// false</span></span><br><span class="line">i3.equals(i4);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="正则表达式-day-14"><a href="#正则表达式-day-14" class="headerlink" title="正则表达式(day 14)"></a>正则表达式(day 14)</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串</p>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul>
<li><code>[abc]</code>: []代表单个字符; 只能输入a、b或c</li>
<li><code>[^abc]</code>: 代表除a、b、c以外的所有单个字符</li>
<li><code>[a-zA-Z]</code>: a~z或A~Z,两头的字母包括在内</li>
<li><code>[a-d[m-p]]</code>: a到d或m到p: <code>[a-dm-p]</code> (并集)</li>
<li><code>[a-z&amp;&amp;[def]]</code>: d、e或f (交集)</li>
<li><code>[a-z&amp;&amp;[^bc]]</code>: a到z，除了b和c: <code>[ad-z]</code> (减去)</li>
<li><code>[a-z&amp;&amp;[^m-p]]</code>: a到z,而非m到p: <code>[a-lq-z]</code> (减去)</li>
</ul>
<h3 id="预定义字符"><a href="#预定义字符" class="headerlink" title="预定义字符"></a>预定义字符</h3><ul>
<li><code>.</code> : 任何字符,转义时需要写成<code>\\.</code></li>
<li><code>\d</code>: 数字：<code>[0-9]</code> (<code>\</code>代表转义字符，如果想表示\d的话，需要写成<code>\\d</code>)</li>
<li><code>\D</code>: 非数字： <code>[^0-9]</code></li>
<li><code>\s</code>: 空白字符： <code>[\t\n\x0B\f\r]</code></li>
<li><code>\S</code>: 非空白字符： <code>[^\s]</code></li>
<li><code>\w</code>: 单词字符: <code>[a-zA-Z_0-9]</code></li>
<li><code>\W</code>: 非单词字符: <code>[^\w]</code></li>
</ul>
<h3 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h3><ul>
<li><code>X?</code>: X一次或一次也没有(e.g.: <code>[abc]?</code> a、b、c出现1次或1次也没有)</li>
<li><code>X*</code>: X, 0次到多次</li>
<li><code>X+</code>: X, 1次或多次</li>
<li><code>X{n}</code>: X，恰好n次</li>
<li><code>X{n,}</code>: X, 至少n次</li>
<li><code>X{n,m}</code>: X, 至少n次，但是不超过m次</li>
</ul>
<h3 id="分割功能"><a href="#分割功能" class="headerlink" title="分割功能"></a>分割功能</h3><p>String.split(String regex);根据正则分割</p>
<h3 id="分组功能"><a href="#分组功能" class="headerlink" title="分组功能"></a>分组功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \\1代表第一组又出现一次，\\2代表第二组又出现一次 (.)表示一个任意字符为一组</span></span><br><span class="line">String regex = <span class="string">"(.)\\1(.)\\2"</span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"我我....我...我.要...要要...学....学学..学.编.编编..编...程.程..程程..."</span>;</span><br><span class="line"><span class="comment">// 将所有.替换成空:我我我我要要要学学学学编编编编程程程程</span></span><br><span class="line">String s1 = s.replaceAll(<span class="string">"\\.+"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// $1代表第一组中的内容，若有两个(),可以用$2</span></span><br><span class="line">String s2 = s1.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);<span class="comment">// 获取正则表达式</span></span><br><span class="line">Mather m = p.matcher(<span class="string">"aaaaab"</span>);<span class="comment">// 获取匹配器</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();<span class="comment">// 是否匹配，匹配为true</span></span><br><span class="line"><span class="comment">// 以上写法等同于： "aaaaab".matches("a*b")</span></span><br></pre></td></tr></table></figure>
<h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><ul>
<li>获取字符串中的手机号码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"我的手机号码是18988888888，曾用过18987654321，还用过18812345678"</span>;</span><br><span class="line">String regex = <span class="string">"1[3578]\\d&#123;9&#125;"</span>;<span class="comment">// 手机号码的正则表达式</span></span><br><span class="line">Pattern p = Pattern.compile(regex);<span class="comment">// 获取正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  m.find(),找到与正则相匹配的字符串</span></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">  <span class="comment">//  m.group(),获取匹配的字符串</span></span><br><span class="line">  System.out.println(m.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>成员方法:<br><code>abs(int a)</code> : 取绝对值<br><code>ceil(double)</code>: 向上取整，返回double<br><code>floor(double)</code>: 向下取整，返回double<br><code>max(int a, int b)</code>: 获取两者的最大值<br><code>pow(double a, double b)</code>: a为底数，b为指数<br><code>random()</code>: 生成[0.0, 1.0)的随机小数<br><code>round(float a)</code>: 四舍五入<br><code>sqrt(double a)</code>: 开平方</p>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>System.gc(); // 运行垃圾回收<br>System.exit(0);// 非0状态是异常中止，退出jvm<br>System.currentTimeMillis();// 获取1970年到当前时间的毫秒值</p>
<h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p>可以让超过Integer范围内的数据进行运算</p>
<h2 id="Date类-util包"><a href="#Date类-util包" class="headerlink" title="Date类(util包)"></a>Date类(util包)</h2><p>1970年1月1日为UNIX TIME的纪元时间<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d1 = <span class="keyword">new</span> Date();<span class="comment">// 空参构造，代表当前时间</span></span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">0</span>);<span class="comment">// 1970年1月1日8点，存在系统时间和本地时间的时差</span></span><br><span class="line">d1.getTime();<span class="comment">// 通过时间对象获取毫秒值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h2><p>DateFormat类的子类，抽象类，不能被实例化。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();<span class="comment">// 获取当前时间</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">sdf.format(d);<span class="comment">// 格式化时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将时间字符串转换成日期对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="string">"2000年08月08日 08:08:08"</span>;</span><br><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date d1 = sdf1.parse(str);</span><br></pre></td></tr></table></figure></p>
<p>时间毫秒值/1000/60/60/24 得到天数</p>
<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.get(Calendar.Year);<span class="comment">// 通过字段获取年</span></span><br><span class="line">c.get(Calendar.Month);<span class="comment">//  通过字段获取月，但月是从0开始</span></span><br><span class="line">c.get(Calendar.DAY_OF_MONTH);<span class="comment">// 月中的第几天</span></span><br><span class="line">c.get(Calendar.DAY_OF_WEEK);<span class="comment">// 周中的第几天，周日为第一天，周六为最后一天</span></span><br><span class="line"></span><br><span class="line">c.add(Calendar.Year, -<span class="number">1</span>);<span class="comment">// 对指定字段进行向前减或向后加</span></span><br><span class="line">c.set(Calendar.Year, <span class="number">2008</span>);<span class="comment">// 修改指定字段</span></span><br></pre></td></tr></table></figure>
<h1 id="Day15-Collection"><a href="#Day15-Collection" class="headerlink" title="Day15(Collection)"></a>Day15(Collection)</h1><h2 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h2><ul>
<li>数组既可以存储基本数据类型又可以存储引用数据类型，基本数据类型存储的是值，引用数据类型存储的是地址值；集合只能存储引用数据类型(对象)，集合中也可以存储基本数据类型，但是在存储的时候会自动装箱变成对象。</li>
<li>数组长度是固定的，不能自动增长；集合的长度是可变的，可以根据元素的增长而增长</li>
<li>元素个数是固定的推荐用数组；元素个数不固定，推荐用集合；遵循此规则节约内存，集合底层是数组，但随着集合的自动增长，会把之前的数组作废掉，产生很多内存垃圾</li>
</ul>
<h2 id="集合继承体系"><a href="#集合继承体系" class="headerlink" title="集合继承体系"></a>集合继承体系</h2><p><img src="/data/img/javase/集合继承体系图.png" alt="集合继承体系"></p>
<p>List集合中，add方法一定返回true,Set集合当存储重复元素时会返回false。</p>
<h2 id="集合转数组遍历"><a href="#集合转数组遍历" class="headerlink" title="集合转数组遍历"></a>集合转数组遍历</h2><p><code>toArray()</code>方法，将集合转换成数组<br><code>containsAll(Collection A)</code>,判断是否包含集合A<br><code>retainAll(Collection A)</code>, 取与集合A的交集</p>
<h2 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h2><p>迭代器是对集合进行遍历，而每一个集合内部的存储结构是不同的，所以每一个集合存和取是不一样的，那么就需要在每一个类中定义hasNext()和next()方法，这样做是可以的，但会使整个集合体系过于臃肿，迭代器是将这样的方法向上抽取出接口，然后在每个类的内部定义自己迭代方法，这样做的好处有而，第一规定了整个集合体系的遍历方式都是hasNext()和next()方法，第二，代码有底层内部实现，使用者不用管怎么实现的，会用即可</p>
<h2 id="List集合的特有功能"><a href="#List集合的特有功能" class="headerlink" title="List集合的特有功能"></a>List集合的特有功能</h2><ol>
<li><code>add(int index, E element)</code> 在指定位置添加元素；当存储时，出现不存在索引时，出现越界异常</li>
<li><code>remove(int index)</code> 通过索引删除元素，将被删除的元素返回；删除时不会自动装箱</li>
<li><code>get(int index)</code> 通过索引获取元素</li>
<li><p><code>set(int index, E element)</code> 设置指定索引位置的值</p>
<h2 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h2><p>遍历的同时在增加元素，出发并发修改异常。<br>解决方法：使用List特有的迭代器ListIterator,可在遍历时添加元素</p>
<h2 id="List三个子类的特点"><a href="#List三个子类的特点" class="headerlink" title="List三个子类的特点"></a>List三个子类的特点</h2><ul>
<li>ArrayList： 底层数据结构是数组，查询快，增删慢，线程不安全，效率高</li>
<li>Vector: 底层数据结构是数组，查询快，增删慢，线程安全，效率低</li>
<li>LinkedList： 底层数据结构是链表，查询慢，增删快，线程不安全，效率高</li>
</ul>
<p>综上，查询多时用ArrayList，增删多用LinkedList，如果都多，用ArrayList。</p>
</li>
</ol>
<h1 id="Day016-List"><a href="#Day016-List" class="headerlink" title="Day016 (List)"></a>Day016 (List)</h1><p><code>contains</code>方法和<code>remove</code>方法，底层依赖的是equals方法</p>
<h2 id="栈和队列数据结构"><a href="#栈和队列数据结构" class="headerlink" title="栈和队列数据结构"></a>栈和队列数据结构</h2><p>栈结构： 先进后出(类似纵向管道)<br>队列结构：先进先出(类似横向管道)</p>
<h2 id="泛型generic"><a href="#泛型generic" class="headerlink" title="泛型generic"></a>泛型generic</h2><p>好处： </p>
<ol>
<li>提高安全性(将运行期的错误转到编译期)</li>
<li>省去强转的麻烦</li>
</ol>
<p>注意事项：</p>
<ol>
<li>前后的泛型必须一致，或者后面的泛型可以省略不用写(1.7的新特性)</li>
<li>泛型不要定义为Object，没有意义</li>
</ol>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><ol>
<li><code>&lt;?&gt;</code> 当右边泛型不确定时，左边可以用<code>?</code></li>
<li><code>? extends E</code>  向下限定，E及其子类</li>
<li><code>? super E</code> 向上限定, E及其父类</li>
</ol>
<h2 id="增强for循环-foreach"><a href="#增强for循环-foreach" class="headerlink" title="增强for循环(foreach)"></a>增强for循环(foreach)</h2><ol>
<li>概述： 简化数组和Collection集合的遍历</li>
<li>格式：<br>   for(元素数据类型 变量: 数组或Collection集合) {<pre><code>使用变量即可，该变量就是元素
</code></pre>   }<br>增强for循环底层依赖的是迭代器Iterator</li>
</ol>
<h2 id="三种迭代的删除"><a href="#三种迭代的删除" class="headerlink" title="三种迭代的删除"></a>三种迭代的删除</h2><ol>
<li>普通for循环的删除，通过索引删除，索引要用<code>i--</code></li>
<li>迭代器删除，不能用集合的删除方法，会引发并发修改异常，只能用迭代器自带的remove方法。</li>
<li>增强for循环，不能删除，只能遍历</li>
</ol>
<h2 id="静态导入-开发中不常用"><a href="#静态导入-开发中不常用" class="headerlink" title="静态导入(开发中不常用)"></a>静态导入(开发中不常用)</h2><p>概念： 导入类中的静态方法<br>格式： import static 包名···.类名.方法名<br>注意事项： 方法必须是静态的，如果有多个同名的静态方法，容易不知道使用谁，如果要使用，必须加前缀</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>概述： 定义方法的时候不知道该定义多少个参数时使用可变参数<br>格式： 修饰符 返回值类型 方法名(数据类型… 变量名){}<br>注意事项： </p>
<ul>
<li>可变参数其实是一个数组</li>
<li>如果一个方法有可变参数，并且有多个参数，那么可变参数肯定是最后一个</li>
</ul>
<h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><p><code>asList</code>： 数组转换成集合<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure></p>
<p>注： </p>
<ol>
<li>数组用asList转为集合后，不能增加或减少元素，但是可以用集合的思想操作数组，可以用其它集合方法</li>
<li>基本数据类型的数组转换成集合，会将整个数组当做一个对象转换；将数组转换成集合，必须是引用数据类型</li>
</ol>
<p><code>toArray</code>： 将集合转成数组<br>若数组的长度 &lt;= 集合的size,转换后的数组长度=集合的size<br>若数组长度 &gt; 集合的size,分配数组的长度=指定长度</p>
<h1 id="Day017-Set"><a href="#Day017-Set" class="headerlink" title="Day017(Set)"></a>Day017(Set)</h1><p>Set集合无索引，不可重复，无序(存取不一致)</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使用线程池管理线程好处： </p>
<ol>
<li><p>使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的损耗</p>
</li>
<li><p>由于没有线程创建和销毁时的损耗，可以提高系统响应速度</p>
</li>
<li><p>通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行的线程数量大小</p>
</li>
</ol>
<h3 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h3><h3 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h4><ul>
<li><p><code>newCacheThreadPool</code></p>
<p>构造方法不带线程池容量，最大容量为<code>Integer.MAX_VALUE</code></p>
</li>
<li><p><code>newFixedThreadPool</code></p>
<p>构造方法中需要设定线程池容量</p>
</li>
<li><p><code>newSingleThreadPool</code></p>
<p>单个线程</p>
</li>
</ul>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><code>ScheduledThreadPoolExecutor</code></h4><ul>
<li><p><code>newSingleThreadScheduledExecutor</code></p>
</li>
<li><p><code>newScheduledThreadPool</code></p>
</li>
</ul>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h4><ul>
<li><code>newWorkStealingPool</code></li>
</ul>
<h3 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h3><p>RUNNING –&gt; SHUTDOWN –&gt; TIDYING –&gt; TERMINATED</p>
<p>或：</p>
<p>RUNNING –&gt; STOP –&gt; TIDYING –&gt; TERMINATED</p>
<p><code>RUNNING</code>: 能接受新提交的任务，并能处理阻塞队列中的任务</p>
<p><code>SHUTDOWN</code>: 关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中以保存的任务</p>
<p><code>STOP</code>: 不能接受新任务也不处理队列中的任务，会中断正在处理任务的线程</p>
<p><code>TIDYING</code>: 如果所有的任务都已经终止了，workerCount(有效线程数)为0，线程池进入该状态后会调用<code>terminated()</code>方法进入<code>TERMINATED</code>状态</p>
<p><code>TERMINATED</code>: 在<code>terminated()</code>方法执行完后进入该状态，默认<code>terminated()</code>方法中什么也没有做</p>
<h3 id="ThreadPoolExecutor参数解析"><a href="#ThreadPoolExecutor参数解析" class="headerlink" title="ThreadPoolExecutor参数解析"></a>ThreadPoolExecutor参数解析</h3><p>线程池最终调用的都是<code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</code>方法</p>
<ul>
<li><p><code>corePoolSize</code> </p>
<p>核心线程池数量</p>
</li>
<li><p><code>maximumPoolSize</code></p>
</li>
<li><p><code>keepAliveTime</code></p>
</li>
<li><p><code>unit</code></p>
</li>
<li><p><code>workQueue</code></p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2>]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/08/10/java/beforeArchitect/spring/</url>
    <content><![CDATA[<h1 id="Spring初识"><a href="#Spring初识" class="headerlink" title="Spring初识"></a>Spring初识</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>什么是框架？某些个人或组织定义了一系列的类或接口，提前定义好一些实现，用户可以在这些类和接口的基础上使用这些类来迅速形成某个领域或者某个行业的解决方案，简化开发过程，提高开发效率。</p>
<h2 id="软件设计发展历程"><a href="#软件设计发展历程" class="headerlink" title="软件设计发展历程"></a>软件设计发展历程</h2><h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>ORM： Object Relational Mapping 对象关系映射</p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起以减少部署节点和成本，此时用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加及其带来的及速度月俩月小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率此时用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务服用及整合的分布式服务框架(RPC)是关键。</p>
<h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<p><strong>Spring出现之前使用的是EJB</strong></p>
<h2 id="主流框架演变之路"><a href="#主流框架演变之路" class="headerlink" title="主流框架演变之路"></a>主流框架演变之路</h2><ol>
<li><p>JSP + Servlet + JavaBean</p>
<ul>
<li><p>JSP: Java Server Page 能内置Java代码，但配置比较麻烦</p>
</li>
<li><p>Servlet: Server Applet</p>
</li>
<li><p>JavaBean: 更多用于描述现实世界某个具体事物的抽象</p>
</li>
</ul>
</li>
<li><p>MVC三层架构</p>
<p>Model + View + Control</p>
<p> 层次分清，耦合性低</p>
</li>
<li><p>使用EJB进行应用开发，但是EJB是重量级框架，使用时有过多的接口和依赖，侵入性强，在使用上比较麻烦</p>
</li>
<li><p>SSH(Struts1/Struts2 + Hibernate + Spring)</p>
</li>
<li><p>SpringMVC + MyBatis + Spring</p>
</li>
<li><p>SpringBoot开发，约定大于配置</p>
</li>
</ol>
<h1 id="Spring理论概念"><a href="#Spring理论概念" class="headerlink" title="Spring理论概念"></a>Spring理论概念</h1><p><strong>Spring框架作为主流框架立于不败之地在于其生态</strong></p>
<p>官网： <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></p>
<h2 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h2><ul>
<li><p>GA（General Availability）：表示正式发布的版本，官方推荐使用此版本</p>
</li>
<li><p>PRE： 预览版，内部测试版，主要给开发人员和测试人员测试用</p>
</li>
<li>SNAPSHOT： 快照版，可稳定使用，且仍在继续改进版本</li>
</ul>
<h2 id="核心解释"><a href="#核心解释" class="headerlink" title="核心解释"></a>核心解释</h2><p>Spring是一个开源框架，为了简化企业开发而生，使开发变得更加优雅和简洁</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p>通过DI、AOP和消除样板式代码来简化企业开发</p>
</li>
<li><p>Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同领域，如Web服务、REST、移动开发以及NoSQL</p>
</li>
<li>低侵入式设计，代码的污染极低</li>
<li>独立于各种应用服务器，基于Spring的框架的应用可以真正实现Write Once, Run Anywhere</li>
<li>Spring的IOC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li>
<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的服用</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li>
<li>Spring的高度开放性，并不强制应用完全依赖于Spring,开发者可自由选用Spring框架的部分或者全部</li>
</ol>
<h2 id="IOC-Inversion-of-Control-控制反转"><a href="#IOC-Inversion-of-Control-控制反转" class="headerlink" title="IOC(Inversion of Control) 控制反转"></a>IOC(Inversion of Control) 控制反转</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>IOC与依赖注入(DI)同理，这是一个通过依赖注入对象的过程，也就是说他们所使用的对象，是通过构造函数参数、工厂方法的参数或从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。这个过程相对于普通创建对象的过程是反向的，因此称之为IOC。</p>
<p>谁控制谁： IOC容器控制对象</p>
<p>控制什么： 实现过程中所需要依赖的对象</p>
<p>什么是反转： IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转；有了IOC之后依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转</p>
<p>哪些方面被反转：依赖的对象</p>
<h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>IOC是设计思想，DI是具体的实现方式</p>
<p>DI： Dependency Injecttion 依赖注入</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>耦合关系不仅是对象与对象之间，也会出现在软件系统的各个模块之间。可通过IOC来实现对象之间的解耦</p>
<h1 id="Spring的使用"><a href="#Spring的使用" class="headerlink" title="Spring的使用"></a>Spring的使用</h1><p>Spring核心模块包：Beans Core Context SpEL(Spring expression)</p>
<p>beans和context包是Spring IoC的核心包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>);</span><br><span class="line">context.getBean(<span class="string">"对象名"</span>);</span><br></pre></td></tr></table></figure>
<p>ApplicationContext表示IOC容器入口，想要获取对象，必须要创建该类。该类有两个读取配置文件的实现类：</p>
<ul>
<li>ClassPathXmlApplicationContext： 表示从classpath中读取数据（常用）</li>
<li>FileSysytemXmlApplicationContext: 表示从当前文件系统读取数据</li>
</ul>
<p>使用<code>context.getBean(&quot;person&quot;)</code>来获取对象，需要进行类型强转</p>
<p><code>context.getBean(&quot;person&quot;, Person.Class)</code> 这种方式获取对象时不需要强转数据类型</p>
<p>这种方式无需手动创建对象，而是将创建对象的过程交给了spring容器。容器中的对象在容器创建完成之前就已经把对象创建好了，<br>即使没有使用getBean方法来获取对象，对象也已经创建好了，而不是get的时候再创建</p>
<p>对象的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"对象所在包"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;bean&gt;</code>标签表示要创建的bean对象：</p>
<ul>
<li>id为bean的唯一标识，为了与其他bean进行区分</li>
<li>class表示要创建的bean的完全限定名</li>
<li>property标签表示bean的属性，name为名称，value为具体的属性值</li>
</ul>
<h2 id="通过Maven的方式来创建项目"><a href="#通过Maven的方式来创建项目" class="headerlink" title="通过Maven的方式来创建项目"></a>通过Maven的方式来创建项目</h2><h3 id="第一步-导包"><a href="#第一步-导包" class="headerlink" title="第一步 导包"></a>第一步 导包</h3><p>使用IDEA选择Maven创建Spring项目，创建完成后会自动生成pom.xml配置文件</p>
<p>在Pom.xml文件里面添加Spring配置包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="第二步-创建对象文件"><a href="#第二步-创建对象文件" class="headerlink" title="第二步 创建对象文件"></a>第二步 创建对象文件</h3><p>在java文件夹下创建所需的对象属性</p>
<h3 id="第三步-创建配置文件"><a href="#第三步-创建配置文件" class="headerlink" title="第三步 创建配置文件"></a>第三步 创建配置文件</h3><p>在resource文件夹下创建对应的配置文件</p>
<h3 id="第四步-测试对象是否创建成功"><a href="#第四步-测试对象是否创建成功" class="headerlink" title="第四步 测试对象是否创建成功"></a>第四步 测试对象是否创建成功</h3><p>注意： 配置文件的位置不要放错</p>
<h2 id="Spring总结"><a href="#Spring总结" class="headerlink" title="Spring总结"></a>Spring总结</h2><ol>
<li><p>ApplicationContext就是IOC容器的接口，可以通过此对象获取容器中创建的对象</p>
</li>
<li><p>对象在Spring容器中默认是在容器创建完成之前就已经创建完成，不是需要用的时候才创建。多例模式下不会提前创建对象</p>
</li>
<li><p>对象在IOC容器中存储的时候都是单例的，如果需要多例则需要修改属性</p>
<p>在xml配置文件的bean上添加属性 <code>scope=prototype</code>,变成多例模式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"奇一星"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象给属性赋值的过程是通过setter方法实现的</p>
</li>
<li><p>对象的属性是由setter/getter方法决定的，而不是定义的成员属性</p>
</li>
</ol>
<h2 id="Spring对象的获取和属性赋值的方式"><a href="#Spring对象的获取和属性赋值的方式" class="headerlink" title="Spring对象的获取和属性赋值的方式"></a>Spring对象的获取和属性赋值的方式</h2><ol>
<li><p>通过bean的id获取IOC容器中的对象： <code>context.getBean(&quot;bean的id&quot;)</code></p>
</li>
<li><p>通过bean的类型获取对象: <code>context.getBean(Person.class)</code></p>
<p>根据类型获取对象时，如果存在两个相同的类型的对象则会报错</p>
</li>
<li><p>通过构造器给bean对象进行赋值</p>
<p>当需要从容器中获取对象的时候，最好要保留无参构造方法，因为底层的实现是反射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"LuckyStar"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置构造器时如果出现了报错，说明对应的对象里面没有找到该构造函数。此时参数的name属性是根据构造方法的参数名称决定的。name属性可以省略不写，但是需要注意顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"ioc.xml"</span>);</span><br><span class="line">Person person = context.getBean(<span class="string">"person2"</span>, Person.class);</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure>
<p>在进行框架配置的时候，可以使用xml文件，也可以使用注解的方式。实际项目中是xml配置和注解配置一起使用</p>
</li>
<li><p>通过命名空间为bean赋值，简化配置文件中属性声明的写法</p>
<p>使用p命名空间来给属性赋值</p>
<ol>
<li>引入p命名空间， 添加<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code>；xmlns xml命名空间(namespace) 简称</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用p命名空间简写，省略property</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person3"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">p:id</span>=<span class="string">"3"</span> <span class="attr">p:name</span>=<span class="string">"一星"</span> <span class="attr">p:age</span>=<span class="string">"18"</span> <span class="attr">p:gender</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为复杂类型进行赋值操作</p>
<p>复杂类型如集合、数组、其他对象等。</p>
<p>对象实体类Person.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qiyixing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String[] hobbies;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; lists;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Object&gt; map;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">               <span class="string">"id="</span> + id +</span><br><span class="line">               <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", age="</span> + age +</span><br><span class="line">               <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", hobbies="</span> + Arrays.toString(hobbies) +</span><br><span class="line">               <span class="string">", address="</span> + address +</span><br><span class="line">               <span class="string">", lists="</span> + lists +</span><br><span class="line">               <span class="string">", map="</span> + map +</span><br><span class="line">               <span class="string">", sets="</span> + sets +</span><br><span class="line">               <span class="string">", properties="</span> + properties +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String[] getHobbies() &#123;</span><br><span class="line">      <span class="keyword">return</span> hobbies;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbies</span><span class="params">(String[] hobbies)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hobbies = hobbies;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.address = address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">getLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lists;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLists</span><span class="params">(List&lt;Address&gt; lists)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lists = lists;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.map = map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sets;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sets = sets;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> properties;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.properties = properties;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"person被创建"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的配置文件ioc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"奇一星"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 使用array标签为数组赋值 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>book<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>movie<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 使用ref给引用类型赋值 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给list赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 使用内部bean,无法从容器中直接获取对象的值，即使用context.getBean("address2")是无法获取到数据的--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address2"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"江西"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"湖北"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">&lt;!-- 使用外部bean， 可以使用context.getBean("address")获取到address对象--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给set属性赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sets"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给Map赋值,entry可以有各种写法--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"111"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"address"</span> <span class="attr">value-ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"address2"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"江西"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>keykeykey<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">value</span>&gt;</span>val<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!--给properties赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"111"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"222"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"town"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承关系bean的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"4"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"父类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"son"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"子类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>context.getBean(&quot;son&quot;)</code>能将son和parent的值都获取到</p>
<p>如果只想实例化子类不想实例化父类，可以将父类变成抽象类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"4"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"父类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时<code>context.getBean(&quot;parent&quot;)</code>会报错，因为抽象类不能被实例化</p>
</li>
<li><p>bean对象创建的依赖关系</p>
<p>bean对象创建时，是按照xml配置文件定义的顺序创建的，写在前面的类会先被创建，后面的类后创建。如果需要打乱这种创建顺序，可以使用属性<code>depends-on</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述情况会先创建person对象后创建address对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">depends-on</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>加上属性<code>depends-on</code>之后则是先创建address对象后创建person对象。实际工作中不需要关注bean的创建顺序</p>
</li>
<li><p>bean的作用于控制，是否是单例</p>
<p><code>scope</code>属性可以指定当前bean的作用域，默认是单例模式singleton;prototype表示多例模式；</p>
<p>Spring4.x版本中还包含另外两种作用域：request和session</p>
<p>request表示请求，每次发送请求都会有一个新的对象</p>
<p>session表示吗，每次会话都会有一个新的对象</p>
<p>但request和session几乎不用，因此5.x之后就淘汰了</p>
<p>单例作用域在IOC容器创建之前就已经创建了bean对象，多例作用域只有在获取对象的的时候才会创建对象</p>
</li>
<li><p>利用工厂模式创建bean对象</p>
<p>之前的案例中，所有bean对象都是通过反射得到bean实例，Spring中还包含另外一种通过工厂模式创建对象的方式。利用工厂模式创建bean对象分为静态工厂和实例工厂</p>
<p>静态工厂： 工厂本身不需要创建对象，但可以通过静态方法调用，对象=工厂类.静态方法名()</p>
<ul>
<li><p>创建java静态工厂类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonStaticFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">1</span>);</span><br><span class="line">      person.setName(name);</span><br><span class="line">      person.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xml文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用静态工厂方法创建bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personStatic"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.PersonStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"静态工厂创建的bean"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例工厂： 工厂本身需要创建对象，工厂类 工厂对象=new 工厂类； 工厂对象.get对象名()</p>
<ul>
<li><p>创建java实例工厂类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInstanceFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">2</span>);</span><br><span class="line">      person.setName(name);</span><br><span class="line">      person.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xml文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用实例工厂方法创建bean --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 先创建工厂实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.PersonInstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 调用工厂实例方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personInstance"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"实例工厂创建的bean"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>   <code>factory-bean</code>是指具体的工厂实例；<code>factory-method</code>指的是工厂类中的方法，方法中的参数写在<code>constructor-arg</code>中</p>
<ol start="10">
<li><p>继承FactoryBean来创建对象</p>
<p>  FactoryBean是Spring规定的一个接口，当前接口的实现FactoryBean类时，Spring都会将其作为一个工厂，但是在ioc容器启动的时候不会创建实例，只有在使用的时候才会创建对象。</p>
<ul>
<li><p>创建自定义对象实现FactoryBean类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回获取的bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">7</span>);</span><br><span class="line">      person.setName(<span class="string">"继承FactoryBean创建对象"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回获取的bean的类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">      <span class="keyword">return</span> Person.class;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前bean是否是单例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中配置此对象,即表示将自定义的FactoryBean交由spring的IoC容器管理</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myFactoryBean"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.MyFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>此方式是Spring创建对象的一种补充，用户可以按照需求创建对象，创建的对象交由Spring IoC进行管理，对象只有在被用到时才会被创建
</code></pre><ol start="11">
<li><p>对象的初始化和销毁方法</p>
<p>Spring在创建对象的时候可以指定具体的初始化和销毁方法,属性分别为<code>init-method</code>和<code>destory-method</code></p>
</li>
<li><p>配置bean对象初始化方法的前后处理方法</p>
<p>Spring中包含一个BeanPostProcessor的接口，可以在bean的初始化方法的前后调用该方法，如果配置了初始化方法的潜质和后置处理器，无论是否包含初始化方法，都会进行调用</p>
<ul>
<li><p>编写前置/后置处理器业务代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化方法前置处理器</span></span><br><span class="line"><span class="comment">   * 在每一个对象的初始化方法前面执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"postProcessBeforeInitialization: "</span> + beanName);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化方法后置处理器</span></span><br><span class="line"><span class="comment">   * 在每一个对象的初始化方法后面执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"postProcessAfterInitialization: "</span> + beanName);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xml文件，交由Spring容器管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>   运行测试用例后可以看出，无论是否指定初始化方法，<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>都会被执行，并且是在每个对象创建之后都会执行一次</p>
<h2 id="Spring创建第三方bean对象"><a href="#Spring创建第三方bean对象" class="headerlink" title="Spring创建第三方bean对象"></a>Spring创建第三方bean对象</h2><p>Spring中，很多对象都是单例的，日常开发中经常需要使用某些外部的单实例对象，例如数据库连接池等，此时就需要在Spring中创建第三方Bean实例。</p>
<ol>
<li><p>导入数据库连接池的Pom文件</p>
<p>在<code>pom.xml</code>文件中添加以下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xml文件管理bean对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3360/demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>context.getBean(&quot;dataSource&quot;, DruidDataSource.class)</code>获取bean对象</p>
</li>
</ol>
<h2 id="Spring引入第三方配置文件"><a href="#Spring引入第三方配置文件" class="headerlink" title="Spring引入第三方配置文件"></a>Spring引入第三方配置文件</h2><ol>
<li><p>新建properties文件 <code>db.properties</code>,在配置文件中写业务相关配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql://localhost:3360/demo</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ioc.xml文件中导入一些context命名空间</p>
<p><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p>
<p><code>http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd</code></p>
<p>完整配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   "</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource2"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClassName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring容器在进行启动的时候会读取当前系统的某些环境变量的配置，因此最好的方式是添加前缀来做区分，例如数据库中的username改为jdbc.username</p>
</li>
</ol>
<h2 id="基于xml文件自动装配"><a href="#基于xml文件自动装配" class="headerlink" title="基于xml文件自动装配"></a>基于xml文件自动装配</h2><p>   Spring自动装配会把某些bean注入到另外的bean中，使用<code>autowire</code>属性实现，<code>autowire</code>属性取值：</p>
<ul>
<li><p><code>default/no</code>不装配</p>
</li>
<li><p><code>byName</code> 根据set方法后面首字母小写的名称装配</p>
</li>
<li><p><code>byType</code> 按照bean的类型进行装配，但是如果有多个类型就会报错</p>
</li>
<li><p><code>constructor</code> 按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接配null；如果按类型找到了多个，那么就是用参数名为id继续匹配，匹配不到就null</p>
</li>
</ul>
<h2 id="基于SpEL的使用"><a href="#基于SpEL的使用" class="headerlink" title="基于SpEL的使用"></a>基于SpEL的使用</h2><p>   SpEL： Spring Expression Language. Spring的表达式语言，支持运行时查询操作对象，使用<code>#{}</code>作为语法规则，所有的大括号中的字符都认为是SpEL</p>
<h2 id="Spring-Ioc的注解应用"><a href="#Spring-Ioc的注解应用" class="headerlink" title="Spring Ioc的注解应用"></a>Spring Ioc的注解应用</h2><h3 id="使用注解的方式将bean注册到spring-IoC容器中"><a href="#使用注解的方式将bean注册到spring-IoC容器中" class="headerlink" title="使用注解的方式将bean注册到spring IoC容器中"></a>使用注解的方式将bean注册到spring IoC容器中</h3><p>常用注解： <code>@Component</code> <code>@Controller</code> <code>@Service</code> <code>@Repository</code> </p>
<p>这四个注解写在类上面的时候就能完成注册bean的功能，Spring并不会根据这些注解进行区分，而是直接扫描注册，这四个注解主要是为了在实际开发中区分开来以提高代码的可读性</p>
<ul>
<li><p><code>@Component</code></p>
<p>组件，理论上可以在任何类上添加，扫描时会完成注册</p>
</li>
<li><p><code>@Controller</code></p>
<p> 放在控制层，用于接收用户的请求</p>
</li>
<li><p><code>@Service</code></p>
<p> 放在业务逻辑层</p>
</li>
<li><p><code>@Repository</code></p>
<p> 放在数据访问层</p>
</li>
</ul>
<p>在使用注解的时候必须先告诉Spring应该从哪个包开始扫描，在配置文件中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在使用注解的时候没有定义id和class,需要把当前类的名称首字母小写作为识别。例如定义一个<code>PersonController</code>类，添加注解<code>@Controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试用例中使用<code>context.getBean(&quot;personController&quot;, PersonController.class)</code>就能获取到对象，但如果getBean的名称不是personController则会报错<code>No bean named &#39;xxx&#39; available</code>。如果需要改变名称，则需要在注解上添加value属性<br>即 <code>@Controller(value=&quot;xxx&quot;)</code></p>
<p>组件默认情况下都是单例的，如果需要配置多例模式，可以在注解下添加<code>@Scope</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义扫描包时要包含的类和不包含的类"><a href="#定义扫描包时要包含的类和不包含的类" class="headerlink" title="定义扫描包时要包含的类和不包含的类"></a>定义扫描包时要包含的类和不包含的类</h3><p><code>&lt;context:component-scan base-package=&quot;com.qiyixing&quot;&gt;&lt;/context:component-scan&gt;</code>这种写法只能定义需要扫描的包，如果想要跳过一些包的扫描，则需要使用属性<code>context:exclude-filter</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 需要包含扫描的注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 需要排除扫描的注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>type表示规则的类型，expression为表达式。type的可选值有： </p>
<ul>
<li><p>assignable</p>
<p> 可以指定对应类的名称，但expression必须是完全限定名，不能写*这种通配符</p>
</li>
<li><p>annotation</p>
<p> 注解，expression必须是注解的完全限定名</p>
</li>
<li><p>regex</p>
<p> 正则表达式 一般不用</p>
</li>
<li><p>aspectj</p>
<p> 使用切面的方式，一般不用</p>
</li>
<li><p>custom</p>
<p> 使用自定义方式，自定义筛选规则，一般不用</p>
</li>
</ul>
<h3 id="自动装配的注解-Autowired和-Resource"><a href="#自动装配的注解-Autowired和-Resource" class="headerlink" title="自动装配的注解@Autowired和@Resource"></a>自动装配的注解@Autowired和@Resource</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p><code>@Autowired</code> 自动注入的注解，默认情况下是按照byType来进行装配的</p>
<ul>
<li><p>如果只找到一个类型，直接赋值；</p>
</li>
<li><p>如果没找到则抛出异常；</p>
</li>
<li><p>如果找到多个类型一样的，则会按照id来进行查找，默认id是类名首字母小写(存在多个类型的时候不能乱取名字)</p>
</li>
</ul>
<p>如果想要通过名字进行查找，可以规定自己的名称，使用注解<code>@Qualifier</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"personService"</span>)</span><br><span class="line"><span class="keyword">private</span> PersonService personService2;</span><br></pre></td></tr></table></figure>
<p>Autowired一般放在属性上，还能别的地方。</p>
<p>当@Autowired放在方法上时，此方法在创建对象的时候会默认调用，方法中的参数会进行自动装配；</p>
<p>@Qualifier注解也可以定义在方法的参数列表中，可以指定当前属性的id名称</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>使用@Resource可以完成与@Autowired相同的功能，但两者还有些区别：</p>
<ul>
<li><p>@Resource是JDK提供的功能，@Autowired是Spring提供的功能</p>
</li>
<li><p>@Resource可以在其他框架中使用，@Autowired只能在Spring中提供</p>
</li>
<li><p>@Resource扩展性好，@Autowired支持的框架比较单一</p>
</li>
<li><p>@Resource是按照名称进行装配的，如果名字找不到就使用类型；@Autowired是按照类型进行装配，类型找不到就使用名字</p>
</li>
</ul>
<h3 id="泛型依赖注入"><a href="#泛型依赖注入" class="headerlink" title="泛型依赖注入"></a>泛型依赖注入</h3><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP Aspect Oriented Programming 面向切面编程</p>
<p>OOP Object Oriented Programming 面向对象编程</p>
<p>面向切面编程是基于OOP基础上的新的编程思维，OOP面向的主要对象是类，而AOP面向的主要时切面，在处理日志、安全管理、事务管理等方面有非常重要的作用。</p>
<p>AOP是Spring中重要的核心点，虽然IoC容器没有依赖AOP，但AOP提供了非常强大的功能，用来作IoC的补充。</p>
<p>通俗来说，AOP就是将某段代码动态切入到指定方法的指定位置进行运行的编程方式</p>
<p>Spring中使用两种动态代理方式，一种是JDK提供的，另一种是cglib</p>
<p>使用JDK提供的reflect包下的类要求每个类都要有实现的接口，但实际开发中并不能保证如此，因此需要换cglib的方式</p>
<p>Spring AOP 的底层原理是动态代理</p>
<p>切面： 关注点模块化。Spring SOP中，切面可以使用通用类基于模式方式或者在普通类中使用注解@AspectJ来实现</p>
<p>通知： 在切面的某个特定的连接点上执行的动作，很多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链</p>
<pre><code>通知的注解有以下几种类型： 
- @Before 前置通知，在方法执行前完成
- @After 后置通知，在方法执行后完成
- @AfterReturning 返回通知，在返回结果之后运行
- @AfterThrowing 异常通知，出现异常的时候使用
- @Around 环绕通知，
</code></pre><p>连接点： 每个方法中可以填入额外代码的地方</p>
<p>切入点： 切入点是连接点的子集，是直接切入代码的连接点。可以通过表达式来控制切入点</p>
<p>织入： 把切面连接到其他应用程序类型或对象上，并创建一个被通知的对象的过程</p>
<h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><ol>
<li><p>导入依赖: <code>spring-aop</code>(可不导入，Spring-context中已集成此依赖) <code>cglib</code> <code>aspectJ</code> <code>aop alliance</code> <code>Spring Aspects</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写配置</p>
<ul>
<li>将目标类和切面类加入到Ioc容器中，在对应的类上添加组件注解</li>
</ul>
<p>@Aspect 将类声明成切面类 @Component 将类交由Spring管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Before</span>的后面固定写execution，execution里面写方法名的完全限定名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法开始执行"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterReturning</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法结束执行"</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterThrowing</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法抛出异常"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法执行结束： over"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将服务注册到Spring Ioc 容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalculator</span> <span class="keyword">implements</span> <span class="title">Calculator</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer i, Integer j)</span> </span>&#123;</span><br><span class="line">      Integer result = i+j;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置spring扫描包，配置AOP注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 开启包的扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 开启AOP注解 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Spring AOP底层使用动态代理，使用时会判断当前对象是否有对应的接口，若有则使用JDK代理模式，没有接口则是cglib代理模式</p>
<p>早期JDK性能不如cglib，但由于JDK不断在更新，cglib没在更新，两者性能差不多</p>
<h3 id="切入点的表达式"><a href="#切入点的表达式" class="headerlink" title="切入点的表达式"></a>切入点的表达式</h3><p>切入点的表达式使用完全限定名（如<code>@Before(&quot;execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))&quot;)</code>）过于死板，实际开发中更多使用的是通配符的方式</p>
<ul>
<li><p>通配符 <code>*</code> </p>
<ol>
<li><p>可以用来匹配一个或多个字符</p>
<p><code>execution(public Integer com.qiyixing.service.MyCalculator.*(Integer, Integer))</code></p>
<p>匹配MyCalculator类中所有的方法</p>
</li>
<li><p>可以用来匹配任意类型的参数</p>
<p><code>execution(public Integer com.qiyixing.service.MyCalculator.*(*, *))</code></p>
</li>
<li><p>*在进行匹配的时候只能匹配一层路径，不能匹配多层</p>
</li>
<li><p>*不能用来匹配访问修饰符，如果不确定访问修饰符可以不写</p>
<p> <code>execution(Integer com.qiyixing.service.MyCalculator.*(*, *))</code></p>
</li>
<li><p>返回值可以使用*来匹配</p>
<p> <code>execution(* com.qiyixing.service.MyCalculator.*(*, *))</code></p>
</li>
</ol>
</li>
<li><p>通配符<code>..</code></p>
<ol>
<li><p>可以用来匹配多个参数，任意类型</p>
<p><code>execution(* com.qiyixing.service.MyCalculator.*(..))</code></p>
</li>
<li><p>可以匹配多层路径</p>
<p><code>execution(* com.qiyixing.service..*(..))</code></p>
</li>
</ol>
</li>
</ul>
<p>表达式最偷懒的方式就是写成<code>* *(..)</code>,表达式以<code>*</code>开头能代表所有</p>
<p>使用通配符不是越简洁越好，更多的是要符合要求或者符合项目规则的匹配方式</p>
<ul>
<li><p>逻辑运算<code>&amp;&amp;</code>(与) <code>||</code>(或) <code>!</code>(非)</p>
<p> <code>execution(* com.qiyixing.service.MyCalculator.*(..)) &amp;&amp; execution(* *(..))</code></p>
<p> 同时满足两种表达式</p>
<p> <code>execution(* com.qiyixing.service.MyCalculator.*(..)) || execution(* *(..))</code></p>
<p> 两种表达式满足一种就行</p>
<p>  <code>execution(* com.qiyixing.service.MyCalculator.*(..)) || execution(* *(..))</code></p>
</li>
</ul>
<p>通知的执行顺序：</p>
<p>   正常执行： @Before –&gt; @After –&gt; @AfterReturning</p>
<p>   发生异常： @Before –&gt; @After –&gt; @AfterThrowing</p>
<p>如果要在方法中获取对应的参数或者方法名称等信息，必须使用JoinPoint对象，且此参数必须是第一个。</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">   Signature signature = joinPoint.getSignature();<span class="comment">// 获取方法签名</span></span><br><span class="line">   Object[] args = joinPoint.getArgs();<span class="comment">// 获取参数信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方法开始执行.方法签名："</span> + signature + <span class="string">";方法参数："</span>+ args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法中有返回值，那么必须要在注解中添加Returning=”xxx”，这个xxx必须要和参数列表中的参数名称保持一致</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(value = <span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"方法结束执行"</span> + result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果需要添加异常信息，注解中需要添加throwing=”xxx”,xxx必须和参数列表中的名称保持一致</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"方法抛出异常"</span> + e.getMessage());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通知方法在定义时，对于访问修饰符 类型都没有明确要求，但是参数不能随便添加</p>
<p>若多个匹配的表达式相同，则可以将表达式抽象出来</p>
<p>   先定义一个无返回值的空方法，将此空方法添加注释@PointCut,填入表达式</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>   使用时可直接调用空方法</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"myPointCut()"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">     Signature signature = joinPoint.getSignature();<span class="comment">// 获取方法签名</span></span><br><span class="line">     Object[] args = joinPoint.getArgs();<span class="comment">// 获取参数信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"方法开始执行.方法签名："</span> + signature + <span class="string">";方法参数："</span>+ args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Around通知"><a href="#Around通知" class="headerlink" title="Around通知"></a>Around通知</h3><p>环绕通知<code>@Around</code>,执行时优先于普通通知</p>
<p>正常结束执行顺序： </p>
<p>环绕前置通知 –&gt; @Before –&gt; 环绕后置通知 –&gt; 环绕返回通知 –&gt; @After –&gt; @AfterReturning</p>
<p>发生异常的执行顺序：</p>
<p>环绕前置通知 –&gt; @Before –&gt; 环绕异常通知 –&gt; 环绕返回通知 –&gt; @After –&gt; @AfterThrowing</p>
<p>如果环绕通知中捕获了异常，那么在普通通知中无法接收到的，如果想要普通通知接收异常，则不能捕获异常只能抛出</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="meta">@Around</span>(value = <span class="string">"myPointCut()"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">   Signature signature = pjp.getSignature();</span><br><span class="line">   Object[] args = pjp.getArgs();</span><br><span class="line">   Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过反射的方式调用目标方法，相当于执行method.invoke()</span></span><br><span class="line">      result = pjp.proceed(args);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      throwable.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个切面类执行顺序"><a href="#多个切面类执行顺序" class="headerlink" title="多个切面类执行顺序"></a>多个切面类执行顺序</h3><p>   当应用程序中包含多个切面类时，默认的执行顺序是按照切面类的类名首字母进行排序，按照字典序</p>
<p>   如果要指定执行顺序，需要在切面类上添加注释<code>@Order()</code> 例如<code>@Order(100)</code> 比 <code>@Order(200)</code>先执行</p>
<h3 id="使用配置文件配置AOP"><a href="#使用配置文件配置AOP" class="headerlink" title="使用配置文件配置AOP"></a>使用配置文件配置AOP</h3><ol>
<li><p>创建xml文件，导入aop命名空间</p>
</li>
<li><p>配置bean，扫描切面</p>
</li>
<li><p>配置切面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logUtil"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.utils.LogUtil"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCalculator"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.service.MyCalculator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logUtil"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"start"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"logFinally"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"stop"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">returning</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"logException"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">throwing</span>=<span class="string">"e"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置文件也能将表达式抽取出来：</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logUtil"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.utils.LogUtil"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCalculator"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.service.MyCalculator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logUtil"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"start"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"logFinally"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"stop"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">returning</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"logException"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以将表达式抽取到最外层，这样多个切面都能用</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"globalPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"bbb"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="声明式事务和传播特性"><a href="#声明式事务和传播特性" class="headerlink" title="声明式事务和传播特性"></a>声明式事务和传播特性</h2>]]></content>
      <categories>
        <category>framework,Spring</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>Spring</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter</title>
    <url>/2019/10/23/frameworks/flutter/</url>
    <content><![CDATA[<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>初学flutter，以跑起来为主，其他细节慢慢补充</p>
<h1 id="下载与安装-Windows系统"><a href="#下载与安装-Windows系统" class="headerlink" title="下载与安装(Windows系统)"></a>下载与安装(Windows系统)</h1><p>官网地址: <a href="https://dart.dev/" target="_blank" rel="noopener">https://dart.dev/</a> </p>
<h2 id="Windows系统两种安装方式"><a href="#Windows系统两种安装方式" class="headerlink" title="Windows系统两种安装方式"></a>Windows系统两种安装方式</h2><ol>
<li>通过命令行安装[不推荐]</li>
<li><p>使用官方提供的软件安装</p>
<ul>
<li>下载地址： <a href="http://www.gekorm.com/dart-windows/" target="_blank" rel="noopener">http://www.gekorm.com/dart-windows/</a></li>
<li>下载安装完成后，在命令行中输入<code>dart --version</code>，出现版本号表示安装成功</li>
</ul>
</li>
</ol>
<p><strong>MAC系统只能通过命令行进行安装</strong></p>
<h2 id="Dart开发工具配置Dart"><a href="#Dart开发工具配置Dart" class="headerlink" title="Dart开发工具配置Dart"></a>Dart开发工具配置Dart</h2><p>Dart的开发工具有很多: IntelliJ IDEA WebStorm Atom Vscode等。</p>
<h3 id="Vscode中配置Dart"><a href="#Vscode中配置Dart" class="headerlink" title="Vscode中配置Dart"></a>Vscode中配置Dart</h3><ol>
<li>搜索安装<code>Dart</code>插件</li>
<li>搜索安装<code>code runner</code>以运行文件</li>
</ol>
<p><strong>Vscode安装完插件后需要重启才能生效</strong></p>
<h1 id="Dart-语法"><a href="#Dart-语法" class="headerlink" title="Dart 语法"></a>Dart 语法</h1><h2 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h2><p>入口方法为<code>main</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Hello Dart'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无返回值的<code>main</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Hello Dart'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释方式"><a href="#注释方式" class="headerlink" title="注释方式"></a>注释方式</h2><p>使用 <code>//</code>、 <code>///</code> 、<code>/**/</code> 均能注释</p>
<h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>dart定义变量时，可以不预先定义变量类型 也可以指定变量类型</p>
<p>不预先定义变量类型使用<code>var</code>进行声明</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'this is var'</span>;</span><br></pre></td></tr></table></figure>
<p>指定变量类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="string">'this is String'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用了<code>var</code>就不能指定类型，指定了类型就不能使用<code>var</code></strong></p>
<h4 id="变量名称命名规则"><a href="#变量名称命名规则" class="headerlink" title="变量名称命名规则"></a>变量名称命名规则</h4><ol>
<li>变量名必须由数字、字母、下划线和美元符号(<code>$</code>)组成</li>
<li>标识符开头不能是数字</li>
<li>标识符不能是保留字和关键字</li>
<li>变量的名字区分大小写</li>
<li>标识符要见名思意： 变量名称建议用名词，方法名建议用动词</li>
</ol>
<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>使用修饰符<code>const</code>、<code>final</code>进行修饰</p>
<ul>
<li><code>const</code> 定义的常量值不变，一开始就需要赋值</li>
<li><p><code>final</code> 可以先不赋值，但只能赋值一次 </p>
<p>  <code>final</code>不仅有<code>const</code>的编译时常量的特性，还有运行时常量的特性，调用方法时得到常量值可以用<code>final</code>修饰</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">final</span> a = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  const b = new DateTime.now(); 错误写法，运行会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串-String类型"><a href="#字符串-String类型" class="headerlink" title="字符串 (String类型)"></a>字符串 (String类型)</h3><h4 id="字符串的定义方式"><a href="#字符串的定义方式" class="headerlink" title="字符串的定义方式"></a>字符串的定义方式</h4><pre><code>- 可以用单引号(&apos;&apos;)或者双引号定义(&quot;&quot;)
- 使用三个单引号(&apos;&apos;&apos;  &apos;&apos;&apos;)或者三个双引号(&quot;&quot;&quot;  &quot;&quot;&quot;)可定义多行字符串
</code></pre><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">'单引号定义字符串'</span>;</span><br><span class="line">  <span class="built_in">print</span>(str);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> str2 = <span class="string">"双引号定义字符串"</span>;</span><br><span class="line">  <span class="built_in">print</span>(str2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> str3 = <span class="string">''' </span></span><br><span class="line"><span class="string">                三个单引号</span></span><br><span class="line"><span class="string">                定义</span></span><br><span class="line"><span class="string">                多行</span></span><br><span class="line"><span class="string">                字符串</span></span><br><span class="line"><span class="string">                '''</span>;</span><br><span class="line">  <span class="built_in">print</span>(str3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> str4 = <span class="string">""" 三个双引号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  定义</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  多行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  字符串  </span></span><br><span class="line"><span class="string">                  </span></span><br><span class="line"><span class="string">                  """</span>;</span><br><span class="line">  <span class="built_in">print</span>(str4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><ol>
<li><p>使用<code>$</code></p>
 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'donkey'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'monkey'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"one: $str1,$str2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"two: $str1 $str2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出结果：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one: donkey,monkey</span><br><span class="line">two: donkey monkey</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>+</code></p>
 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="string">'donkey'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">'monkey'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"one: "</span> + str1 + <span class="string">","</span> + str2);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"two: "</span> + str1 + <span class="string">" "</span> + str2);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出结果： </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one: donkey,monkey</span><br><span class="line">two: donkey monkey</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数值类型-Number型"><a href="#数值类型-Number型" class="headerlink" title="数值类型(Number型)"></a>数值类型(Number型)</h3><p><code>int</code>  必须是整型</p>
<p><code>double</code> 浮点型， 也可赋值整型,但会带上小数点</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">double</span> d = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"d: "</span> + <span class="string">"$d"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"i: "</span> + <span class="string">"$i"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d: 1.0</span><br><span class="line">i: 1</span><br></pre></td></tr></table></figure>
<p>注： 此处打印时使用<code>print(&quot;d: &quot; + d);</code> 会报类型错误</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>bool值只能为<code>true</code>或<code>false</code></p>
<h3 id="数组-集合类型-List"><a href="#数组-集合类型-List" class="headerlink" title="数组/集合类型 (List)"></a>数组/集合类型 (List)</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义List方式1</span></span><br><span class="line">    <span class="keyword">var</span> list = [<span class="string">"abc"</span>,<span class="string">"aaa"</span>,<span class="string">"ccc"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义List方式2</span></span><br><span class="line">    <span class="keyword">var</span> list2 = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line">    list2.add(<span class="string">"nanana"</span>);</span><br><span class="line">    list2.add(<span class="string">"ninini"</span>);</span><br><span class="line">    list2.add(<span class="string">"nununu"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(list2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义指定类型的List</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> list3 = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();<span class="comment">// 只能添加String类型的元素</span></span><br><span class="line"></span><br><span class="line">    list3.add(<span class="string">"111"</span>);</span><br><span class="line">    list3.add(<span class="string">"222"</span>);</span><br><span class="line">    list3.add(<span class="string">"333"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(list3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abc, aaa, ccc]</span><br><span class="line">[nanana, ninini, nununu]</span><br><span class="line">[111, 222, 333]</span><br></pre></td></tr></table></figure>
<h3 id="字典类型-Map"><a href="#字典类型-Map" class="headerlink" title="字典类型(Map)"></a>字典类型(Map)</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种定义Map的方式</span></span><br><span class="line">    <span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(person);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(person[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(person[<span class="string">"age"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种定义Map的方式</span></span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    p[<span class="string">"name"</span>] = <span class="string">"李四"</span>;</span><br><span class="line">    p[<span class="string">"age"</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">"age"</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;name: 张三, age: 18&#125;</span><br><span class="line">张三</span><br><span class="line">18</span><br><span class="line">&#123;name: 李四, age: 20&#125;</span><br><span class="line">李四</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="数据类型的判断"><a href="#数据类型的判断" class="headerlink" title="数据类型的判断"></a>数据类型的判断</h3><p>使用关键词<code>is</code>判断数据类型</p>
<h2 id="运算符-与java一样-先跳过"><a href="#运算符-与java一样-先跳过" class="headerlink" title="运算符 (与java一样 先跳过)"></a>运算符 (与java一样 先跳过)</h2><h2 id="循环语句-与java一样-先跳过"><a href="#循环语句-与java一样-先跳过" class="headerlink" title="循环语句 (与java一样 先跳过)"></a>循环语句 (与java一样 先跳过)</h2><h2 id="集合-与java一样-先跳过"><a href="#集合-与java一样-先跳过" class="headerlink" title="集合 (与java一样 先跳过)"></a>集合 (与java一样 先跳过)</h2><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 方法名称(参数1,参数2,[可选参数1,可选参数2],....) &#123;</span><br><span class="line">    方法体</span><br><span class="line"></span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数内只能写一行代码</p>
<h2 id="Dart中类和对象"><a href="#Dart中类和对象" class="headerlink" title="Dart中类和对象"></a>Dart中类和对象</h2><p>Dart中没有<code>public</code> <code>private</code> <code>protected</code> 等修饰符,若要将属性或方法私有化可以使用<code>_</code></p>
<h1 id="Flutter环境配置"><a href="#Flutter环境配置" class="headerlink" title="Flutter环境配置"></a>Flutter环境配置</h1><h2 id="windows上搭建Flutter-Android运行环境"><a href="#windows上搭建Flutter-Android运行环境" class="headerlink" title="windows上搭建Flutter Android运行环境"></a>windows上搭建Flutter Android运行环境</h2><ol>
<li>安装配置JDK</li>
<li>安装Android Studio</li>
<li>下载配置Flutter SDK</li>
<li><p>配置Flutter镜像</p>
<p> <code>build.gradle</code>中將<code>google()</code> <code>jcenter()</code>注釋掉，換成阿里鏡像地址：</p>
   <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">maven&#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">maven&#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;</span><br><span class="line">maven&#123;url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Flutter-V-1-9-1-2019年9月更新版"><a href="#Flutter-V-1-9-1-2019年9月更新版" class="headerlink" title="Flutter (V 1.9.1 2019年9月更新版)"></a>Flutter (V 1.9.1 2019年9月更新版)</h1><h2 id="跟随官网开始学-https-flutter-dev-docs-get-started-codelab"><a href="#跟随官网开始学-https-flutter-dev-docs-get-started-codelab" class="headerlink" title="跟随官网开始学(https://flutter.dev/docs/get-started/codelab)"></a>跟随官网开始学(<code>https://flutter.dev/docs/get-started/codelab</code>)</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>以下代码均为VsCode中完成，<strong>光标移动到终端</strong>后可执行一些快捷命令：</p>
<ul>
<li><p><code>r</code>/<code>R</code> 热部署项目</p>
</li>
<li><p><code>p</code> 显示网格</p>
</li>
<li><p><code>o</code> 切换平台(IOS/Android平台切换)</p>
</li>
<li><p><code>q</code> 退出</p>
</li>
</ul>
<h4 id="第一步-初始化Flutter-app"><a href="#第一步-初始化Flutter-app" class="headerlink" title="第一步 初始化Flutter app"></a>第一步 初始化Flutter app</h4><ol>
<li>导入<code>material.dart</code> UI库，material官网： <code>https://material.io/</code></li>
<li><p>书写入口方法并调用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>main()</code> 表示入口方法</li>
<li><code>=&gt;</code> 箭头函数，后面内容为一行时使用，一种语法糖</li>
<li><code>MyApp()</code> 自定义的方法</li>
</ul>
</li>
<li><p>声明自定义方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildcontext) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;This is for my note!&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;Demo Page&apos;),),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(&apos;Hello World&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上述demo创建了一个<code>Material app</code>,<code>Material</code>是遵循移动端和网页端标准的一种视觉设计语言，官网为 <code>https://material.io/</code>，Flutter中提供了丰富的Material组件</p>
</li>
<li><p>自定义的<code>MyApp</code>必须继承<code>StatelessWidget</code>以将自己定义为组件，在Flutter中，万物皆组件，例如： <code>alignment</code>、<code>padding</code>、<code>layout</code></p>
</li>
<li><p><code>StatelessWidget</code>是抽象类，因此要重写<code>build</code>方法，重写需要加上<code>@override</code>注释,<code>build</code>方法中必须要有参数<code>BuildContext</code></p>
</li>
<li><p><code>Scaffold</code>是<code>Material</code>中的一个组件,提供了自定义<code>appbar</code>、<code>title</code>、<code>body</code>属性来维持<code>home</code>页面的组件树，<code>Scaffold</code>的子组件可以很复杂，用于构建所需界面</p>
</li>
<li><p>一个组件的主要方法就是提供<code>build()</code>方法来将其它或者更低级的组件封装来定义界面显示</p>
</li>
<li><p>上述demo中的<code>body</code>是由<code>Center</code>组件和其子组件<code>Text</code>组成的，<code>Center</code>组件表示将其子组件设置为居中屏幕对齐</p>
</li>
</ul>
</li>
</ol>
<h4 id="第二步-引用外部包"><a href="#第二步-引用外部包" class="headerlink" title="第二步 引用外部包"></a>第二步 引用外部包</h4><p>此步骤中，使用一个外部开源包<code>english_words</code>,此包中含有常用英语以及一些实用短语。</p>
<p><code>english_words</code>包以及其它开源包可在<code>https://pub.dev/</code>中获取</p>
<ol>
<li><p><code>pubspec</code>文件负责管理Flutter APP中的依赖和assets。打开项目根目录下的<code>pubspec.yaml</code>文件，将<code>english_words</code>及其版本添加到依赖列表中：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: flutter_app</span><br><span class="line">description: A new Flutter application.</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  sdk: &quot;&gt;=2.1.0 &lt;3.0.0&quot;</span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  cupertino_icons: ^0.1.2</span><br><span class="line">  # 此处添加依赖</span><br><span class="line">  english_words: ^3.1.5</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  flutter_test:</span><br><span class="line">    sdk: flutter</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖添加完成后，VSCode会自动导包，并在根目录下的<code>pubspec.lock</code>文件中自动生成对应外部包的相关信息。如果使用的是<code>Android Studio</code>则需要点击<code>Packages get</code>进行导包，无论使用哪种，只要控制台出现了<code>Running &quot;flutter pub get&quot; in 项目名...</code>就表示已将外部包成功导入项目中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">english_words:</span><br><span class="line">dependency: &quot;direct main&quot;</span><br><span class="line">description:</span><br><span class="line">  name: english_words</span><br><span class="line">  url: &quot;https://pub.dartlang.org&quot;</span><br><span class="line">source: hosted</span><br><span class="line">version: &quot;3.1.5&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>lib/main.dart</code>文件中引入</p>
<p> <img src="../../../../data/img/flutter/flutter_importPackage.png" alt="flutter引入外包"></p>
<p> 引入时编辑器会提示此包还未使用、</p>
</li>
<li><p>使用<code>english_words</code>生成文字代替上述demo中的<code>Hello World</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:english_words/english_words.dart&apos;;// 导包</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildcontext) &#123;</span><br><span class="line">    // 注入</span><br><span class="line">    final wordPair = WordPair.random();</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;This is for my note!&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;Demo Page&apos;),),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(wordPair.asPascalCase),// 使用</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注： <code>wordPair.asPascalCase</code>中<code>PascalCase</code>表示将每个单词的首字母大写，如将<code>helloworld</code>写成<code>HelloWorld</code></p>
</li>
<li><p>上述代码每热部署(Android Studio快捷键<code>ctrl+s</code>; VScode在终端键入<code>r</code>)一次,界面就会随机显示不同的词语。因为该词语是在<code>build</code>方法中生成的，每启动一次项目或切换平台时，MaterialApp就会重新进行渲染。</p>
</li>
</ol>
<h4 id="第三步-添加一个有状态的组件"><a href="#第三步-添加一个有状态的组件" class="headerlink" title="第三步 添加一个有状态的组件"></a>第三步 添加一个有状态的组件</h4><p><code>Stateless</code>组件是不可变的，即其所有属性都无法改变——所有值都为final。</p>
<p><code>Stateful</code>组件的状态在组件的生命周期内可变化。实现一个有状态的组件至少需要两个类</p>
<p>  1) <code>StatefulWidget</code>类<br>  2) <code>State</code>类</p>
<p>创建一个<code>State</code>类的对象<code>StatefulWidget</code></p>
<p><code>StatefulWidget</code>类本身是不可变的，但<code>State</code>类在组件的生命周期中会一直存在</p>
<p>在此步骤中，会添加一个有状态的组件<code>RandomWords</code>继承新创建父类<code>RandomWordsState</code>，然后就能在无状态组件<code>MyApp</code>中作为<code>child</code>来使用<code>RandomWords</code>了。</p>
<ol>
<li><p>在<code>main.dart</code>中创建有状态类<code>RandomWordsState</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>State&lt;RandomWords&gt;</code>表示声明一个泛型为<code>RandomWords</code>的通用类<code>State</code>。App中大多数的逻辑和状态都存在这，这里表示状态为<code>RandomWords</code>的组件。这个类将保存随着用户滚动而无限增长的生成的单词对， 以及喜欢的单词对，用户通过重复点击心形 ❤️ 图标来将它们从列表中添加或删除。(<strong>啥玩意儿？没懂</strong>)</p>
<p> <code>RandomWordsState</code>依赖于<code>RandomWords</code>类</p>
</li>
<li><p>在<code>main.dart</code>中添加有状态的<code>RandomWords</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RandomWords extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  RandomWordsState createState() =&gt; RandomWordsState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后，编辑器会提示<code>RandomWordsState</code>缺少<code>build</code>方法,接下来就是通过将<code>MyApp</code>中的代码移动到<code>RandomWordsState</code>中，为<code>RandomWordsState</code>添加<code>build</code>方法。</p>
</li>
<li><p>在<code>RandomWordsState</code>中添加<code>build</code>方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    final wordPair = WordPair.random();</span><br><span class="line"></span><br><span class="line">    return Text(wordPair.asPascalCase);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改MyApp中生成随机文字部分的代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildcontext) &#123;</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;This is for my note!&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;Demo Page&apos;),),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RandomWords(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启App。</p>
</li>
</ol>
<h4 id="第四步-创建无限滚动的ListView"><a href="#第四步-创建无限滚动的ListView" class="headerlink" title="第四步 创建无限滚动的ListView"></a>第四步 创建无限滚动的ListView</h4><p>在此步骤中，你将<code>RandomWordsState</code>扩展成展示词语的列表。用户滚动屏幕，该列表将无限展示词语。</p>
<p><code>ListView</code>的<code>builder</code>构造函数工厂可以根据需求快速创建列表。</p>
<ol>
<li><p>在<code>RandomWordsState</code>中创建一个<code>_suggestions</code>列表来保存推荐的成语。同时创建一个<code>_biggerFont</code>变量来使字体变大。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RandomWordsState extends State&lt;RandomWords&gt; &#123;</span><br><span class="line">  final _suggestions = &lt;WordPair&gt;[];</span><br><span class="line">  final _biggerFont = const TextStyle(fontSize: 18);</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    final wordPair = WordPair.random();</span><br><span class="line"></span><br><span class="line">    return Text(wordPair.asPascalCase);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注： 在Dart语法中，前缀用<code>_</code>表示私有</p>
<p> 接下来为<code>RandomWordsState</code>类添加方法<code>_buildSuggestions()</code>，此方法用于创建显示推荐的词语。</p>
<p> <code>ListView</code>类中提供了属性<code>itemBuilder</code>,这是一个工厂匿名回调函数，含有两个参数： <code>BuildContext</code>和迭代器<code>i</code>。迭代器从0开始递增，每生成推荐的一次单词对就会自增两次，一次用于<code>ListTile</code>,一次用于<code>Divider</code>。此模式能随着用户的滚动无限出现单词对。</p>
</li>
<li><p>在<code>RandomWordsState</code>类中添加<code>_buildSuggestions()</code>方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Widget _buildSuggestions() &#123;</span><br><span class="line">  return ListView.builder(</span><br><span class="line">    padding: const EdgeInsets.all(16),</span><br><span class="line">    itemBuilder: (context, i ) &#123;</span><br><span class="line">      if(i.isOdd) return Divider();</span><br><span class="line"></span><br><span class="line">      final index = i ~/ 2;</span><br><span class="line">      if(index &gt;= _suggestions.length) &#123;</span><br><span class="line">        _suggestions.addAll(generateWordPairs().take(10));</span><br><span class="line">      &#125;</span><br><span class="line">      return _buildRow(_suggestions[index]);</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>itemBuilder</code>每产生一对单词对就会被回调一次，并将每对单词对放入<code>ListTile</code>行中。偶数行添加<code>ListTile</code>行；奇数行添加<code>Divider</code>组件将每对单词分开。需要注意的是，<code>Divider</code>在小屏上看起来可能不太明显</p>
</li>
<li><p><code>if(i.isOdd) return Divider();</code>表示在<code>ListView</code>的每一行之前加上1像素的分割线</p>
</li>
<li><p><code>final index = i ~/ 2;</code>表达式<code>~/</code>表示取<code>i/2</code>结果的整型，向下取整。例如：i为1,2,3,4,5时，得到的结果分别为0,1,1,2,2。此处用于计算<code>ListView</code>中减去分割线后实际的单词对数量。</p>
</li>
<li><p>如果是建议列表中最后一个单词对，接着再生成10个单词对，然后添加到建议列表。</p>
<p><code>_buildSuggestions()</code>方法每生成一对单词对就会调用一次<code>_buildRow</code>。<code>_buildRow</code>用于在<code>ListTile</code>中显示新的单词对以使下一步中每行看起来更漂亮</p>
</li>
</ul>
</li>
<li><p>在<code>RandomWordsState</code>中添加<code>_buildRow</code>方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Widget _buildRow(WordPair wordPair) &#123;</span><br><span class="line">  return ListTile(</span><br><span class="line">    title: Text(</span><br><span class="line">      wordPair.asPascalCase,</span><br><span class="line">      style: _biggerFont,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>RandomWordsState</code>类中的<code>build</code>方法，使用<code>_buildSuggestions()</code>代替直接调用单词生成库。脚手架(Scaffold)实现了基本的<code>Material</code>设计视觉布局。将<code>body</code>中的内容改成：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext buildContext) &#123;</span><br><span class="line">  return Scaffold(</span><br><span class="line">    appBar: AppBar(title: Text(&apos;Infinity scroll word pairs&apos;)),</span><br><span class="line">    body: _buildSuggestions(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>更新<code>MyApp</code>类中<code>build</code>方法，修改<code>title</code>并将<code>home</code>改成<code>RandomWords</code>组件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildcontext) &#123;</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Startup Name Generator&apos;,</span><br><span class="line">      home: RandomWords(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启项目即可查看结果</p>
</li>
</ol>
<h2 id="Flutter内置组件"><a href="#Flutter内置组件" class="headerlink" title="Flutter内置组件"></a>Flutter内置组件</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>MaterialAPP组件作为根组件，具有<code>home</code>属性，<code>home</code>属性调用<code>Scaffold</code>组件</p>
<p>实例化类时，关键字<code>new</code>可以省略。</p>
<h3 id="Scaffold组件"><a href="#Scaffold组件" class="headerlink" title="Scaffold组件"></a>Scaffold组件</h3><ul>
<li><p><code>appBar</code></p>
<p>顶部导航栏</p>
</li>
<li><p><code>body</code></p>
<p>页面内容</p>
</li>
</ul>
<ul>
<li><p><code>bottomNavigationBar</code></p>
<p>底部导航栏</p>
</li>
<li><p><code>floatingActionButton</code></p>
<p>右下角浮动按钮</p>
</li>
<li><p><code>drawer</code> 、 <code>endDrawer</code></p>
<p><code>drawer</code>左侧侧边栏 <code>endDrawer</code></p>
<p>值类型为<code>Drawer</code>,详见<code>Drawer</code>组件</p>
</li>
</ul>
<h3 id="Text组件"><a href="#Text组件" class="headerlink" title="Text组件"></a>Text组件</h3><p>属性写在<code>Text()</code>中，内容为必填，还有很多可选参数。例如<code>style</code>用来设置文本的样式，值需要使用内置组件<code>TextStyle</code>，<code>TextStyle</code>中可以设置字体大小、颜色等文字相关样式</p>
<p>Flutter中的文本都不能直接写，必须使用Text进行封装</p>
<ul>
<li><p><code>textAlign</code>(文本对齐方式)</p>
<ul>
<li><p><code>TextAlign.center</code> 居中</p>
</li>
<li><p><code>TextAlign.left</code> 左对齐</p>
</li>
<li><p><code>TextAlign.right</code> 右对齐</p>
</li>
<li><p><code>TextAlign.justify</code> 两端对齐</p>
</li>
</ul>
</li>
<li><p><code>textDirection</code> (文本方向)</p>
<ul>
<li><p><code>TextDirection.ltr</code> 从左到右</p>
</li>
<li><p><code>TextDirection.rtl</code> 从右到左</p>
</li>
</ul>
</li>
<li><p><code>overflow</code> 文本溢出后的处理方式</p>
<ul>
<li><p><code>TextOverflow.ellipsis</code> 溢出部分用<code>...</code>代替</p>
</li>
<li><p><code>TextOverflow.fade</code> 文字溢出，从上往下为渐变效果</p>
</li>
<li><p><code>TextOverflow.clip</code> 溢出部分裁剪(默认)</p>
</li>
</ul>
</li>
<li><p><code>textScaleFactor</code> 字体显示倍率</p>
<p>相对于谁的倍率？父元素？</p>
</li>
<li><p><code>maxLines</code> 文字最大显示行数</p>
</li>
<li><p><code>style</code> 字体样式设置</p>
<p>值需要用<code>TextStyle</code>进行封装，可设置字体样式</p>
<ul>
<li><p><code>decoration</code> 文字装饰线</p>
<ul>
<li><p><code>TextDecoration.overline</code> 上划线</p>
</li>
<li><p><code>TextDecoration.lineThrough</code> 中划线(删除线)</p>
</li>
<li><p><code>TextDecoration.underline</code> 下划线</p>
</li>
<li><p><code>TextDecoration.none</code> 无装饰(默认)</p>
</li>
</ul>
</li>
<li><p><code>decorationColor</code> 文字装饰线颜色</p>
</li>
<li><p><code>decorationStyle</code> 文字装饰线样式</p>
</li>
<li><p><code>decorationThickness</code> 文字装饰线粗细</p>
</li>
<li><p><code>color</code> 字体颜色</p>
</li>
<li><p><code>backgroundColor</code>(文字填充色)</p>
</li>
<li><p><code>fontSize</code> (字体大小)</p>
<p>默认为14像素，若设置了字体显示倍率<code>textScaleFactor</code>,则渲染出来的字体大小 = <code>fontSize</code> * <code>textScaleFactor</code></p>
</li>
<li><p><code>fontWeight</code>(字体粗细)</p>
<ul>
<li><p><code>FontWeight.bold</code> 加粗 (w700)</p>
</li>
<li><p><code>FontWeight.normal</code> 正常(默认 w400)</p>
</li>
<li><p><code>FontWeight.wxxx</code> <code>xxx</code>为自定义加粗数值</p>
</li>
</ul>
</li>
<li><p><code>fontStyle</code> (字体样式是否倾斜)</p>
<ul>
<li><code>FontStyle.italic</code> 字体倾斜</li>
</ul>
</li>
<li><p><code>letterSpacing</code> (字间距，常用于中文字体)</p>
</li>
<li><p><code>wordSpacing</code> (单词间距)</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>  以下以后慢慢研究</p>
<ul>
<li><code>textBaseline</code></li>
<li><code>height</code></li>
<li><code>locale</code></li>
<li><code>foreground</code></li>
<li><code>background</code></li>
<li><code>shadows</code></li>
<li><code>fontFeatures</code> </li>
<li><code>debugLabel</code></li>
<li><code>fontFamily</code></li>
<li><code>fontFamilyFallback</code></li>
<li><code>package</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;; // 引入material.io的UI包</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Welcome to flutter&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(&apos;Welcome to Flutter for bar &apos;)</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            &apos;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sunt corrupti reprehenderit aliquid harum, perspiciatis aliquam omnis?&apos;,// 文本内容</span><br><span class="line">            textAlign: TextAlign.left,// 文字对齐样式</span><br><span class="line">            maxLines: 1,//最大显示行</span><br><span class="line">            // overflow: TextOverflow.ellipsis,// 文字溢出使用...代替</span><br><span class="line">            overflow: TextOverflow.fade, // 文字溢出，从上往下为渐变效果</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Container组件-容器组件"><a href="#Container组件-容器组件" class="headerlink" title="Container组件/容器组件"></a>Container组件/容器组件</h3><p>作用类似于<code>div</code></p>
<p>常用属性(键值对)：</p>
<ul>
<li><p><code>width</code> 、 <code>height</code></p>
<p>宽度和高度，此宽高将<code>padding</code>的值包含在内,相当于CSS中的填充盒宽高</p>
<p>不设置宽高时，<code>Container</code>会自动充满屏幕</p>
<p><strong>宽高的取值类型定义为了<code>double</code>，好几个视频老师强调如果是整数也需要写成浮点型，但实际写成<code>int</code>型也能执行，有可能是版本更新的原因，暂不深究</strong></p>
</li>
<li><p><code>alignment</code>(<strong>内容</strong>对齐方式)</p>
<p><code>alignment: Alignment.topLeft</code>值为<code>Alignment</code>类型，取值一般为以下</p>
<ul>
<li><p><code>Alignment.topLeft</code> 上部靠左对齐</p>
</li>
<li><p><code>Alignment.topCenter</code> 上部居中对齐</p>
</li>
<li><p><code>Alignment.topRight</code> 上部靠右对齐</p>
</li>
<li><p><code>Alignment.center</code> 居中对齐</p>
</li>
<li><p><code>Alignment.bottomLeft</code> 下部靠左对齐</p>
</li>
<li><p><code>Alignment.bottomCenter</code> 下部居中对齐</p>
</li>
<li><p><code>Alignment.bottomRight</code> 下部靠右对齐</p>
</li>
</ul>
</li>
<li><p><code>padding</code> (内边距)</p>
<p>默认值为0,类型为<code>EdgeInsets</code></p>
<ul>
<li><p><code>EdgeInsets.all(10)</code>  上下左右内边距均为10</p>
</li>
<li><p><code>EdgeInsets.fromLTRB(left, top, right, bottom)</code> 左上右下分别设置内边距</p>
</li>
</ul>
</li>
<li><p><code>margin</code>(外边距)</p>
<p>基本用法参见<code>padding</code></p>
</li>
<li><p><code>color</code> (背景填充色)</p>
<p><code>color: Colors.pink</code> </p>
<ul>
<li><p>此背景色填充范围涵盖<code>padding</code>,相当于CSS中的填充盒</p>
</li>
<li><p>取值为<code>Color</code>类</p>
<ul>
<li><p><code>Colors.内置颜色单词</code> 框架内置颜色</p>
</li>
<li><p><code>Color.fromARGB(a, r, g, b)</code> a、r、g、b分别表示透明度、红、绿、蓝，类型均为<code>int</code></p>
</li>
<li><p><code>Color.fromRGBO(r, g, b, opacity)</code> opacity表示透明度，类型为<code>double</code>,其他均为<code>int</code></p>
</li>
</ul>
</li>
</ul>
<p><code>color</code>实际上是<code>BoxDecoration(color: color)</code>的简写，因此设置了这里的颜色就不能设置<code>decoration</code>中的任意<code>color</code>(例如<code>border</code>中的颜色),否则执行会报错: <code>Cannot provide both a color and a decoration</code></p>
</li>
<li><p><code>decoration</code> (边框及背景颜色)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: BoxDecoration(</span><br><span class="line">  color: Colors.pink,</span><br><span class="line">  border: Border.all(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    width: 20</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>decoration</code>取值为<code>BoxDecoration</code>类，可以设置边框样式及背景填充色</p>
<p><code>decoration</code>也可设置背景色为渐变，写法如下： </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: Center(</span><br><span class="line">  child: Container(</span><br><span class="line">    child: new Text(&apos;Flutter盒模型&apos;, style: TextStyle(fontSize: 40.0)),</span><br><span class="line">    alignment: Alignment.topRight,</span><br><span class="line">    width: 300,</span><br><span class="line">    height: 300,</span><br><span class="line">    // color: Colors.pink,</span><br><span class="line">    padding: const EdgeInsets.fromLTRB(10, 20, 30, 40),</span><br><span class="line">    margin: const EdgeInsets.all(10),</span><br><span class="line">    decoration: new BoxDecoration(</span><br><span class="line">      gradient: const LinearGradient(</span><br><span class="line">        colors: [Colors.pink,Colors.purple,Colors.white]</span><br><span class="line">      ),</span><br><span class="line">      border: Border.all(width: 6,color: Colors.lightBlue)</span><br><span class="line">    ),</span><br><span class="line">  </span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>foregroundDecoration</code> (暂不研究)</p>
</li>
<li><p><code>constraints</code>(暂不研究)</p>
</li>
<li><p><code>transform</code>(旋转Container)</p>
<p>类似CSS3中的<code>transform</code>属性，待深究</p>
</li>
<li><p><code>child</code> (子元素) <strong>此部分待考究，先往下学</strong></p>
<p><code>Container</code>的子元素(大概要称为子组件？)</p>
<p>不设置<code>child</code>和<code>constraints</code>时，内容会自动撑满可用空间。</p>
<ul>
<li><p>若未设置宽高值，可用空间为整个父类；</p>
</li>
<li><p>若设置了宽高且未设置<code>constraints</code>时，可用空间为所设置的范围内</p>
</li>
<li><p>若只设置宽或高，不设置<code>constraints</code>时，未设置的那部分会自动撑满</p>
</li>
</ul>
</li>
</ul>
<h3 id="image-图片组件"><a href="#image-图片组件" class="headerlink" title="image(图片组件)"></a>image(图片组件)</h3><p>为图片添加滤镜(图片混合模式)</p>
<ul>
<li><p><code>Image.network</code> 添加网络图片</p>
<ul>
<li><p><code>src</code> 直接填写，不用封装成字典形式，除<code>src</code>可以直接填写以外，其他属性都要使用字典样式</p>
</li>
<li><p><code>alignment</code> 图片对齐方式</p>
</li>
<li><p><code>color</code> <code>colorBlendMode</code> 联合使用 用于将图片和背景色混合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child: new Image.network(</span><br><span class="line">  &apos;https://w.wallhaven.cc/full/dg/wallhaven-dgv8qo.png&apos;,</span><br><span class="line">  color: Colors.greenAccent,</span><br><span class="line">  colorBlendMode: BlendMode.darken,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fit</code> </p>
<p>控制图片在容器中显示的效果(拉伸、 挤压等),使用<code>BoxFit</code>类封装</p>
<ul>
<li><p><code>BoxFit.fill</code> 充满父容器</p>
</li>
<li><p><code>BoxFit.fitHeight</code> 高度方向拉伸充满父容器</p>
</li>
<li><p><code>BoxFit.fitWidth</code> 宽度方向拉伸充满父容器</p>
</li>
<li><p><code>BoxFit.contain</code> 全图显示，保持原比例，可能会有空隙</p>
</li>
<li><p><code>BoxFit.cover</code> 充满父容器且保持原比例，可能会有部分内容被裁切</p>
</li>
</ul>
</li>
<li><p><code>repeat</code> </p>
<p>图片在容器中的平铺效果，默认只显示一张图片</p>
<ul>
<li><p><code>ImageRepeat.repeatY</code> Y方向平铺</p>
</li>
<li><p><code>ImageRepeat.repeatX</code> X方向平铺</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="圆角图片实现的两种方式"><a href="#圆角图片实现的两种方式" class="headerlink" title="圆角图片实现的两种方式"></a>圆角图片实现的两种方式</h4><ol>
<li><p>使用<code>Container</code>的圆角属性<code>borderRadius</code>和 <code>image</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;I am learning Container&apos;)),</span><br><span class="line">        body: Container(</span><br><span class="line">          width: 300,</span><br><span class="line">          height: 300,</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">            color: Colors.pinkAccent,</span><br><span class="line">            borderRadius: BorderRadius.circular(150),// 指定弧度为宽高的一半就能变成圆形</span><br><span class="line">            image: DecorationImage(</span><br><span class="line">              image: NetworkImage(&apos;https://w.wallhaven.cc/full/vm/wallhaven-vmg8r3.jpg&apos;),</span><br><span class="line">              fit: BoxFit.cover</span><br><span class="line">            )</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>ClipOval</code>组件</p>
<p><code>ClipOval</code>会自动子图片设置弧度，若要设置圆形的图片，需要设置图片的宽高的<code>fit</code>属性，以保证每一张图片都为圆形</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;I am learning Container&apos;)),</span><br><span class="line">        body: Container(</span><br><span class="line">          child: ClipOval(</span><br><span class="line">            child: Image.network(&apos;https://w.wallhaven.cc/full/42/wallhaven-4277l6.jpg&apos;,</span><br><span class="line">              height: 100,</span><br><span class="line">              width: 100,</span><br><span class="line">              fit: BoxFit.cover</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="引入本地图片"><a href="#引入本地图片" class="headerlink" title="引入本地图片"></a>引入本地图片</h4><p>一般建议存放图标等内容</p>
<ol>
<li><p>在根目录中新建文件夹<code>images</code>,在<code>images</code>下创建子文件夹<code>2.0x</code>、<code>3.0x</code>、<code>4.0x</code>… 官网要求必须有<code>2.0x</code>和<code>3.0x</code></p>
</li>
<li><p>将图片复制到上面新建的每一个子文件夹中</p>
<p><strong>Flutter项目运行在手机上时会根据不同屏幕的分辨率加载不同文件夹下对应的图片，因此必须按照上述步骤配置多个文件夹</strong></p>
</li>
<li><p>在<code>pubspec.yaml</code>文件中的<code>assets</code>配置图片路径</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">assets:</span><br><span class="line">  - images/a_dot_burr.jpeg</span><br><span class="line">  - images/a_dot_ham.jpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入本地图片时使用<code>Image.asset</code>来设置图片地址，其他属性设置与<code>Image.network</code>相同</p>
</li>
</ol>
<p><strong>更正：本地图片的文件夹不需要按照步骤1、2中所说的方式定死，只要在<code>pubspec.yaml</code>文件中配置好自定义的文件简爱就可以了，上述步骤可能是老版本限制</strong></p>
<h3 id="列表组件-ListView"><a href="#列表组件-ListView" class="headerlink" title="列表组件 ListView"></a>列表组件 ListView</h3><p>可用于新闻列表。Fluter中提供了五种常见的列表：垂直列表、垂直图文列表、水平列表、动态列表、矩阵式列表</p>
<h4 id="列表组件中的参数"><a href="#列表组件中的参数" class="headerlink" title="列表组件中的参数"></a>列表组件中的参数</h4><ul>
<li><p><code>children</code></p>
<p>列表中的元素，使用<code>&lt;Widget&gt;[]</code>封装，<code>&lt;Widget&gt;[]</code>中可以添加任何组件，如<code>Container()</code> <code>Image.network(src)</code>等,但一般都是配合<code>ListTile</code>组件使用</p>
<ul>
<li><p><code>ListTile</code>参数</p>
<p>官方文档： <code>A single fixed-height row that typically contains some text as well as a leading or trailing icon.</code></p>
<ul>
<li><p><code>title</code> 标题</p>
</li>
<li><p><code>subtitle</code> 二级标题</p>
</li>
<li><p><code>leading</code> 列表前图标： <code>Icon(Icons.内置图标名)</code>； <code>Icon()</code>中还可以设置其他属性，如图标大小、颜色等，可以以后研究</p>
</li>
<li><p><code>trailing</code> 列表末尾图标，设置同<code>leading</code></p>
</li>
</ul>
<p><strong><code>leading</code>和<code>trailing</code>还可以使用<code>Image.asset()</code>设置图片</strong></p>
</li>
</ul>
</li>
<li><p><code>padding</code> 列表整体的内边距</p>
</li>
<li><p><code>scrollDirection</code> 列表方向</p>
<p>默认为垂直列表，将<code>scrollDirection</code>设置成为<code>Axis.horizontal</code>时，变为水平列表但此处有坑，当<code>children</code>为<code>ListTile</code>时，无法设置<code>ListTile</code>的宽度，此时若设置成为水平列表则会报错 <code>BoxConstraints forces an infinite width</code>。</p>
<p>水平列表无法使用<code>ListTile</code>??需要研究下<code>ListTile</code>是个啥</p>
</li>
</ul>
<h4 id="动态列表"><a href="#动态列表" class="headerlink" title="动态列表"></a>动态列表</h4><ol>
<li><p>通过循环语句实现动态列表</p>
<ul>
<li><p>在同一类中直接获取数组</p>
<ul>
<li><p>自定义一个私有方法返回一个数组，返回类型必须为<code>List&lt;Widget&gt;</code></p>
</li>
<li><p>调用自定义方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">    List&lt;Widget&gt; list = new List();</span><br><span class="line"></span><br><span class="line">    for(var i=0; i&lt;20; i++) &#123;</span><br><span class="line">      list.add(ListTile(title: Text(&apos;这是第$i个列表&apos;)));</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;I am learning Container&apos;)),</span><br><span class="line">        body: Container(</span><br><span class="line">          child: ListView(</span><br><span class="line">              children: _getData()</span><br><span class="line">            ),</span><br><span class="line">        ) </span><br><span class="line">      ),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导入外部文件中的数据</p>
<p>假设有外部数据文件<code>data/list.dart</code>如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List listData = [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;myhome&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;lalaby&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/nk/wallhaven-nk1gkd.jpg&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;work&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;nino&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/vm/wallhaven-vmg8r3.jpg&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;ala&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;kiyo&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/47/wallhaven-47kkd3.jpg&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;olo&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;mizu&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/42/wallhaven-4277l6.jpg&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;yojo&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;yama&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/4x/wallhaven-4x93gv.png&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;title&quot;: &quot;yolo&quot;,</span><br><span class="line">                      &quot;author&quot;: &quot;sla&quot;,</span><br><span class="line">                      &quot;imageUrl&quot;: &quot;https://w.wallhaven.cc/full/4v/wallhaven-4vo7vl.jpg&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- 导入文件数据`import &apos;./data/list.dart&apos;;`

- 遍历数据并将结果转成`List`

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">  var tempList = listData.map((value) &#123;</span><br><span class="line">    return ListTile(</span><br><span class="line">      title: Text(value[&quot;title&quot;]),</span><br><span class="line">      subtitle: Text(value[&quot;author&quot;]),</span><br><span class="line">      leading: Image.network(value[&quot;imageUrl&quot;]),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return tempList.toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 调用私有方法`_getData()`
</code></pre><ol start="2">
<li><p>利用<code>ListView</code>提供的<code>builder()</code>方法来实现动态列表</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;I am learning Container&apos;)),</span><br><span class="line">        body: Component(), </span><br><span class="line">      ),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  List list = new List();</span><br><span class="line">  Component() &#123;    </span><br><span class="line">    for(var i=0; i&lt;20; i++) &#123;</span><br><span class="line">      list.add(Text(&apos;这是第$i个列表&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return ListView.builder(</span><br><span class="line">      itemCount: list.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        return ListTile(</span><br><span class="line">          title: list[index],</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="GridView组件"><a href="#GridView组件" class="headerlink" title="GridView组件"></a>GridView组件</h3><p>网格布局，可用于实现商品列表。</p>
<p>常用两种方式实现网格布局： </p>
<ol>
<li><p>通过<code>GridView.count</code>实现</p>
</li>
<li><p>通过<code>GridView.builder</code>实现</p>
</li>
</ol>
<h4 id="GridView常用属性"><a href="#GridView常用属性" class="headerlink" title="GridView常用属性"></a>GridView常用属性</h4><ul>
<li><p><code>children</code></p>
<p>子元素列表，使用<code>&lt;Widget&gt;[]</code>封装</p>
</li>
<li><p><code>crossAxisCount</code> </p>
<p>一行中Widget的数量</p>
</li>
<li><p><code>mainAxisSpacing</code></p>
<p>子Widget之间垂直距离</p>
</li>
<li><p><code>crossAxisSpacing</code></p>
<p>子Widget之间水平距离</p>
</li>
<li><p><code>childAspectRatio</code></p>
<p>子Widget宽高比,通过调整宽高比来控制子组件的高度，直接设置子组件的高度是无效的</p>
</li>
</ul>
<h4 id="通过GridView-count实现网格布局"><a href="#通过GridView-count实现网格布局" class="headerlink" title="通过GridView.count实现网格布局"></a>通过<code>GridView.count</code>实现网格布局</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget&#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext)  &#123;</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;listView&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;Change Your Mind&apos;), backgroundColor: Colors.transparent),</span><br><span class="line">        body: GridView.count(</span><br><span class="line">                crossAxisCount: 3,</span><br><span class="line">                mainAxisSpacing: 2,</span><br><span class="line">                crossAxisSpacing: 2,</span><br><span class="line">                childAspectRatio: 0.7,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/nk/wallhaven-nk1gkd.jpg&apos;,fit: BoxFit.cover),</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/vm/wallhaven-vmg8r3.jpg&apos;,fit: BoxFit.cover),</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/47/wallhaven-47kkd3.jpg&apos;,fit: BoxFit.cover),</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/42/wallhaven-4277l6.jpg&apos;,fit: BoxFit.cover),</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/4x/wallhaven-4x93gv.png&apos;,fit: BoxFit.cover),</span><br><span class="line">                  Image.network(&apos;https://w.wallhaven.cc/full/4v/wallhaven-4vo7vl.jpg&apos;,fit: BoxFit.cover)</span><br><span class="line">                ],</span><br><span class="line">              )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用动态数据：</p>
<ul>
<li><p>处理动态数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  import &apos;data/list.dart&apos;;</span><br><span class="line"></span><br><span class="line">  List&lt;Widget&gt; _getData() &#123;</span><br><span class="line">  var tempList = listData.map((value) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Image.network(value[&quot;imageUrl&quot;],fit: BoxFit.cover,),</span><br><span class="line">          Text(value[&quot;title&quot;])</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return tempList.toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用数据渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&apos;I am learning Container&apos;)),</span><br><span class="line">        body: Component(), </span><br><span class="line">      ),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return GridView.count(</span><br><span class="line">      crossAxisCount: 3,</span><br><span class="line">      mainAxisSpacing: 1,</span><br><span class="line">      crossAxisSpacing: 2,</span><br><span class="line">      children: _getData(),</span><br><span class="line">    );    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="通过GridView-builder实现网格布局"><a href="#通过GridView-builder实现网格布局" class="headerlink" title="通过GridView.builder实现网格布局"></a>通过<code>GridView.builder</code>实现网格布局</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return GridView.builder(</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: 3</span><br><span class="line">      ),</span><br><span class="line">      itemCount: listData.length,</span><br><span class="line">      itemBuilder: _getData</span><br><span class="line">    );    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _getData(context, index) &#123;</span><br><span class="line">    var value = listData[index];</span><br><span class="line">    return Container(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Image.network(value[&quot;imageUrl&quot;],fit: BoxFit.cover,),</span><br><span class="line">            Text(value[&quot;title&quot;])</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>GridView.builder</code>注意事项：</p>
<ul>
<li><p><code>itemCount</code>表示需要处理的数据的长度</p>
</li>
<li><p><code>itemBuilder</code>表示处理数据的方法，需要传入<code>context</code>和<code>index</code>两个参数</p>
</li>
<li><p><code>gridDelegate</code> 用来控制每行显示的组件个数及组件之间横向纵向距离以及宽高比等，使用<code>SliverGridDelegateWithFixedCrossAxisCount</code>封装</p>
</li>
<li><p><code>gridDelegate</code>为必填项，若为空，运行时会报错30486<code>The following assertion was thrown building Component(dirty): &#39;package:flutter/src/widgets/scroll_view.dart&#39;: Failed assertion: line 1491 pos 15: &#39;gridDelegate != null&#39;: is not true.</code></p>
</li>
</ul>
<h3 id="常见的页面布局组件-padding-Row-Column-Expanded"><a href="#常见的页面布局组件-padding-Row-Column-Expanded" class="headerlink" title="常见的页面布局组件 (padding Row Column Expanded)"></a>常见的页面布局组件 (<code>padding</code> <code>Row</code> <code>Column</code> <code>Expanded</code>)</h3><h4 id="Padding组件"><a href="#Padding组件" class="headerlink" title="Padding组件"></a>Padding组件</h4><p>HTML中常见的布局标签都有<code>padding</code>属性，但Flutter中很多组件都没有<code>padding</code>属性，一般采用<code>Padding</code>组件来处理容器与子容器间接的间距</p>
<p>常用属性</p>
<ul>
<li><p><code>padding</code></p>
<p>设置内边距值</p>
</li>
<li><p><code>child</code></p>
<p>放入需要设置内边距的子组件</p>
</li>
</ul>
<h3 id="Row组件"><a href="#Row组件" class="headerlink" title="Row组件"></a>Row组件</h3><p>水平布局组件</p>
<p>常用参数</p>
<ul>
<li><p><code>mainAxisAlignment</code></p>
<p>主轴的排序方式(水平方向)</p>
<ul>
<li><p><code>MainAxisAlignment.center</code> 子元素整体居中显示</p>
</li>
<li><p><code>MainAxisAlignment.end</code> 子元素整体靠最右显示</p>
</li>
<li><p><code>MainAxisAlignment.spaceAround</code> 子元素之间的距离是元素到两边的距离的两倍</p>
</li>
<li><p><code>MainAxisAlignment.between</code> 子元素之间两边的距离为0，元素中间距离相等</p>
</li>
<li><p><code>MainAxisAlignment.spaceEvenly</code> 子元素之间和两边的距离平均分配</p>
</li>
</ul>
</li>
<li><p><code>crossAxisAlignment</code></p>
<p>次轴(垂直方向)的排序方式，相对于外层Y轴方向的显示方式</p>
<ul>
<li><p><code>CrossAxisAlignment.start</code> Y轴最上方</p>
</li>
<li><p><code>CrossAxisAlignment.end</code> Y轴最下方</p>
</li>
<li><p><code>CrossAxisAlignment.stretch</code> Y方向上拉伸至充满父元素 </p>
</li>
<li><p><code>CrossAxisAlignment.baseline</code> 设置成<code>baseline</code>时，必须设置<code>textBaseline</code>,否则会运行出错</p>
</li>
</ul>
</li>
<li><p><code>children</code></p>
<p>组件子元素</p>
</li>
</ul>
<h3 id="Column组件"><a href="#Column组件" class="headerlink" title="Column组件"></a>Column组件</h3><p>垂直布局组件</p>
<p>属性和Row组件基本一致，但主轴方向是垂直方向，次轴方向为水平方向</p>
<h3 id="Expanded组件"><a href="#Expanded组件" class="headerlink" title="Expanded组件"></a>Expanded组件</h3><p>类似于Web中的Flex布局</p>
<p>常用属性：</p>
<ul>
<li><p><code>flex</code></p>
</li>
<li><p><code>child</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      color: Colors.grey,</span><br><span class="line">      child:  Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: 1,</span><br><span class="line">              child: Container(child: Text(&apos;sdfsdfs&apos;), color: Colors.blue,),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: 2,</span><br><span class="line">              child: Container(child: Text(&apos;rstgs rrtgs&apos;), color: Colors.pink,),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: 2,</span><br><span class="line">              child: Container(child: Text(&apos;uyki tkjh&apos;), color: Colors.green,),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: 2,</span><br><span class="line">              child: Container(child: Text(&apos;sdhbev &apos;), color: Colors.deepOrange,),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SizeBox组件"><a href="#SizeBox组件" class="headerlink" title="SizeBox组件"></a>SizeBox组件</h3><p>元素与元素之间的间距可以用<code>margin属性</code>也可以用<code>SizeBox</code>组件，一般常用的是<code>SizeBox</code></p>
<h3 id="Stack层叠组件"><a href="#Stack层叠组件" class="headerlink" title="Stack层叠组件"></a>Stack层叠组件</h3><p>用于实现定位布局可单独使用，也可以<code>Align</code>组件或<code>Positioned</code>组件联用</p>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul>
<li><p><code>alignment</code></p>
<p><code>Stack</code>组件中的所有元素对齐方式,无法对单个元素进行定位，可与<code>Align</code>或<code>Positioned</code>联用控制单个元素定位</p>
<p><code>Align</code>组件通过设置<code>alignment</code>来对单个元素进行定位</p>
<p><code>Positioned</code>组件通过设置<code>left</code> <code>right</code> <code>top</code> <code>bottom</code>等的值来对单个元素进行定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        height: 400,</span><br><span class="line">        width: 300,</span><br><span class="line">        color: Colors.pinkAccent,</span><br><span class="line">        child: Stack(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Align(</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              child: Image.network(&quot;https://w.wallhaven.cc/full/42/wallhaven-42pr69.jpg&quot;,width: 120,height: 120),</span><br><span class="line">            ),</span><br><span class="line">            Align(</span><br><span class="line">              alignment: Alignment.topLeft,</span><br><span class="line">              child: Image.network(&quot;https://w.wallhaven.cc/full/4l/wallhaven-4lepvl.jpg&quot;,width: 120,height: 120),</span><br><span class="line">            ),</span><br><span class="line">            Align(</span><br><span class="line">              alignment: Alignment.bottomLeft,</span><br><span class="line">              child: Image.network(&quot;https://w.wallhaven.cc/full/4g/wallhaven-4g3dgq.jpg&quot;,width: 120,height: 120),</span><br><span class="line">            ),</span><br><span class="line">            Align(</span><br><span class="line">              alignment: Alignment.topRight,</span><br><span class="line">              child: Image.network(&quot;https://w.wallhaven.cc/full/vm/wallhaven-vmx6gm.jpg&quot;,width: 120,height: 120),</span><br><span class="line">            ),</span><br><span class="line">            Align(</span><br><span class="line">              alignment: Alignment.bottomRight,</span><br><span class="line">              child: Image.network(&quot;https://w.wallhaven.cc/full/x1/wallhaven-x15qpv.jpg&quot;,width: 120,height: 120),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>children</code></p>
</li>
</ul>
<h3 id="AspectRatio组件"><a href="#AspectRatio组件" class="headerlink" title="AspectRatio组件"></a>AspectRatio组件</h3><p>调整子元素child的宽高比</p>
<h3 id="Card组件"><a href="#Card组件" class="headerlink" title="Card组件"></a>Card组件</h3><p>卡片组件，内容可由大多数类型的组件组成，<code>Card</code>具有圆角和阴影，让它看起来更具立体感</p>
<p>常用属性：</p>
<ul>
<li><p><code>margin</code></p>
<p>外边距</p>
</li>
<li><p><code>child</code></p>
<p>子组件</p>
</li>
<li><p><code>Shape</code></p>
<p>设置阴影效果，默认阴影效果为圆角的长方形边</p>
</li>
</ul>
<p>卡片组件可以包含任何组件，但建议结合<code>ListView</code>组件一起使用,但需要注意的是<code>ListView</code>组件不能嵌套<code>ListView</code>组件</p>
<h4 id="图文卡片的实现"><a href="#图文卡片的实现" class="headerlink" title="图文卡片的实现"></a>图文卡片的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Component extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    return ListView(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Card(</span><br><span class="line">          margin: EdgeInsets.all(10),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              AspectRatio(</span><br><span class="line">                aspectRatio: 4/3,</span><br><span class="line">                child: Image.network(&quot;https://w.wallhaven.cc/full/ox/wallhaven-ox7357.jpg&quot;,fit: BoxFit.cover,),</span><br><span class="line">              ),</span><br><span class="line">              ListTile(</span><br><span class="line">                leading: ClipOval(                  </span><br><span class="line">                  child: Image.network(&quot;https://w.wallhaven.cc/full/13/wallhaven-13op8v.jpg&quot;,fit: BoxFit.cover,height: 50,width: 50,),</span><br><span class="line">                ),</span><br><span class="line">                title: Text(&quot;Candy Nija&quot;),</span><br><span class="line">                subtitle: Text(&quot;my first photo&quot;),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Card(</span><br><span class="line">          margin: EdgeInsets.all(10),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              AspectRatio(</span><br><span class="line">                aspectRatio: 4/3,</span><br><span class="line">                child: Image.network(&quot;https://w.wallhaven.cc/full/13/wallhaven-13op8v.jpg&quot;,fit: BoxFit.cover,),</span><br><span class="line">              ),</span><br><span class="line">              ListTile(</span><br><span class="line">                leading: ClipOval(                  </span><br><span class="line">                  child: Image.network(&quot;https://w.wallhaven.cc/full/ey/wallhaven-eyv2z8.jpg&quot;,fit: BoxFit.cover,height: 50,width: 50,),</span><br><span class="line">                ),</span><br><span class="line">                title: Text(&quot;Cindy Casio&quot;),</span><br><span class="line">                subtitle: Text(&quot;stop and think&quot;),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Card(</span><br><span class="line">          margin: EdgeInsets.all(10),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              AspectRatio(</span><br><span class="line">                aspectRatio: 4/3,</span><br><span class="line">                child: Image.network(&quot;https://w.wallhaven.cc/full/vg/wallhaven-vg2gl8.jpg&quot;,fit: BoxFit.cover,),</span><br><span class="line">              ),</span><br><span class="line">              ListTile(</span><br><span class="line">                // leading: ClipOval(                  </span><br><span class="line">                //   child: Image.network(&quot;https://w.wallhaven.cc/full/39/wallhaven-397326.jpg&quot;,fit: BoxFit.cover,height: 50,width: 50,),</span><br><span class="line">                // ),</span><br><span class="line">                leading: CircleAvatar(backgroundImage: NetworkImage(&quot;https://w.wallhaven.cc/full/39/wallhaven-397326.jpg&quot;),),</span><br><span class="line">                title: Text(&quot;Joker Nija&quot;),</span><br><span class="line">                subtitle: Text(&quot;Another life&quot;),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Wrap组件"><a href="#Wrap组件" class="headerlink" title="Wrap组件"></a>Wrap组件</h3><p><code>Row</code>组件和<code>Column</code>组件分别是控制的是单行单列的布局，<code>Wrap</code>组件在主轴方向上空间不足时，会自动向次轴方向上扩展显示以实现流布局</p>
<p>常用属性： </p>
<ul>
<li><p><code>direction</code> 主轴方向</p>
<p>  <code>Axis.vertical</code> 垂直</p>
<p>  <code>Axis.horizontal</code> 水平</p>
</li>
<li><p><code>alignment</code> 主轴对齐方式</p>
</li>
<li><p><code>spacing</code> 元素之间主轴方向上的间距，直接输入数值即可</p>
</li>
<li><p><code>runSpacing</code> 元素之间在次轴方向上的间距</p>
</li>
</ul>
<h3 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h3><p>按钮的属性基本一致，只是显示的样式不同</p>
<ul>
<li><p><code>RaiseButton</code> 凸起按钮组件</p>
<p><code>Create a filled button.</code></p>
<p>默认为一个灰色填充效果的按钮</p>
<p><code>RaiseButton</code>组件中必须有属性<code>onPressed</code>监听，否则设置的样式等会无效</p>
</li>
<li><p><code>FlatButton</code> 扁平化按钮</p>
</li>
<li><p><code>OutlineButton</code> 线框按钮</p>
</li>
<li><p><code>IconButton</code> 图标按钮</p>
</li>
<li><p><code>ButtonBar</code> 按钮组</p>
</li>
<li><p><code>FloatingActionButton</code> 浮动按钮</p>
</li>
</ul>
<h3 id="StatefulWidget组件"><a href="#StatefulWidget组件" class="headerlink" title="StatefulWidget组件"></a>StatefulWidget组件</h3><p>Flutter中自定义组件其实就是在定义一个类，这个类需要继承<code>StatelessWidget</code>/<code>StatefulWidget</code></p>
<ul>
<li><p><code>StatelessWidget</code> 表示无状态组件，状态不可变</p>
</li>
<li><p><code>StatefulWidget</code> 表示有状态组件，持有的状态可在Widget生命周期改变。如果想改变页面中的数据，则需要使用<code>StatefulWidget</code></p>
</li>
</ul>
<p>VsCode中装插件<code>Awesome Flutter Snippets</code>后,输入<code>statelessW</code>/<code>statefulW</code>即可自动生成自定义组件的基本结构</p>
<p><code>State</code>类中有一个方法<code>setState()</code>可以改变值重新渲染页面</p>
<h3 id="BottomNavigationBar组件"><a href="#BottomNavigationBar组件" class="headerlink" title="BottomNavigationBar组件"></a>BottomNavigationBar组件</h3><p>底部导航条组件，是Scaffold的参数</p>
<p>常用参数</p>
<ul>
<li><p><code>items</code></p>
<ul>
<li><p>底部导航条按钮集合，至少要有两个<code>BottomNavigationBarItem</code>，否则运行报错<code>&#39;items.length &gt;= 2&#39;: is not true.</code></p>
</li>
<li><p>返回类型为<code>BottomNavigationBarItem</code>集合，参数有：</p>
<ul>
<li><p><code>icon</code> 图标</p>
</li>
<li><p><code>title</code> 标题名</p>
</li>
<li><p><code>activeIcon</code> 选中时图标</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>currentIndex</code></p>
<p>默认选中第几个</p>
</li>
<li><p><code>onTap</code></p>
<p>选中变化回调函数</p>
</li>
<li><p><code>fixedColor</code></p>
<p>选中的颜色</p>
</li>
<li><p><code>type</code></p>
<p>配置底部导航栏可以有多个按钮</p>
<ul>
<li><p><code>BottomNavigationBarType.shifting</code></p>
<p>切换导航时有淡入淡出效果且不显示未选中的按钮</p>
</li>
<li><p><code>BottomNavigationBarType.fixed</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>Flutter中通过<code>Navigator</code>组件管理路由导航，并提供了管理堆栈的方法，如<code>Navigator.push</code>和<code>Navigator.pop</code></p>
<p>Flutter提供了额两种配置路由跳转的方式： 基本路由和命名路由</p>
<h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><p>固定写法： </p>
<ul>
<li><p><code>Navigator.push</code> 跳转至下一级子页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).push(</span><br><span class="line">  MaterialPageRoute(</span><br><span class="line">    builder: (context) =&gt; SearchPage() // SearchPage为需要跳转的页面</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Navigator.pop</code> 退出当前页面，返回上一级页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><ol>
<li><p>在<code>main.dart</code>文件中的<code>MaterialApp</code>中的<code>routes</code>属性进行配置路由</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes: &#123;</span><br><span class="line">  &apos;/search&apos; : (context) =&gt; SearchPage(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过使用<code>Navigator.pushNamed(context,&#39;路由名&#39;)</code>跳转</p>
<p> 路由名必须要跟<code>routes</code>中的名字对应</p>
</li>
</ol>
<p>命名路由传值</p>
<p>官方demo只是为了指定路由传值，以下写法可以改成通用传值: </p>
<ul>
<li><p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义路由 arguments表示可选参数</span></span><br><span class="line"><span class="keyword">final</span> routes  = &#123;</span><br><span class="line">  <span class="string">'/search'</span> : (context, &#123;arguments&#125;) =&gt; SearchPage(arguments: arguments),</span><br><span class="line">  <span class="string">'/form'</span> : (context, &#123;arguments&#125;) =&gt; SearchPage(arguments: arguments),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// 切换路由时的操作</span></span><br><span class="line">      onGenerateRoute: (settings) &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = settings.name;<span class="comment">// 获取路由名称</span></span><br><span class="line">        <span class="keyword">final</span> Function pageContentBuilder = <span class="keyword">this</span>.routes[name];<span class="comment">// 将自定义配置的路由名赋给pageContentBuilder</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pageContentBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// pageContentBuilder不为空，利用MaterialPageRoute进行跳转</span></span><br><span class="line">          <span class="keyword">if</span> (settings.arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Route route = MaterialPageRoute(</span><br><span class="line">              builder: (context) =&gt; </span><br><span class="line">                pageContentBuilder(context,arguments: settings.arguments));<span class="comment">// settings.arguments为传递的参数</span></span><br><span class="line">            <span class="keyword">return</span> route;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Route route= MaterialPageRoute(</span><br><span class="line">              builder: (context) =&gt; </span><br><span class="line">                pageContentBuilder(context));</span><br><span class="line">            <span class="keyword">return</span> route;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      home: Tabs(),</span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> arguments;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">SearchPage</span><span class="params">(&#123;<span class="keyword">this</span>.arguments&#125;)</span></span>;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Container(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(title: Text(<span class="string">'搜索'</span>),),</span><br><span class="line">          body: Container(</span><br><span class="line">            child: Row(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'查询$&#123;arguments != null ? arguments['</span>id<span class="string">'] : '</span><span class="number">0</span><span class="string">'&#125;'</span>),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    </span><br><span class="line">                  &#125;,</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>路由配置可最终抽离成一个单独的文件<code>Routes.dart</code>:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../pages/Search.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../pages/Tabs.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">final</span> routes  = &#123;</span><br><span class="line">  <span class="string">'/'</span> : (context, &#123;arguments&#125;) =&gt; Tabs(),</span><br><span class="line">  <span class="string">'/search'</span> : (context, &#123;arguments&#125;) =&gt; SearchPage(arguments: arguments),</span><br><span class="line">  <span class="string">'/form'</span> : (context, &#123;arguments&#125;) =&gt; SearchPage(arguments: arguments),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由跳转</span></span><br><span class="line">var onGenerateRoute = (settings) &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = settings.name;</span><br><span class="line">        <span class="keyword">final</span> Function pageContentBuilder = routes[name];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pageContentBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If you push the route</span></span><br><span class="line">          <span class="keyword">if</span> (settings.arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Cast the arguments to the correct type: ScreenArguments.</span></span><br><span class="line">            <span class="keyword">final</span> Route route = MaterialPageRoute(</span><br><span class="line">              builder: (context) =&gt; </span><br><span class="line">                pageContentBuilder(context,arguments: settings.arguments));</span><br><span class="line">            <span class="keyword">return</span> route;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Route route= MaterialPageRoute(</span><br><span class="line">              builder: (context) =&gt; </span><br><span class="line">                pageContentBuilder(context));</span><br><span class="line">            <span class="keyword">return</span> route;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<p><code>main.dart</code>配置如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'routes/Routes.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>=&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      onGenerateRoute: onGenerateRoute,</span><br><span class="line">      initialRoute: <span class="string">'/'</span>, <span class="comment">// 初始化加载的路由</span></span><br><span class="line">      theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">      <span class="comment">// routes: &#123;</span></span><br><span class="line">      <span class="comment">//   '/search' : (context) =&gt; SearchPage(),</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路由替换以及返回到根路由"><a href="#路由替换以及返回到根路由" class="headerlink" title="路由替换以及返回到根路由"></a>路由替换以及返回到根路由</h3><ul>
<li><p><code>Navigator.of(context).pushReplacementNamed(&#39;路由名&#39;)</code></p>
<p>替换路由，将当前页面替换成指定页面，替换后的页面点击返回时，返回的还是当前页面的上一级</p>
<p>因此可以借助路由替换来实现返回根路由</p>
</li>
<li><p><code>Navigator.of(context).pushAndRemoveUntil(newRoute, predicate)</code></p>
<p>直接返回根目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushAndRemoveUntil(MaterialPageRoute(</span><br><span class="line">                builder: (context) =&gt; Tabs(),<span class="comment">// 根路由页面</span></span><br><span class="line">              ), (route) =&gt; route = <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AppBar组件"><a href="#AppBar组件" class="headerlink" title="AppBar组件"></a>AppBar组件</h3><p>将<code>MaterialApp</code>中的<code>debugShowCheckedModeBanner</code>设置成为<code>false</code>则不显示右上角<code>debugg</code>图标</p>
<p>顶部导航</p>
<ul>
<li><p><code>title</code> </p>
<p>顶部导航文字 </p>
</li>
<li><p><code>backgroundColor</code></p>
<p>导航栏背景颜色</p>
</li>
<li><p><code>leading</code></p>
<p>导航栏左侧加元素，一般是图标,如果需要点击图标监听事件，则需要用<code>IconButton</code></p>
</li>
<li><p><code>actions</code></p>
<p>导航栏右侧添加元素</p>
</li>
<li><p><code>centerTitle</code></p>
<p>设置文本是否居中</p>
</li>
<li><p><code>automaticallyImplyLeading</code></p>
<p>导航栏左侧是否显示自动生成的<code>leading</code>图标</p>
<ul>
<li><p>/// Controls whether we should try to imply the leading widget if null.<br>///<br>/// If true and [leading] is null, automatically try to deduce what the leading<br>/// widget should be. If false and [leading] is null, leading space is given to [title].<br>/// If leading widget is not null, this parameter has no effect.</p>
</li>
</ul>
</li>
</ul>
<h3 id="TabController"><a href="#TabController" class="headerlink" title="TabController"></a>TabController</h3><ul>
<li><p>在<code>MaterialApp</code>的<code>home</code>内添加<code>DefaultTabController()</code>,设置标签长度<code>length</code></p>
<p>  若不配置<code>length</code>,运行时会报错：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The method &apos;&gt;=&apos; was called on null.</span><br><span class="line">···</span><br><span class="line">When the exception was thrown, this was the stack:</span><br><span class="line">I/flutter ( 3567): #0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5)</span><br><span class="line">I/flutter ( 3567): #1      new DefaultTabController (package:flutter/src/material/tab_controller.dart:315:22)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>AppBar()</code>的<code>bottom</code>属性中添加<code>TabBar()</code></p>
</li>
<li><p>在<code>body</code>中设置<code>TabView()</code>,定义标签切换对应的页面</p>
<p><code>TabView()</code>的长度必须与<code>TabBar()</code>中的一致，否则报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The following assertion was thrown building TabBarView(dirty, dependencies: [_TabControllerScope],</span><br><span class="line">I/flutter ( 3567): state: _TabBarViewState#351c0):</span><br><span class="line">I/flutter ( 3567): Controller&apos;s length property (2) does not match the</span><br><span class="line">I/flutter ( 3567): number of tabs (3) present in TabBar&apos;s tabs property.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>demo示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  theme: ThemeData(primaryColor: Colors.lime),</span><br><span class="line">  home: DefaultTabController(</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    child: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"data"</span>),</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">          tabs: &lt;Widget&gt;[</span><br><span class="line">            Tab(text: <span class="string">"热门"</span>,),</span><br><span class="line">            Tab(text: <span class="string">"推荐"</span>,)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      body: TabBarView(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                ListView(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    ListTile(title: Text(<span class="string">"热门标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"热门标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"热门标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"热门标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"热门标签内容"</span>),),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">                ListView(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    ListTile(title: Text(<span class="string">"推荐标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"推荐标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"推荐标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"推荐标签内容"</span>),),</span><br><span class="line">                    ListTile(title: Text(<span class="string">"推荐标签内容"</span>),),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">    ),</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<h3 id="Divider组件"><a href="#Divider组件" class="headerlink" title="Divider组件"></a>Divider组件</h3><p>分割线</p>
<h3 id="Drawer组件"><a href="#Drawer组件" class="headerlink" title="Drawer组件"></a>Drawer组件</h3><p><code>Drawer</code>组件中可以设置<code>DrawerHeader</code>组件,设置抽屉头部样式</p>
<p><code>UserAccountsDrawerHeader</code>组件可以快速实现头部组件样式，显示用户头像信息等</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="TextField-文本框组件"><a href="#TextField-文本框组件" class="headerlink" title="TextField 文本框组件"></a><code>TextField</code> 文本框组件</h4><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="flutter-swiper-轮播图"><a href="#flutter-swiper-轮播图" class="headerlink" title="flutter_swiper 轮播图"></a>flutter_swiper 轮播图</h3><h2 id="实践中的踩坑记录"><a href="#实践中的踩坑记录" class="headerlink" title="实践中的踩坑记录"></a>实践中的踩坑记录</h2><h3 id="更换APP图标及名称"><a href="#更换APP图标及名称" class="headerlink" title="更换APP图标及名称"></a>更换APP图标及名称</h3><ul>
<li><p>更换图标 </p>
<p>Android &amp; IOS 图标一键生成网站： <a href="http://icon.wuruihong.com/" target="_blank" rel="noopener">http://icon.wuruihong.com/</a></p>
<p>上传一张原图片后，会自动生成压缩包，下载解压后可以看到Android和IOS两个文件夹</p>
<ul>
<li><p>将Android文件夹的内容复制到<code>项目根目录\android\app\src\main\res</code>,将原文件夹替换</p>
</li>
<li><p>将IOS文件夹的内容复制到<code>项目根目录\ios\Runner\Assets.xcassets</code>下，将原<code>AppIcon.appiconset</code>文件夹替换</p>
</li>
</ul>
</li>
<li><p>更换APP名称</p>
<ul>
<li><p>Android名称： 打开<code>项目根目录\android\app\src\main</code>文件夹下的<code>AndroidManifest.xml</code>文件，修改<code>android:label</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"io.flutter.app.FlutterApplication"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"聖巡"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/LaunchTheme"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustResize"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- This keeps the window background of the activity showing</span></span><br><span class="line"><span class="comment">             until Flutter renders its first frame. It can be removed if</span></span><br><span class="line"><span class="comment">             there is no splash screen (such as the default splash screen</span></span><br><span class="line"><span class="comment">             defined in @style/LaunchTheme). --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"io.flutter.app.android.SplashScreenUntilFirstFrame"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>IOS名称： 打开<code>项目根目录\ios\Runner</code>下的<code>info.plist</code>文件，修改<code>dict.String</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleDevelopmentRegion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>$(DEVELOPMENT_LANGUAGE)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleExecutable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>$(EXECUTABLE_NAME)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>$(PRODUCT_BUNDLE_IDENTIFIER)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleInfoDictionaryVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>6.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>聖巡<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundlePackageType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>APPL<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleShortVersionString<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>$(FLUTTER_BUILD_NAME)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleSignature<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>????<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>$(FLUTTER_BUILD_NUMBER)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>LSRequiresIPhoneOS<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UILaunchStoryboardName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>LaunchScreen<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIMainStoryboardFile<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UISupportedInterfaceOrientations<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationPortrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationLandscapeLeft<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationLandscapeRight<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UISupportedInterfaceOrientations~ipad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationPortrait<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationPortraitUpsideDown<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationLandscapeLeft<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>UIInterfaceOrientationLandscapeRight<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIViewControllerBasedStatusBarAppearance<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>此命名规范来自Dart官方网站： <code>https://dart.dev/guides/language/effective-dart/style</code></p>
<p>Dart中的命名方式有三种： <code>UpperCamelCase</code> 首字母大写(包括第一个字母)的驼峰式、<code>lowerCamelCase</code>首字母大写，第一个字母小写的驼峰式、<code>lowercase_with_underscores</code>带有下划线的小写字母</p>
<ol>
<li><p><code>Classes, enums, typedefs, and type parameters should capitalize the first letter of each word (including the first word), and use no separators.</code></p>
<p> 类名、枚举、<code>typedefs</code>(这啥？)、泛型参数采用<code>UpperCamelCase</code></p>
</li>
<li><p><code>DO name libraries, packages, directories, and source files using lowercase_with_underscores.</code></p>
<p>库名、包名、文件夹名、文件名采用<code>lowercase_with_underscores</code>(小写字母+下划线)</p>
</li>
<li><p><code>DO name import prefixes using lowercase_with_underscores.</code></p>
<p>重命名导入的包时，采用<code>lowercase_with_underscores</code>(小写字母+下划线)</p>
</li>
<li><p><code>DO name other identifiers using lowerCamelCase.</code></p>
<p>命名其他时采用<code>lowerCamelCase</code></p>
</li>
<li><p><code>PREFER using lowerCamelCase for constant names.</code></p>
<p>最好使用<code>lowerCamelCase</code>来命名常量</p>
</li>
</ol>
<h3 id="嵌入地图"><a href="#嵌入地图" class="headerlink" title="嵌入地图"></a>嵌入地图</h3><p>我为啥一上来就用了个这么虐心的组件？？？o(╥﹏╥)o</p>
<h4 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h4><p><code>amap_base_flutter</code>插件可以实现定位、简单的地图展示、导航、搜索等功能</p>
<p>Android版：</p>
<ul>
<li><p>在<code>pubspec.yaml</code>文件中引入依赖，无需添加版本号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  amap_location:</span><br></pre></td></tr></table></figure>
</li>
<li><p>至高德地图<code>https://lbs.amap.com/api/android-sdk/guide/create-project/get-key</code>注册<code>API key</code></p>
</li>
<li><p>修改 <code>项目目录/app/build.gradle</code> 在<code>android/defaultConfig</code>节点修改<code>manifestPlaceholders</code>,新增百度地图AK配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  .... 你的代码</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">      .....</span><br><span class="line">      manifestPlaceholders = [</span><br><span class="line">              AMAP_KEY : &quot;你的高德地图AK&quot;, // 高德地图AK</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h3><ol>
<li><p>引入<code>dio</code>包</p>
<p> <code>dio</code>是一个强大的<code>Dart Http</code>请求库，支持<code>Restful API</code>、<code>FormData</code>、拦截器、请求取消、Cookie管理、文件上传/下载、超时、自定义适配器等…</p>
<p> 在<code>pubspec.yaml</code>文件中添加依赖:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  dio:</span> <span class="string">^3.x.x</span>  <span class="string">//</span> <span class="string">请使用pub上3.0.0分支的最新版本(本人用的是3.0.5)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>常见报错信息：</p>
<ul>
<li><p><code>SocketException: Failed host lookup: &#39;www.baidu.com&#39; (OS Error: No address associated with hostnam, errno = 7)</code></p>
<p>  测试DIO做请求时，写了个方法get百度首页数据，返回此报错，结果发现是手机没联网导致，emmm…</p>
</li>
<li><p><code>Unhandled Exception: DioError [DioErrorType.RESPONSE]: Http status error [400]</code></p>
<ul>
<li><p>状态为400可能有很多原因，此为碰到的其中之一</p>
<p><code>post</code>发送请求时一直没反应，状态为400，后来终于发现是封装方法是出现问题</p>
<p><code>get</code>方法： </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>(url, &#123;data, options, cancelTocken&#125;) <span class="keyword">async</span>&#123;</span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(url, queryParameters: data, options: options, cancelToken: cancelToken);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get success---------<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get success---------<span class="subst">$&#123;response.data&#125;</span>'</span>);</span><br><span class="line">      </span><br><span class="line">  &#125; on DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get error---------$e'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>post</code>方法：</p>
  <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">post(url, &#123;data, options, cancelToken&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = <span class="keyword">await</span> dio.post(url, data: data, options: options, cancelToken: cancelToken);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get success---------<span class="subst">$&#123;response.statusCode&#125;</span>'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get success---------<span class="subst">$&#123;response.data&#125;</span>'</span>);</span><br><span class="line">  &#125; on DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'get error---------$e'</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> response.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>get</code>方法中，接收参数的属性是<code>queryParameters</code>,<code>post</code>方法中，接收参数的属性是<code>data</code>,一开始将<code>post</code>方法中接收参数的属性写成了<code>queryParameters</code>,结果做请求时一直毫无反应，debug进去发现报了<code>Http status error [400]</code>的错。坑！</p>
</li>
</ul>
</li>
<li><p><code>DioError [DioErrorType.RESPONSE]: Http status error [415]</code></p>
</li>
</ul>
<h2 id="报错集锦"><a href="#报错集锦" class="headerlink" title="报错集锦"></a>报错集锦</h2><ul>
<li><p><code>* Error running Gradle: ProcessException: Process &quot;D:\vscodework\yardApp\android\gradlew.bat&quot; exited abnormally: Configure project :app</code></p>
<p>八成是被墙了，下载不下来依赖，在环境变量中配置一下两个参数就解决了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line"></span><br><span class="line">PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br></pre></td></tr></table></figure>
<p>环境变量配置好后需要重启电脑才能生效</p>
</li>
</ul>
<hr>
<p>参考资料：</p>
<ol>
<li><p>Flutter官网： <a href="https://flutter.dev/" target="_blank" rel="noopener">https://flutter.dev/</a></p>
</li>
<li><p>技术胖教学视频： <a href="https://www.bilibili.com/watchlater/#/av35800108/p1" target="_blank" rel="noopener">https://www.bilibili.com/watchlater/#/av35800108/p1</a></p>
</li>
<li><p>Material官网： <a href="https://material.io/" target="_blank" rel="noopener">https://material.io/</a></p>
</li>
<li><p>Flutter教程_2019年最新Flutter 零基础入门实战教程:  <a href="https://www.bilibili.com/watchlater/?spm_id_from=666.19.b_62696c692d6865616465722d6d.17#/av53072584/p17" target="_blank" rel="noopener">https://www.bilibili.com/watchlater/?spm_id_from=666.19.b_62696c692d6865616465722d6d.17#/av53072584/p17</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>framework,Flutter</category>
      </categories>
      <tags>
        <tag>Computer Language</tag>
        <tag>UI</tag>
        <tag>framework</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
</search>
