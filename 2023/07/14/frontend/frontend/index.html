
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>前端基础 - 奇天大圣的蟠桃园</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="记录当下！,事件循环浏览器的进程模型进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程
每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意
线程： 运行代码的“人”称之为,"> 
    <meta name="author" content="Aurelia"> 
    <link rel="alternative" href="atom.xml" title="奇天大圣的蟠桃园" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="前端基础 - 奇天大圣的蟠桃园">
    <meta name="twitter:description" content="记录当下！,事件循环浏览器的进程模型进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程
每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意
线程： 运行代码的“人”称之为,">
    
    
    
    
    <meta property="og:site_name" content="奇天大圣的蟠桃园">
    <meta property="og:type" content="object">
    <meta property="og:title" content="前端基础 - 奇天大圣的蟠桃园">
    <meta property="og:description" content="记录当下！,事件循环浏览器的进程模型进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程
每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意
线程： 运行代码的“人”称之为,">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">奇天大圣的蟠桃园</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://garden.aezo.cn"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">前端基础</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">前端基础</h1>
        <div class="stuff">
            <span>七月 14, 2023</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Computer-Language/">Computer Language</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/frontend/">frontend</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/js/">js</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><p>进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程</p>
<p>每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意</p>
<p>线程： 运行代码的“人”称之为“线程”，一个进程至少有一个线程，所以在进程开启之后会主动创建一个线程来运行代码，该线程称之为主线程。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><p>浏览器是一个多进程多线程的应用程序。</p>
<p>浏览器内部工作机器复杂，为了避免互相影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<p>谷歌浏览器 –&gt; 点击更多 –&gt; 选择更多工具 –&gt; 任务管理器</p>
<p>能看到浏览器的多个进程，即使一个网页都没打开也会有很多进程</p>
<p>浏览器中的主要进程包括：浏览器进程、网络进程、渲染进程</p>
<p>浏览器进程： 负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
<p>浏览器进程负责的页面展示指的是浏览器本身的界面，如标签页、前进后退刷新按钮、导航栏等的展示</p>
<p>网络进程： 负责加载网络资源</p>
<p>渲染进程：</p>
<p>渲染进程启动后会开启一个渲染主线程，主线程负责执行HTML、CSS、JS代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不互相影响。</p>
<p><strong>将来此默认模式可能会有所改变，有可能会变成一个站点开启一个进程，而不是一个标签页一个进程，但目前还是一个标签页一个进程的模式，具体可以参见chrome官方文档说明</strong></p>
<p><strong>最新版的chrome(114.0.5735.199)已经有所改动，新增了一个性能模块，需要自动开启，开启后会自动释放已有一段时间未使用的标签页占用的内存，以让使用中的标签页和其他应用获得更多计算机资源，并让 Chrome 保持快速运行。可在“设置”页面中管理省内存模式以及选择要释放哪些网站占用的内存</strong></p>
<h2 id="渲染主线程是如何工作的"><a href="#渲染主线程是如何工作的" class="headerlink" title="渲染主线程是如何工作的"></a>渲染主线程是如何工作的</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li><p>解析HTML</p>
</li>
<li><p>解析CSS</p>
</li>
<li><p>计算样式</p>
</li>
<li><p>布局</p>
</li>
<li><p>处理图层</p>
</li>
<li><p>每秒把页面画60次</p>
</li>
<li><p>执行全局js代码</p>
</li>
<li><p>执行事件处理函数</p>
</li>
<li><p>执行计时器的回调函数</p>
</li>
</ul>
<p>渲染主线程调度任务：排队</p>
<p>将需要执行的任务放在消息队列中进行排队</p>
<ol>
<li><p>最开始的时候，渲染总线程会进入一个无限循环</p>
</li>
<li><p>每一次循环会检查消息队列中是否有任务存在。如果有就取出第一个任务执行，执行完一个后进入下一次循环；如果没有则进入休眠状态</p>
</li>
<li><p>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒继续循环拿取任务</p>
</li>
</ol>
<p>以上整个过程被称为事件循环(event loop)，又叫做消息循环（message loop）</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>代码在执行过程中会遇到一些无法立即处理的任务，如：</p>
<ul>
<li><p>计时完成后需要执行的任务： setTimeout setInterval</p>
</li>
<li><p>网络通信完成后需要执行的任务： XHR、Fetch</p>
</li>
<li><p>用户操作后需要执行的任务： addEventListener</p>
</li>
</ul>
<p>如果让渲染主线程等待这些任务执行完，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死</p>
<h2 id="JS为何会阻碍渲染"><a href="#JS为何会阻碍渲染" class="headerlink" title="JS为何会阻碍渲染"></a>JS为何会阻碍渲染</h2><p>因为JS和渲染都在浏览器的渲染主线程中，执行JS渲染就需要等着，执行渲染，JS就要等着</p>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>任务没有优先级，在消息队列中先进先出</p>
<p><strong>但是消息队列是有优先级的</strong></p>
<ul>
<li><p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行</p>
</li>
<li><p>浏览器必须准备好一个微队列(microtask queue)，微队列中的任务优先所有其他任务队列</p>
</li>
</ul>
<p>Chrome的实现中，至少包含一下队列：</p>
<ul>
<li><p>延时队列： 用于存放计时器到达后的回调任务，优先级 中</p>
</li>
<li><p>交互队列： 用于存放用户操作后产生的事件处理任务，优先级 高</p>
</li>
<li><p>微队列： 用户存放需要最快执行的任务，优先级 最高</p>
</li>
</ul>
<p>添加任务到微队列的主要方式是使用Promise、MutationObserver</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(函数)</span><br></pre></td></tr></table></figure>
<p>以下代码的执行顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的顺序应该是2， 1</p>
<p>以下代码的执行顺序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出顺序应该是3 2 1</p>
<p>console.log(3)属于全局函数，所以是先执行，console.log(2)在微队列，优先级高于console.log(1)的延时队列</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="如何理解JS的异步"><a href="#如何理解JS的异步" class="headerlink" title="如何理解JS的异步"></a>如何理解JS的异步</h3><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。<br>渲染主线程承担着诸多工作，页面渲染、执行js都在其中运行。<br>如果使用同步的方式，极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法执行。<br>这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法即使更新，给用户造成卡死的现象。</p>
<p>所以浏览器采用异步的方式来避免。<br>具体做法是，当某些任务，如计时器、网络、事件监听，主线程将任务交给其他线程处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程进行调用执行。</p>
<p>异步模式下浏览器永不阻塞，从而最大限度保障了单线程的执行。</p>
<h3 id="阐述下JS的事件循环"><a href="#阐述下JS的事件循环" class="headerlink" title="阐述下JS的事件循环"></a>阐述下JS的事件循环</h3><p>事件循环又叫消息循环，是浏览器渲染主线程的工作方式。<br>在Chrome源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，其他线程只需要在合适的时候将任务加入到队列末尾即可</p>
<p>过去把消息队列简单分为虹队列和微队列，这种说法已经无法满足现在的复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据W3C官方的解释，每个任务具有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高优先级，必须优先调度执行</p>
<h3 id="JS中的计时器能做到精确计时吗？为什么？"><a href="#JS中的计时器能做到精确计时吗？为什么？" class="headerlink" title="JS中的计时器能做到精确计时吗？为什么？"></a>JS中的计时器能做到精确计时吗？为什么？</h3><p>不能。</p>
<ul>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又会带来偏差</li>
</ul>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>绘制Paint –&gt; 分块Tiling –&gt; 光栅化 Raster –&gt; 画 Draw</p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>将每个块变成位图，优先处理靠近视口的块  </p>
<p>此过程会使用GPU进行加速</p>
<h2 id="画"><a href="#画" class="headerlink" title="画"></a>画</h2><p>合成线程及选出每个位图在屏幕上的位置，交给GPU进行最终呈现。 GPU是浏览器的进程，不是显卡的进程</p>
<p>此部分会进行transform等变形属性的计算，这就是transform效率高的根本原因，因为它发生在合成线程，与渲染主线程无关</p>
<p>合成线程会把quad交给渲染主线程</p>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="浏览器是如何渲染页面的"><a href="#浏览器是如何渲染页面的" class="headerlink" title="浏览器是如何渲染页面的"></a>浏览器是如何渲染页面的</h3><h3 id="什么是reflow"><a href="#什么是reflow" class="headerlink" title="什么是reflow"></a>什么是reflow</h3><p>reflow的本质是重新计算Layout树。</p>
<p>当进行了会影响布局树的操作之后，需要重新计算布局树，会引发layout.</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当JS代码全部完成后在进行统一计算，所以改动属性造成的reflow是异步完成的。</p>
<p>当JS获取布局属性时就有可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复的权衡下，最终决定获取属性立即reflow。</p>
<h3 id="什么是repaint"><a href="#什么是repaint" class="headerlink" title="什么是repaint"></a>什么是repaint</h3><p>repaint本质上是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式之后，就需要重新计算，会引发repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint。</p>
<h3 id="为什么transform的效率高"><a href="#为什么transform的效率高" class="headerlink" title="为什么transform的效率高"></a>为什么transform的效率高</h3><p>因为transform既不会影响布局也不会影响绘制指令，它只会影响渲染流程的最后一个Draw阶段。</p>
<p>由于draw阶段在合成线程中，所以transform的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌也不会影响transform的变化</p>
<h1 id="实战——歌词滚动效果"><a href="#实战——歌词滚动效果" class="headerlink" title="实战——歌词滚动效果"></a>实战——歌词滚动效果</h1><p><code>transition</code>表示变化过渡时间，只针对数值类的属性有效，比如颜色、宽高、透明度等</p>
<p>JS 先做数据逻辑，再做界面逻辑，最后才是事件逻辑</p>
<h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>得到属性描述符：</p>
<p><code>Object.getOwnPropertyDescriptor(对象, 对象的属性属性名称)</code></p>
<p>设置属性描述符：</p>
<p><code>Object.defineProperty(对象, 对象的属性名, {需要设置的属性：属性对应的属性值})</code></p>
<p><code>Object.freeze(obj)</code> 冻结对象，对象冻结后不能修改和增删属性</p>
<p><code>obj = {...obj}</code> 克隆对象</p>
<p><code>obj.seal(obj)</code> 密封对象</p>
<p>属性描述符有：</p>
<ul>
<li><p><code>value</code> 属性值</p>
</li>
<li><p><code>writable</code> 是否可以重写</p>
</li>
<li><p><code>enumerable</code> 是否可遍历</p>
</li>
<li><p><code>configurable</code> 是否可修改描述符本身，设置为false之后就不能再次修改属性符了</p>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>前端学习路线： h5+css3 –&gt; es6 -&gt; 网络 –&gt; 第三方库 –&gt; 工程化 –&gt; Vue react等框架 –&gt; …</p>
<p>Vue的data中是界面数据</p>
<p>数据响应式： 数据的变化会引发界面的更新，其本质是当数据变化时，会自动运行相关函数</p>
<p>Vue中的computed表示计算属性，本身不存在，要靠计算出来</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
