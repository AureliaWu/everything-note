<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇天大圣的蟠桃园</title>
  
  <subtitle>保持饥饿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://garden.aezo.cn/"/>
  <updated>2023-11-16T09:38:50.674Z</updated>
  <id>http://garden.aezo.cn/</id>
  
  <author>
    <name>Aurelia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Uniapp</title>
    <link href="http://garden.aezo.cn/2023/11/09/frameworks/uniapp/"/>
    <id>http://garden.aezo.cn/2023/11/09/frameworks/uniapp/</id>
    <published>2023-11-09T06:20:20.890Z</published>
    <updated>2023-11-16T09:38:50.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uniapp开发安卓APP"><a href="#Uniapp开发安卓APP" class="headerlink" title="Uniapp开发安卓APP"></a>Uniapp开发安卓APP</h1><h2 id="离线缓存与数据持久化"><a href="#离线缓存与数据持久化" class="headerlink" title="离线缓存与数据持久化"></a>离线缓存与数据持久化</h2><p>离线缓存： 将网络请求的数据缓存到本地，用户在没有网络链接的情况下可以继续访问已缓存的数据。<br>Uniapp使用<code>uni.setStorageSync</code>和<code>uni.getStorageSync</code>来实现</p><blockquote><p>uni-app的Storage在不同端的实现不同, App端为原生的plus.storage，无大小限制，不是缓存，是持久化的</p></blockquote><h1 id="Uniapp离线打包安卓APK"><a href="#Uniapp离线打包安卓APK" class="headerlink" title="Uniapp离线打包安卓APK"></a>Uniapp离线打包安卓APK</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="一些下载"><a href="#一些下载" class="headerlink" title="一些下载"></a>一些下载</h3><ol><li>下载安装<code>Android Studio</code>,<a href="https://developer.android.google.cn/studio/index.html" target="_blank" rel="noopener">下载地址</a></li><li>下载HbuilderX最新的SDK,<a href="https://nativesupport.dcloud.net.cn/AppDocs/download/android.html#" target="_blank" rel="noopener">下载地址</a></li></ol><h3 id="HbuilderX离线打包"><a href="#HbuilderX离线打包" class="headerlink" title="HbuilderX离线打包"></a>HbuilderX离线打包</h3><ol><li><code>HbuilderX</code>界面选择<code>发行 -&gt; 原生APP-本地打包 -&gt; 生成本地打包APP资源</code></li><li>打包完成后会在控制台输出打包生成的文件地址<code>xxxx/__UNI__XXX/xxx</code>,<code>__UNI__XXX</code>是本项目对应的Appid</li><li>将下载的HbuilderX最新的SDK解压，使用<code>Android Studio</code>打开包中的<code>HBuilder-Integrate-AS</code>文件夹</li><li>将<code>HBuilder-Integrate-AS\simpleDemo\src\main\assets\apps\</code>下的所有文件删除，替换成步骤2中生成的整个<code>__UNI__XXX/</code>文件夹</li><li>将<code>src/main/assets/data/dcloud_control.xml</code>中的<code>APPID</code>修改为上面的<code>__UNI__XXX</code></li><li><code>Android Studio</code>界面选择<code>Build -&gt; Generate Signed Bundle/APK...</code>,在跳出的弹窗页面选择APK,选择<code>Next</code>,进入下一步</li><li>首次生成选择<code>Create new ...</code>,<code>key store path</code>要在<code>simpleDemo</code>文件夹下，可以直接放在根目录；密码和别名都可以自定义，点击<code>ok</code>开始生成签名文件<br> 注：<ul><li>此步骤是在生成签名文件，由于下载的Demo包是Gradle，可能会出现生成签名出错的问题，目前遇到的基本都是提示<code>invalid keystore format</code></li><li><code>invalid keystore format</code>很可能是因为项目本身的JDK版本和电脑环境变量的JDK版本不一致，将两者调成JDK12是可以运行的</li></ul></li><li>在<code>/simpleDemo/build.gradle</code>中配置信息，<code>keyAlias</code>为刚刚填写的key的别名，<code>keypassword</code>为自定义的密码，<code>StorageFile</code>为刚刚生成的文件名</li><li>查看刚生成的签名文件(此处以<code>test.keystore</code>为例)的签名，进入到<code>test.keystore</code>文件夹，在命令行输入<code>keytool -list -v -keystore test.keystore</code></li><li>步骤9中查看的签名可能只会有<code>SHA1</code>和<code>SHA256</code>两种，但实际配置时还需要<code>MD5</code>签名，则只能使用<a href="#jump">另一种方法</a>查看</li><li>登录UniAPP开发者中心管理应用，进入相应的应用，选择<code>各平台信息</code>标签，如果没有则自己新建一个</li><li>配置信息中的包名需要填写在<code>/simpleDemo/build.gradle</code>文件的<code>applicationId</code>中</li><li>填写步骤10中的<code>MD5</code>信息、<code>SHA1</code>信息、<code>SHA256</code>信息，提交后会生成对应的APPKey</li><li>将生成的APPKey填入<code>src/main/AndroidManifest.xml</code>的<code>android:value</code></li><li><code>\src\main\res\drawable</code>文件夹下的<code>icon.png</code>、<code>push.png</code>、<code>splash.png</code>分别对应APP的logo、消息推送logo、启动页图片，可改成自定义</li><li>在<code>\src\main\res\values\strings.xml</code>中修改APP的名称</li><li><code>Android Studio</code>界面选择<code>Build -&gt; Build Bundle(s)/APK(s) -&gt; Build APK(s)</code>开始打包</li><li>打包后的文件位置在<code>\build\outputs\apk\debug\simpleDemo-debug.apk</code>(<code>\release\simpleDemo-release.apk</code>不是自定义的apk包，为啥？？？有待继续研究)</li></ol><h4 id="查看签名文件的SHA1-SHA256-MD5信息"><a href="#查看签名文件的SHA1-SHA256-MD5信息" class="headerlink" title="查看签名文件的SHA1 SHA256 MD5信息"></a><span id="jump">查看签名文件的<code>SHA1</code> <code>SHA256</code> <code>MD5</code>信息</span></h4><p>生成<code>test.keystore</code>文件后，在<code>Android Studio</code>的<code>HBuilder-Integrate-AS</code>项目根目录下打开终端，输入<code>./gradlew signingReport</code>命令</p><p>正常情况下能获取到<code>SHA1</code> <code>SHA256</code> <code>MD5</code>信息，如果报错则查看jdk版本是否一致</p><p><strong>如果修改过环境变量，需要重启<code>Android Studio</code>再操作</strong></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol><li><a href="https://blog.csdn.net/qq_26282869/article/details/127012224" target="_blank" rel="noopener">uniapp离线打包安卓APP全过程</a></li><li><a href="https://nativesupport.dcloud.net.cn/AppDocs/download/android.html#" target="_blank" rel="noopener">HBuilderX离线SDK (Android)</a></li><li><a href="https://blog.csdn.net/m0_62059090/article/details/127425912" target="_blank" rel="noopener">Android 连接第三方模拟器</a></li><li><a href="https://blog.csdn.net/Ysmooth_Alone/article/details/130176427" target="_blank" rel="noopener">uniapp离线打包在Android Studio创建的jsk证书无法获取MD5的问题</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uniapp开发安卓APP&quot;&gt;&lt;a href=&quot;#Uniapp开发安卓APP&quot; class=&quot;headerlink&quot; title=&quot;Uniapp开发安卓APP&quot;&gt;&lt;/a&gt;Uniapp开发安卓APP&lt;/h1&gt;&lt;h2 id=&quot;离线缓存与数据持久化&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="framework,Uniapp" scheme="http://garden.aezo.cn/categories/framework-Uniapp/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="framework" scheme="http://garden.aezo.cn/tags/framework/"/>
    
      <category term="Uniapp" scheme="http://garden.aezo.cn/tags/Uniapp/"/>
    
  </entry>
  
  <entry>
    <title>Python3</title>
    <link href="http://garden.aezo.cn/2023/07/21/python/python%E5%85%A5%E9%97%A8/"/>
    <id>http://garden.aezo.cn/2023/07/21/python/python入门/</id>
    <published>2023-07-21T10:08:00.289Z</published>
    <updated>2023-07-21T10:08:00.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在Mac上安装Python3"><a href="#在Mac上安装Python3" class="headerlink" title="在Mac上安装Python3"></a>在Mac上安装Python3</h2><p>方法一： 从Python官网下载Python3 <code>https://www.python.org/downloads/</code>，下载完成后双击运行并安装</p><p>方法二： 如果安装了Homebrew,直接通过命令<code>brew install python3</code>安装即可,若要指定版本，使用命令<code>brew install --build-from-source python@3.8</code></p><h3 id="使用Homebrew安装可能出的错"><a href="#使用Homebrew安装可能出的错" class="headerlink" title="使用Homebrew安装可能出的错"></a>使用Homebrew安装可能出的错</h3><p>Mac升级为macOS Big Sur系统11.1之后，需要先升级Homebrew，否则使用<code>brew</code>命令时会报错 <code>Version value must be a string; got a NilClass ()</code></p><p>Homebrew升级命令： <code>brew update-reset</code></p><p>查看Homebrew版本命令： <code>brew --version</code></p><p>查看python3版本的命令： <code>python3 --version</code></p><h1 id="Mac直接运行-py文件"><a href="#Mac直接运行-py文件" class="headerlink" title="Mac直接运行.py文件"></a>Mac直接运行<code>.py</code>文件</h1><ol><li>在<code>.py</code>文件的第一行加特殊的注释: <code>#!/usr/bin/env python3</code></li><li>通过命令行给文件以执行权限 <code>chmod a+x xx.py</code></li></ol><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><ul><li>以<code>#</code>开头的语句是注释，每一行都是一个语句，当语句以<code>:</code>冒号结尾时，缩进的语句视为代码块</li><li>Python程序大小写敏感</li></ul><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数、浮点数、字符串、布尔值、空值、列表、字典、自定义数据类型</p><ul><li>使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li><li>使用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li><li>空值是Python里的一个特殊的值，用<code>None</code>表示</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Python中，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而而且可以是不同类型的变量。</p><p>这种本身类型不固定的语言称之为<code>动态语言</code>,与之对应的是<code>静态语言</code>静态语言在定义变量时必须指定变量类型，如Java语言。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Python源代码是一个文本文件，当源代码中包含中文的时候，保存源代码时就务必要指定保存为UTF-8编码；当Python解释器读取源代码时，为了让它按UTF-8编码读取，通常在文件开头写上以下两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略此注释</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则在源代码中写的中文输出可能会有乱码</p><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>Python中采用的格式化方式和C语言是一致的，用<code>%</code>实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">'hello, %s' % 'world' --&gt; hello, world</span><br><span class="line"></span><br><span class="line">'Hi, %s, you have $%d.' % ('Michael', 10000) --&gt; Hi, Michael, you have $10000.</span><br></pre></td></tr></table></figure><ul><li><code>%s</code>表示用字符串替换</li><li><code>%d</code>表示用整数替换</li><li><code>%f</code>表示用浮点数替换</li><li><code>%x</code>表示用十六进制整数替换</li></ul><p><strong>格式化整数和浮点数还可以指定是否补0和整数与小数的位数</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">print('%2d-%02d' % (3,1)) --&gt; '3-01'</span><br><span class="line"></span><br><span class="line">print('%.2f' % 3.1415926) --&gt; '3.14'</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表： list</p><p>list是一个有序的集合，可以随时添加和删除其中的元素</p><p>list.len() 获得list中元素的个数</p><p>list[index] 访问每一个指定位置的元素</p><p>list.append(xx) 将元素追加到list末尾</p><p>list.insert(index, xx) 将元素插入到索引号为index的位置</p><p>list.pop() 删除list末尾的元素</p><p>list.pop(index) 删除指定位置的元素</p><p><strong>list里面的元素数据类型可以不同，也可以是另一个list</strong></p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种有序列表叫元组： tuple</p><p>tuple和list非常类似，但是tuple一旦初始化就不能修改，没有<br><code>append()</code> <code>insert()</code>这样的方法</p><p><code>t = ()</code> 定义一个空的tuple</p><p>list和tuple是Python内置的有序组合，一个可变一个不可变。</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><code>if: ... elif: ... else: ...</code></p><p><code>elif</code>是<code>else if</code> 的缩写</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for...in</code> 依次把list或tuple中的每个元素迭代出来</p><p><code>range()</code>函数可以申请改成一个整数序列，<code>range(5)</code>表示生成的序列是从0开始小于5的整数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(5)) --&gt; [0,1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>只要满足条件就会不断循环</p><p>使用<code>break</code>可提前退出循环</p><p>使用<code>continue</code>可跳过当前循环直接开始下次循环</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Python内置了字典：<code>dict</code>，全称<code>dictionary</code>,使用键值对存储，具有极快的查找速度</p><p>如果key不存在，dict就会报错，为避免key不存在的错误，有两种办法：</p><ul><li>通过使用<code>xx in dict</code>判断key是否存在</li><li>通过dict.get(xx)，如果key不存在可以返回None或者自己指定的value</li></ul><p>返回None的时候，Python的交互环境不显示结果</p><p>使用dict.pop(key)会将key对应的键值对一起删除</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。set中没有重复的key.</p><p>要创建一个set，需要提供一个list作为输入集合，重复元素在set中会被自动过滤</p><p>set.add(key) 添加元素到set中，可以重复添加，但是不会有效果</p><p>set.remove(key) 删除元素</p><p>set可以看成是数学意义上的无需和无重复元素的集合</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数就是最基本的一种代码抽象的方式</p><p>Python内置了很多函数可以直接调用，使用函数名和参数就能直接调用函数。</p><p>abs() 求绝对值函数</p><p>max() 接收任意多个参数并返回最大的那个</p><p>int() 把其他数据类型转换成整数</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>使用<code>def</code>语句定义一个函数，依次写出函数名、括号、括号中的参数、冒号，然后在缩进块在红编写函数体，函数的返回值用<code>return</code>语句返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p>如果想定义一个什么也不做的空函数，可以用pass语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>pass</code>可以用来作为一个占位符让代码先运行起来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h2 id=&quot;在Mac上安装Python3&quot;&gt;&lt;a href=&quot;#在Mac上安装Python3&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="others" scheme="http://garden.aezo.cn/categories/others/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="basic" scheme="http://garden.aezo.cn/tags/basic/"/>
    
      <category term="Python" scheme="http://garden.aezo.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://garden.aezo.cn/2023/07/14/frontend/frontend/"/>
    <id>http://garden.aezo.cn/2023/07/14/frontend/frontend/</id>
    <published>2023-07-14T02:36:54.000Z</published>
    <updated>2023-07-19T09:55:51.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><p>进程： 程序运行需要自己专属的内存空间，这块内存空间可以简单理解成为进程</p><p>每个应用至少有一个进程，进程之间相互独立，即使需要通信也需要双方同意</p><p>线程： 运行代码的“人”称之为“线程”，一个进程至少有一个线程，所以在进程开启之后会主动创建一个线程来运行代码，该线程称之为主线程。如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><p>浏览器是一个多进程多线程的应用程序。</p><p>浏览器内部工作机器复杂，为了避免互相影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p>谷歌浏览器 –&gt; 点击更多 –&gt; 选择更多工具 –&gt; 任务管理器</p><p>能看到浏览器的多个进程，即使一个网页都没打开也会有很多进程</p><p>浏览器中的主要进程包括：浏览器进程、网络进程、渲染进程</p><p>浏览器进程： 负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p><p>浏览器进程负责的页面展示指的是浏览器本身的界面，如标签页、前进后退刷新按钮、导航栏等的展示</p><p>网络进程： 负责加载网络资源</p><p>渲染进程：</p><p>渲染进程启动后会开启一个渲染主线程，主线程负责执行HTML、CSS、JS代码。</p><p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不互相影响。</p><p><strong>将来此默认模式可能会有所改变，有可能会变成一个站点开启一个进程，而不是一个标签页一个进程，但目前还是一个标签页一个进程的模式，具体可以参见chrome官方文档说明</strong></p><p><strong>最新版的chrome(114.0.5735.199)已经有所改动，新增了一个性能模块，需要自动开启，开启后会自动释放已有一段时间未使用的标签页占用的内存，以让使用中的标签页和其他应用获得更多计算机资源，并让 Chrome 保持快速运行。可在“设置”页面中管理省内存模式以及选择要释放哪些网站占用的内存</strong></p><h2 id="渲染主线程是如何工作的"><a href="#渲染主线程是如何工作的" class="headerlink" title="渲染主线程是如何工作的"></a>渲染主线程是如何工作的</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li><p>解析HTML</p></li><li><p>解析CSS</p></li><li><p>计算样式</p></li><li><p>布局</p></li><li><p>处理图层</p></li><li><p>每秒把页面画60次</p></li><li><p>执行全局js代码</p></li><li><p>执行事件处理函数</p></li><li><p>执行计时器的回调函数</p></li></ul><p>渲染主线程调度任务：排队</p><p>将需要执行的任务放在消息队列中进行排队</p><ol><li><p>最开始的时候，渲染总线程会进入一个无限循环</p></li><li><p>每一次循环会检查消息队列中是否有任务存在。如果有就取出第一个任务执行，执行完一个后进入下一次循环；如果没有则进入休眠状态</p></li><li><p>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒继续循环拿取任务</p></li></ol><p>以上整个过程被称为事件循环(event loop)，又叫做消息循环（message loop）</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>代码在执行过程中会遇到一些无法立即处理的任务，如：</p><ul><li><p>计时完成后需要执行的任务： setTimeout setInterval</p></li><li><p>网络通信完成后需要执行的任务： XHR、Fetch</p></li><li><p>用户操作后需要执行的任务： addEventListener</p></li></ul><p>如果让渲染主线程等待这些任务执行完，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死</p><h2 id="JS为何会阻碍渲染"><a href="#JS为何会阻碍渲染" class="headerlink" title="JS为何会阻碍渲染"></a>JS为何会阻碍渲染</h2><p>因为JS和渲染都在浏览器的渲染主线程中，执行JS渲染就需要等着，执行渲染，JS就要等着</p><h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>任务没有优先级，在消息队列中先进先出</p><p><strong>但是消息队列是有优先级的</strong></p><ul><li><p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行</p></li><li><p>浏览器必须准备好一个微队列(microtask queue)，微队列中的任务优先所有其他任务队列</p></li></ul><p>Chrome的实现中，至少包含一下队列：</p><ul><li><p>延时队列： 用于存放计时器到达后的回调任务，优先级 中</p></li><li><p>交互队列： 用于存放用户操作后产生的事件处理任务，优先级 高</p></li><li><p>微队列： 用户存放需要最快执行的任务，优先级 最高</p></li></ul><p>添加任务到微队列的主要方式是使用Promise、MutationObserver</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(函数)</span><br></pre></td></tr></table></figure><p>以下代码的执行顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>输出的顺序应该是2， 1</p><p>以下代码的执行顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出顺序应该是3 2 1</p><p>console.log(3)属于全局函数，所以是先执行，console.log(2)在微队列，优先级高于console.log(1)的延时队列</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="如何理解JS的异步"><a href="#如何理解JS的异步" class="headerlink" title="如何理解JS的异步"></a>如何理解JS的异步</h3><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。<br>渲染主线程承担着诸多工作，页面渲染、执行js都在其中运行。<br>如果使用同步的方式，极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法执行。<br>这样一来，一方面会导致繁忙的主线程白白消耗时间，另一方面会导致页面无法即使更新，给用户造成卡死的现象。</p><p>所以浏览器采用异步的方式来避免。<br>具体做法是，当某些任务，如计时器、网络、事件监听，主线程将任务交给其他线程处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程进行调用执行。</p><p>异步模式下浏览器永不阻塞，从而最大限度保障了单线程的执行。</p><h3 id="阐述下JS的事件循环"><a href="#阐述下JS的事件循环" class="headerlink" title="阐述下JS的事件循环"></a>阐述下JS的事件循环</h3><p>事件循环又叫消息循环，是浏览器渲染主线程的工作方式。<br>在Chrome源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，其他线程只需要在合适的时候将任务加入到队列末尾即可</p><p>过去把消息队列简单分为虹队列和微队列，这种说法已经无法满足现在的复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据W3C官方的解释，每个任务具有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高优先级，必须优先调度执行</p><h3 id="JS中的计时器能做到精确计时吗？为什么？"><a href="#JS中的计时器能做到精确计时吗？为什么？" class="headerlink" title="JS中的计时器能做到精确计时吗？为什么？"></a>JS中的计时器能做到精确计时吗？为什么？</h3><p>不能。</p><ul><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又会带来偏差</li></ul><h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>绘制Paint –&gt; 分块Tiling –&gt; 光栅化 Raster –&gt; 画 Draw</p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>将每个块变成位图，优先处理靠近视口的块  </p><p>此过程会使用GPU进行加速</p><h2 id="画"><a href="#画" class="headerlink" title="画"></a>画</h2><p>合成线程及选出每个位图在屏幕上的位置，交给GPU进行最终呈现。 GPU是浏览器的进程，不是显卡的进程</p><p>此部分会进行transform等变形属性的计算，这就是transform效率高的根本原因，因为它发生在合成线程，与渲染主线程无关</p><p>合成线程会把quad交给渲染主线程</p><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="浏览器是如何渲染页面的"><a href="#浏览器是如何渲染页面的" class="headerlink" title="浏览器是如何渲染页面的"></a>浏览器是如何渲染页面的</h3><h3 id="什么是reflow"><a href="#什么是reflow" class="headerlink" title="什么是reflow"></a>什么是reflow</h3><p>reflow的本质是重新计算Layout树。</p><p>当进行了会影响布局树的操作之后，需要重新计算布局树，会引发layout.</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当JS代码全部完成后在进行统一计算，所以改动属性造成的reflow是异步完成的。</p><p>当JS获取布局属性时就有可能造成无法获取到最新的布局信息。</p><p>浏览器在反复的权衡下，最终决定获取属性立即reflow。</p><h3 id="什么是repaint"><a href="#什么是repaint" class="headerlink" title="什么是repaint"></a>什么是repaint</h3><p>repaint本质上是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式之后，就需要重新计算，会引发repaint。</p><p>由于元素的布局信息也属于可见样式，所以reflow一定会引起repaint。</p><h3 id="为什么transform的效率高"><a href="#为什么transform的效率高" class="headerlink" title="为什么transform的效率高"></a>为什么transform的效率高</h3><p>因为transform既不会影响布局也不会影响绘制指令，它只会影响渲染流程的最后一个Draw阶段。</p><p>由于draw阶段在合成线程中，所以transform的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌也不会影响transform的变化</p><h1 id="实战——歌词滚动效果"><a href="#实战——歌词滚动效果" class="headerlink" title="实战——歌词滚动效果"></a>实战——歌词滚动效果</h1><p><code>transition</code>表示变化过渡时间，只针对数值类的属性有效，比如颜色、宽高、透明度等</p><p>JS 先做数据逻辑，再做界面逻辑，最后才是事件逻辑</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>得到属性描述符：</p><p><code>Object.getOwnPropertyDescriptor(对象, 对象的属性属性名称)</code></p><p>设置属性描述符：</p><p><code>Object.defineProperty(对象, 对象的属性名, {需要设置的属性：属性对应的属性值})</code></p><p><code>Object.freeze(obj)</code> 冻结对象，对象冻结后不能修改和增删属性</p><p><code>obj = {...obj}</code> 克隆对象</p><p><code>obj.seal(obj)</code> 密封对象</p><p>属性描述符有：</p><ul><li><p><code>value</code> 属性值</p></li><li><p><code>writable</code> 是否可以重写</p></li><li><p><code>enumerable</code> 是否可遍历</p></li><li><p><code>configurable</code> 是否可修改描述符本身，设置为false之后就不能再次修改属性符了</p></li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>前端学习路线： h5+css3 –&gt; es6 -&gt; 网络 –&gt; 第三方库 –&gt; 工程化 –&gt; Vue react等框架 –&gt; …</p><p>Vue的data中是界面数据</p><p>数据响应式： 数据的变化会引发界面的更新，其本质是当数据变化时，会自动运行相关函数</p><p>Vue中的computed表示计算属性，本身不存在，要靠计算出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h1&gt;&lt;h2 id=&quot;浏览器的进程模型&quot;&gt;&lt;a href=&quot;#浏览器的进程模型&quot; class=&quot;headerlink&quot; title=&quot;浏
      
    
    </summary>
    
      <category term="frontend,js" scheme="http://garden.aezo.cn/categories/frontend-js/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="frontend" scheme="http://garden.aezo.cn/tags/frontend/"/>
    
      <category term="js" scheme="http://garden.aezo.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA</title>
    <link href="http://garden.aezo.cn/2023/06/27/tools/idea/"/>
    <id>http://garden.aezo.cn/2023/06/27/tools/idea/</id>
    <published>2023-06-27T05:35:41.000Z</published>
    <updated>2023-11-10T06:18:58.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>Alt + insert</code> 生成构造方法、getset方法、mybatis文件等</li></ul><h2 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h2><h3 id="MyBatisCodeHelperPro-Marketplace-Edition"><a href="#MyBatisCodeHelperPro-Marketplace-Edition" class="headerlink" title="MyBatisCodeHelperPro (Marketplace Edition)"></a>MyBatisCodeHelperPro (Marketplace Edition)</h3><ul><li><p><a href="https://www.cnblogs.com/equals/p/15391453.html" target="_blank" rel="noopener">安装说明</a></p></li><li><p><a href="https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/" target="_blank" rel="noopener">使用说明</a></p></li><li><p><a href="https://www.bilibili.com/video/av50632948/?vd_source=8a67383411f69921887ca2f40f490a83" target="_blank" rel="noopener">操作视频</a></p></li><li><p>支持实体生成建表语句</p></li><li><p>支持基于表生成实体/Mapper/服务等</p></li><li><p>支持生成Mybatis执行日志</p></li><li><p>支持预执行SQL</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用快捷键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Alt + insert&lt;/code&gt; 生成构造方法、getset方法、mybatis文件等
      
    
    </summary>
    
      <category term="Tools, IDEA" scheme="http://garden.aezo.cn/categories/Tools-IDEA/"/>
    
    
      <category term="Tools" scheme="http://garden.aezo.cn/tags/Tools/"/>
    
      <category term="IDEA" scheme="http://garden.aezo.cn/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>坦克大战</title>
    <link href="http://garden.aezo.cn/2023/06/06/projects/tank/"/>
    <id>http://garden.aezo.cn/2023/06/06/projects/tank/</id>
    <published>2023-06-06T06:04:35.871Z</published>
    <updated>2023-06-12T02:49:16.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frame类"><a href="#Frame类" class="headerlink" title="Frame类"></a>Frame类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Frame f = <span class="keyword">new</span> Frame(); <span class="comment">// 新建Frame类</span></span><br><span class="line">f.setSize(<span class="number">800</span>, <span class="number">600</span>);<span class="comment">// 设置窗口大小</span></span><br><span class="line">f.setResizable(<span class="keyword">false</span>);<span class="comment">// 设置窗口不能调整大小</span></span><br><span class="line">f.setTitle(<span class="string">"Tank War"</span>);<span class="comment">// 设置窗口名称</span></span><br><span class="line">f.setVisible(<span class="keyword">true</span>);<span class="comment">// 设置窗口可见</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加窗口监听事件</span></span><br><span class="line">f.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">    <span class="comment">// 添加窗口关闭事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="坦克大战"><a href="#坦克大战" class="headerlink" title="坦克大战"></a>坦克大战</h1><h2 id="创建TankFrame类继承Frame类"><a href="#创建TankFrame类继承Frame类" class="headerlink" title="创建TankFrame类继承Frame类"></a>创建TankFrame类继承Frame类</h2><p><code>public class TankFrame extends Frame {}</code></p><h2 id="在构造函数中设置默认值"><a href="#在构造函数中设置默认值" class="headerlink" title="在构造函数中设置默认值"></a>在构造函数中设置默认值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    setResizable(<span class="keyword">false</span>);</span><br><span class="line">    setTitle(<span class="string">"Tank War"</span>);</span><br><span class="line">    setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    addKeyListener(<span class="keyword">new</span> KeyListener());<span class="comment">// 监听键盘按键事件</span></span><br><span class="line"></span><br><span class="line">    addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建内部类KeyListener控制键盘按键"><a href="#创建内部类KeyListener控制键盘按键" class="headerlink" title="创建内部类KeyListener控制键盘按键"></a>创建内部类KeyListener控制键盘按键</h2><p><code>class KeyListener extends KeyAdapter {}</code></p><p>重写KeyAdapter类中的<code>keyPressed()</code>和<code>keyReleased()</code>方法</p><h2 id="判断两个方块相交"><a href="#判断两个方块相交" class="headerlink" title="判断两个方块相交"></a>判断两个方块相交</h2><p>使用工具类Rectangle,<code>Rectangle.intersects()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rectangle rect1 = <span class="keyword">new</span> Rectangle(x, y, WIDTH, HEIGHT);</span><br><span class="line">Rectangle rect2 = <span class="keyword">new</span> Rectangle(x2, y2, WIDTH2, HEIGHT2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rect1.intersects(rect2)) System.out.println(<span class="string">"两者相交"</span>);</span><br></pre></td></tr></table></figure><h2 id="坦克大战中的设计模式"><a href="#坦克大战中的设计模式" class="headerlink" title="坦克大战中的设计模式"></a>坦克大战中的设计模式</h2><ol><li><p>单例模式</p><p> 应用场景：只需要一个实例 比如各种各样的manager、Factory</p><ul><li><p>饿汉式</p><p>  类加载到内存后就实例化一个单例，JVM保证线程安全，缺点是无论是否会用都会在类装载完成时完成实例化</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- 懒汉式    按需使用    - 多线程使用不安全写法    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 多线程使用安全写法        类加载时不会产生实例，只有在调用`getInstance()`时调用静态内部类会实例化对象    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonDemo INSTANCE = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonDemoHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 目前语法上最完美的写法，既能解决线程同步问题，还能防止反序列化        调用时直接使用 `SingletonDemo.INSTANCE`    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    枚举类没有构造方法，所以能防止反序列化实际使用时常用的还是饿汉式</code></pre><ol start="2"><li><p>策略模式</p><p> <code>Comparator</code>接口 和 <code>Comparable</code>接口</p><ul><li><p><code>Comparator</code>接口是java.util包内的接口，包含两个抽象方法： <code>compare(o1，o2)</code>和<code>equals(obj)</code></p></li><li><p><code>Comparable</code>接口是java.lang包内的接口，只有一个方法： <code>compareTo(obj)</code></p><p>开闭原则： 对修改关闭，对扩展开放</p><p>实现<code>Comparable</code>接口时只能有一个compareTo方法</p></li></ul></li><li><p>工厂模式</p><p> 简单工厂和静态工厂</p><p> 任何产生对象的方法或类都可以称为工厂</p><p> 形容词用接口，名词用抽象类</p><p> 工厂模式更好的方法是spring里面的bean工厂</p><p> 坦克大战里面利用抽象工厂完成一键风格替换</p><p> 父类抽象方法时，方法要尽量少，因为父类方法越多实现时子类就会要覆写越多</p><p> 生产一系列的类是抽象工厂</p><p> 抽象工厂在实际的开发过程中使用的不是特别多</p></li></ol><ol start="4"><li><p>facade模式（门面模式）</p></li><li><p>Mediator模式(调停者模式)</p></li><li><p>责任链模式</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>面向对象设计时，慎用继承关系，因为继承是一种强关系，父类变了，子类必须变。</li></ol><p>强关系对于代码的扩展性是有局限的。</p><ol start="2"><li>Java转exe需要java虚拟机、jar包和转换工具</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Frame类&quot;&gt;&lt;a href=&quot;#Frame类&quot; class=&quot;headerlink&quot; title=&quot;Frame类&quot;&gt;&lt;/a&gt;Frame类&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="实战" scheme="http://garden.aezo.cn/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="实战" scheme="http://garden.aezo.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="http://garden.aezo.cn/2023/06/05/algorithm/bigData/"/>
    <id>http://garden.aezo.cn/2023/06/05/algorithm/bigData/</id>
    <published>2023-06-05T07:52:22.571Z</published>
    <updated>2023-06-05T09:11:33.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><p>内存寻址时间比IO寻址快10w倍</p><p>单机处理大数据的Io速度太慢，内存也太小</p><p>大数据技术关心的重点： </p><ul><li>分而治之</li><li>并行计算</li><li>计算向数据移动</li><li>数据本地化读取 </li></ul><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>Hadoop Distributed File System 分布式文件系统，与其他的分布式文件系统相比，Hadoop能更好的支持分布式计算。</p><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><ul><li>文件线性按字节切割成块（block），具有offset, id</li><li>文件与文件的block大小可以不一样</li><li>一个文件除最后一个block，其他block大小一致</li><li>block的大小依据硬件的I/O特性调整</li><li>block被分散存放在集群的节点中，具有location</li><li>Block具有副本(replication),没有主从概念，副本不能出现在同一个节点</li><li>副本是满足可靠性和性能的关键</li><li>文件上传可以指定block的大小和副本数，上传后只能修改副本数</li><li>一次写入多次读取，不支持修改</li><li>支持追加数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Hadoop&quot;&gt;&lt;/a&gt;Hadoop&lt;/h1&gt;&lt;p&gt;内存寻址时间比IO寻址快10w倍&lt;/p&gt;
&lt;p&gt;单机处理大数据的Io速度太慢，内存也太小&lt;/p&gt;
&lt;p&gt;大数
      
    
    </summary>
    
      <category term="algorithm" scheme="http://garden.aezo.cn/categories/algorithm/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="algorithm" scheme="http://garden.aezo.cn/tags/algorithm/"/>
    
      <category term="basic" scheme="http://garden.aezo.cn/tags/basic/"/>
    
      <category term="bigData" scheme="http://garden.aezo.cn/tags/bigData/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://garden.aezo.cn/2023/05/09/java/maven/"/>
    <id>http://garden.aezo.cn/2023/05/09/java/maven/</id>
    <published>2023-05-09T06:55:13.632Z</published>
    <updated>2023-06-08T09:59:18.012Z</updated>
    
    <content type="html"><![CDATA[<p>Maven：</p><p>项目对象模型POM</p><p>核心配置文件： setting.xml</p><p>Maven工程关系： 依赖关系、继承关系、聚合关系</p><h2 id="常见的插件"><a href="#常见的插件" class="headerlink" title="常见的插件"></a>常见的插件</h2><h3 id="编译器插件"><a href="#编译器插件" class="headerlink" title="编译器插件"></a>编译器插件</h3><p><code>settings.xml</code>文件里面可配置全局默认的JDK版本,<code>settings.xml</code>文件中的id不能随便取名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.4<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk14<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Repository for JDK 1.4 builds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.myhost.com/maven/jdk14<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshotPolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">snapshotPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若不想用setting.xml中默认的JDK，可以在项目的<code>pom.xml</code>文件中添加一个编译器插件的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDK编译插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--插件坐标--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--源代码使用JDK版本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--源代码编译为class文件的版本，要与上面版本保持一致--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="资源拷贝插件"><a href="#资源拷贝插件" class="headerlink" title="资源拷贝插件"></a>资源拷贝插件</h3><p>配置文件一般都放在<code>src/main/resources</code>目录下，打包后配置文件会在<code>target/classes</code>目录中,默认情况下不放在<code>src/main/resources</code>的配置文件打包后不会存在<code>target/classes</code>目录中，若想要把指定路径下的配置文件打包到<code>target/classes</code>目录中需要添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述配置表示<code>src/main/java</code>目录下的xml文件和<code>src/main/resources</code>目录下的xml文件、properties文件都会被打包到<code>target/classes</code>中</p><h3 id="Tomcat插件"><a href="#Tomcat插件" class="headerlink" title="Tomcat插件"></a>Tomcat插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Tomcat插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置Tomcat监听端口--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置项目的访问路径(Application Context)--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Tomcat插件发布部署并执行war工程的时候，需要使用启动命令，启动命令为: <code>tomcat7:run</code>.命令中的tomcat7是插件命名，由插件提供商决定。run为插件中的具体功能。</p><p>Tomcat是可运行插件，必须要通过命令来运行控制</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p><code>mvn install</code></p><p>本地安装，包含编译、打包、安装到本地仓库</p><p><code>mvn clean</code></p><p>清除已编译信息，删除工程中的target目录</p><p>常用的命令在IDEA都有可视化界面可以操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven：&lt;/p&gt;
&lt;p&gt;项目对象模型POM&lt;/p&gt;
&lt;p&gt;核心配置文件： setting.xml&lt;/p&gt;
&lt;p&gt;Maven工程关系： 依赖关系、继承关系、聚合关系&lt;/p&gt;
&lt;h2 id=&quot;常见的插件&quot;&gt;&lt;a href=&quot;#常见的插件&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Spring" scheme="http://garden.aezo.cn/categories/Spring/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="Spring" scheme="http://garden.aezo.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库</title>
    <link href="http://garden.aezo.cn/2020/10/31/database/mysql/"/>
    <id>http://garden.aezo.cn/2020/10/31/database/mysql/</id>
    <published>2020-10-31T09:22:00.000Z</published>
    <updated>2023-02-24T08:23:43.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序和数据的访问都有聚集成群的倾向，在一个时间段内仅使用其中一小部分（称<strong>空间局部性</strong>），或者最近访问过的程序代码和数据，很快又会被访问的可能性很大(称<strong>时间局部性</strong>)。</p><h3 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h3><p>磁盘预读的长度一般为页(page)的整数倍</p><ul><li>页(page)是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4k），主存和磁盘以页为单位交换数据。</li></ul><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><ul><li>索引的目的是为了加速查询</li><li>索引是存在磁盘中而不是内存中</li><li>索引的文件存储形式与存储引擎有关</li><li><p>索引文件的结构</p><ul><li><p>hash</p><p>  哈希表本质上是散列表，可以完成索引的存储，每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置即可。</p><p>  适合场景： </p><ul><li>等值查询</li><li><p>表中的数据是无序数据，范围查找的时候比较浪费时间，需要挨个进行便利操作</p><p>在企业中多数的查询是范围查询，因此hash表不是特别适合</p><p>hash表在使用的时候需要将全部数据加载到内存，比较耗费内存的空间，这点上来说，使用hash表也不是很合适</p></li></ul></li><li><p>二叉树</p></li><li>B树</li><li>B+树</li></ul></li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>mysql索引的五种类型： 主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力</p><ul><li><p>主键索引</p><p>  主键索引是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键</p></li><li><p>唯一索引</p><p>  索引列的所有值都只能出现一次，即必须唯一，值可以为空</p></li><li><p>普通索引</p><p>  基本的索引类型，值可以为空，没有唯一性的限制（覆盖索引）</p><p>  覆盖索引： sql语句中只select索引字段</p><p>  覆盖索引可避免回表操作</p></li><li><p>全文索引</p><p>  MyISAM支持，Innodb在5.6之后支持</p><p>  全文索引的索引类型为FULLTEXT。全文索引可以在<code>varchar</code>、<code>char</code>、<code>text</code>类型的列上创建</p></li><li><p>组合索引</p><p>  多列值组成一个索引，专门用于组合搜索(最左匹配原则)</p><p>  最左匹配原则：优先匹配前一个字段，例如用<code>name</code>和<code>age</code>作为组合索引，使用<code>name</code>+<code>age</code>组合查询时会先匹配<code>name</code>再匹配<code>age</code>,如果没有<code>name</code>，那么<code>age</code>也无法参与匹配</p></li></ul><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>索引在插入新的值的时候，为了维护索引的有序性，必须要维护</p><p>在维护索引的时候需要分以下几种情况：</p><ul><li><p>如果插入一个比较大的值，直接插入即可，几乎没有成本</p></li><li><p>如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置</p></li><li><p>如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做<strong>页分裂</strong>，此时性能会受影响，同时空间的使用率也会降低，除了页分裂之外还包括页合并</p></li><li><p>尽量使用自增主键作为索引</p></li></ul><h2 id="MySQL整体结构"><a href="#MySQL整体结构" class="headerlink" title="MySQL整体结构"></a>MySQL整体结构</h2><p><img src="/source/data/img/mysql/mysql整体结构.png" alt="MySQL整体结构图"></p><p>不同存储引擎，数据文件和索引文件存放的位置是不同的，因此有了分类：</p><ul><li><p>聚簇索引</p><p>数据和文件放在一起： <code>innodb</code></p><p><code>.frm</code>后缀文件存放的是表结构<br><code>.ibd</code>后缀文件存放的是数据文件和索引文件</p></li></ul><p>注意： <code>mysql</code>的<code>innodb</code>存储引擎默认情况下会把所有的数据文件放到表空间，不会为每一个单独的表保存一份数据文件，如果需要将每一个表单独使用文件保存，需要执行语句： <code>set global innodb_file_per_table = on;</code></p><ul><li><p>非聚簇索引</p><p>  数据和索引单独一个文件: <code>MyISAM</code></p><p>  <code>.frm</code>: 存放表结构<br>  <code>.MYI</code>: 存放索引数据<br>  <code>.MYD</code>: 存放实际数据</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li><p>数据库中最常见的慢查询优化方法是什么？</p></li><li><p>为什么加索引能优化慢查询</p></li><li><p>你知道哪些数据结构可以提高查询速度</p></li><li><p>这些数据结构既然都能优化查询速度，MySQL为何选择使用B+树？</p></li><li><p>索引下推</p><p>  在回表前把数据做一次筛选</p></li></ul><p>常见树结构： 多叉树、二叉树、AVL树、红黑树</p><p>树结构中，左子树必须小于根节点，右子树必须大于根节点</p><p>多叉树(从左到右是有序) –&gt; 二叉树(二分查找) –&gt; AVL树(平衡树) –&gt; 红黑树</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><p>AVL树：AVL树是一棵严格意义上的平衡树，最高子树和最低子树高度之差不能超过1，因此在进行元素插入的时候会进行1到N次的旋转，严重影响插入的性能</p></li><li><p>红黑树： 红黑树是基于AVL树的一个升级，损失了部分查询的性能来提升插入的性能，在红黑树中，最低子树跟最高子树之差小于2倍即可，例如最低子树是4层，那么最高子树不能高于8层。在插入时不需要进行N多次的旋转操作，而且还加入了变色的特性来满足插入和查询性能的平衡</p></li></ul><p>二叉树及其N多的变种都不能支撑索引，因为其树的深度无法控制，或者插入数据的性能比较低</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树的特点：</p><ol><li>所有键值分布在整棵树上</li><li>搜索有可能在非叶子节点(一个节点下面没有左右子树称为叶子节点，否则为非叶子节点)结束，在关键字全集内做一次查找性能逼近二叉树</li><li>每个节点最多拥有m（阶）个子树</li><li>根节点至少有2个子树</li><li>分支节点至少拥有m/2棵子树（除根节点和叶子节点外都是分支节点）</li><li>所有叶子节点都在同一层，每个节点最多可以有m-1个key，并且以升序排列</li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是在B树的基础之上做的一种优化，变化如下：</p><ol><li>B+树每个节点可以包含更多的节点，这么做的原因有两个，第一是为了降低树的高度；第二是将数据范围变为多个区间，区间越多数据检索越快</li><li>非叶子节点存储Key，叶子节点存储key和数据</li><li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p>注意事项：</p><ol><li>InnoDB是通过B+树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id来作为主键</li><li>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，此过程称为<strong>回表</strong></li></ol><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是(5.6后支持)</td></tr><tr><td>适合操作类型</td><td>大量select</td><td>大量insert、delete、update</td></tr></tbody></table><h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><p>客户端 –&gt; 连接器（管理连接，权限验证） –&gt; 查询缓存 –&gt; 分析器（词法分析，语法分析） –&gt; 优化器（执行计划，索引选择） –&gt; 执行器（操作引擎，返回结果） –&gt; 存储引擎（存储数据，提供读写接口）</p><p>连接器、查询缓存、分析器、优化器、执行器属于服务端</p><ul><li><p>连接器</p><p>  连接器负责跟客户端建立连接，获取权限、维持和管理连接</p><pre><code>- 用户名密码验证- 查询权限信息，分配对应权限- 可以使用`show processlist`语句查看现在的连接- 如果太长时间没有动静就会自动断开，通过`wait_timeout`控制，默认8小时</code></pre><p>  连接可以分为两类：</p><pre><code>- 长连接： 推荐使用，但要周期性断开长连接- 短连接</code></pre></li><li><p>查询缓存</p><p>当执行查询语句的时候，会先去查询缓存中查看结果，之前执行过的sql语句及其结果可能以<code>key-value</code>的形式存储在缓存中，如果能找到则直接返回，如果找不到，就继续执行后续的阶段</p><p>不推荐使用查询缓存：</p><ol><li>查询缓存的失效比较频繁，只要表更新，缓存就会清空</li><li>缓存对应新更新的数据命中率比较低</li></ol></li><li><p>分析器</p><ul><li><p>词法分析：MySQL需要把输入的字符串进行识别每个分代表什么意思。把<code>字符串T</code>识别成<code>表名T</code>；把<code>字符串ID</code>识别成<code>列ID</code></p></li><li><p>语法分析： 根据语法规则判断这个SQL语句是否满足MySQL的语法，如果不符合就会报错<code>You have an error in your SQL synta</code></p></li></ul></li><li><p>优化器</p><p>  在具体执行SQL语句之前，要先经过优化器的处理： 当表中有多个索引的时候，决定用哪个索引；当SQL语句需要做多表关联的时候，决定表的连接顺序等等</p><p>  不同的执行方式对SQL语句的执行效率影响很大</p><ul><li><p>RBO： 基于规则的优化</p></li><li><p>CBO： 基于成本的优化</p></li></ul></li><li><p>执行器 </p><p>执行语句，返回结果</p></li><li><p>存储引擎</p><p>  存储数据</p></li></ul><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="Redo日志-——-InnoDB存储引擎的日志文件"><a href="#Redo日志-——-InnoDB存储引擎的日志文件" class="headerlink" title="Redo日志 —— InnoDB存储引擎的日志文件"></a>Redo日志 —— InnoDB存储引擎的日志文件</h3><p>当发生数据修改的时候InnoDB引擎会先将记录写到redo log中，并更新内存，此时更新就算是完成了，同时InnoDB引擎会在何时的时机将记录操作到磁盘中</p><p>Redolog是固定大小的，是循环写的过程</p><p>有了Redolog后，InnoDB就可以保证及时数据库发生异常重启，之前的记录也不会丢失，叫做<code>crash-safe</code></p><h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><p>Undo log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo log来实现多版本并发控制（简称<code>MVCC</code>）</p><p>在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为<code>Undo log</code>）。然后进行数据修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo log中的备份将数据恢复到事务开始之前的状态</p><p><strong>Undo log是逻辑日志</strong>，可以理解为：</p><ul><li>当delete一条记录时，undo log中会记录一条多赢的insert记录</li><li>当insert一条记录时，Undolog中会记录一条对应的delete记录</li><li>当update一条数据时，它记录一条对应相反的update记录</li></ul><p><strong>Redo log 和 Undo log 都是InnoDB独有的日志，MyISAM中没有。Redo log叫前滚日志，保证数据库回到发生异常(比如突然断电)前的持久化状态；Undo log叫回滚日志，是记录数据更新后的持久化状态。</strong></p><h3 id="Binlog-——-服务端的日志文件"><a href="#Binlog-——-服务端的日志文件" class="headerlink" title="Binlog —— 服务端的日志文件"></a>Binlog —— 服务端的日志文件</h3><p>Binglog是服务端(server层)的日志，主要做mysql功能层面的事情</p><p>与Redo日志的区别：</p><ul><li>Redo日志是InnoDB独有的，Binlog是所有引擎都可以使用的</li><li>Redo是物理日志，记录的是在某个数据页上做了什么修改；Binlog是逻辑日志，记录的是这个语句的原始逻辑</li><li>Redo是循环写的，空间会用完；Binlog是可以追加写的，不会覆盖之前的日志信息</li></ul><p><strong>MySQL默认不开启Binlog</strong></p><p>Binlog会记录所有的逻辑，并且采用追加写的方式，一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置。</p><p>恢复数据的过程： </p><ol><li>找到最近一次的全量备份数据</li><li>从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时刻</li></ol><h2 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h2><p>使用<code>explain</code> + SQL语句来模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的</p><h3 id="执行计划中包含的信息（属性）"><a href="#执行计划中包含的信息（属性）" class="headerlink" title="执行计划中包含的信息（属性）"></a>执行计划中包含的信息（属性）</h3><ol><li><p>id</p><p>select查询的序列号包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><ul><li><p>如果id相同，那么执行顺序从上到下</p></li><li><p>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id相同和不同的同时存在，相同的可以认为是一组，从上往下顺序执行。在所有组中，id值越大优先级越高，越先执行</p></li></ul></li><li><p>select_type</p><p><code>SIMPLE</code>: 简单查询</p><p><code>PRIMARY</code>: 最外层查询</p><p><code>UNION</code>: 若第二个语句在union之后则标记为union</p><p><code>DEPENDENT UNION</code>: 跟union关联，外层查询依赖内层查询结果</p><p><code>UNION RESULT</code>: 从union表中获取结果select</p><p><code>SUBQUERY</code>: 子查询</p><p><code>DEPENDENT SUBQUERY</code>: 子查询是结果集合是D<code>EPENDENT SUBQUERY</code>,单个值是<code>SUBQUERY</code></p><p><code>DERIVED</code>: from子句中出现的子查询，也叫做衍生类</p><p><code>UNCACHEABLE SUBQUERY</code>: 表示使用子表查询结果不能被缓存</p><p><code>UNCACHEABLE UNION</code>: 表示union的查询结果不能被缓存</p></li><li><p>table</p><p>对应正在访问哪一个表、表名或者别名，可能是临时表挥着union合并结果集</p><ul><li>如果是具体表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li><li>表名是drivedN的形式，表示使用了id为N的查询产生的衍生表，当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ul></li><li><p>partitions</p><p>分区</p></li><li><p>type</p><p>访问类型，表示当前sql语句执行时是以何种方式访问我们的数据，访问类型有很多，效率从高到低分别是：</p><p><code>sysytem &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_of_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p><p>一般情况下，得保证查询至少达到<code>range</code>级别，最好能达到<code>ref</code></p><ul><li><p>ALL: 全表扫描，一般情况下，出现这种sql语句而且数据量比较大的话，那么久需要进行优化</p></li><li><p>index： 全索引扫描，比All效率好。主要两种情况，一种是当前的查询是覆盖索引，即我们需要的数据在索引中就可以索取；第二种者是使用了索引进行排序，这样就避免数据的重排序</p></li><li><p>range： 表示利用索引联合查询的时候限制了范围，在指定范围内进行查询</p></li><li><p>index_subquery: 利用索引关联子查询，不需要再扫描全表</p></li><li><p>unique_subquery</p></li><li>index_merge</li><li>ref_of_null</li><li>fulltext</li><li><p>ref<br>使用了非唯一性索引进行查找</p></li><li><p>eq_ref</p></li><li><p>const<br>这个表至多有一个匹配行</p></li><li><p>sysytem</p><p>表里面只有一行记录（等于系统表）</p></li></ul></li><li><p>possible_keys</p><p>显示可能会用到的索引</p></li><li><p>key</p><p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p></li><li><p>key_len</p><p>索引中使用的字节数</p></li><li><p>ref</p><p> 显示索引的哪一列被使用了，如果可能的话，是一个常数</p></li><li><p>rows</p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录读取的行数，此参数很重要，直接反映的sql找了多少数据，在完成目的的情况下，越少越好</p></li><li><p>extra</p><p>包含额外的信息</p></li></ol><h2 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong></p><p>不同的存储引擎支持不同的锁机制。</p><ul><li><code>MyISAM</code>和<code>MERMORY</code>存储引擎采用的是表级锁(<code>table-level locking</code>)</li><li><code>InnoDB</code>存储引擎支持行级锁(<code>row-level locking</code>)，也支持表级锁，但默认情况下采用行级锁</li></ul><p><strong>表级锁</strong>： 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发度最低</p><p><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</p><p>仅从锁的角度来说，表级锁更适合以查询为主，只有少量按索引条件更新数据的应用，如web应用；行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理(<code>OLTP</code>)系统</p><p><code>OLTP</code>: <code>ONLINE TRANSIATION PROCESS</code> 联机事务处理</p><p><code>OLAP</code>: <code>ONLINE ANALYSIS PROCESS</code> 联机分析系统 </p><h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>MySQL的表级锁有两种模式： <strong>表共享读锁(Table Read Lock)</strong>、<strong>表独占写锁(Table Write Lock)</strong></p><p>对MyISAM表的读操作，不会阻塞其他用户对同一张表的读请求，但会阻塞对同一表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间、以及写操作之间是串行的</p><h4 id="MyISAM写阻塞读"><a href="#MyISAM写阻塞读" class="headerlink" title="MyISAM写阻塞读"></a>MyISAM写阻塞读</h4><p>当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><p><code>lock table xxx write;</code>（锁表语句，给表xx加写锁）</p><p>…执行一些操作…</p><p><code>unlock tables;</code>(释放锁)</p><h4 id="MyISAM读阻塞写"><a href="#MyISAM读阻塞写" class="headerlink" title="MyISAM读阻塞写"></a>MyISAM读阻塞写</h4><p>一个session使用<code>lock table</code>给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时另一个session可以查询表中的记录，但更新就会出现锁等待。</p><p><code>lock table xxx read;</code> （锁表语句，给表加读锁）</p><p><code>unlock tables;</code>（释放锁）</p><p><strong>注意：</strong> MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显示加锁。</p><h3 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h3><ol><li>事务及其ACID属性</li></ol><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有四属性，通常称为事务的ACID属性。</p><p>原子性(<code>Actomicity</code>): 事务是一个原子操作单位，其对数据的修改，要么全都执行，要么全都不执行</p><p>一致性(<code>Consistent</code>): 在事务开始和完成时，数据都必须保持一致状态</p><p>隔离性(<code>Isolation</code>): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行</p><p>持久性(<code>Durable</code>): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p><ol start="2"><li><p>并发事务带来的问题</p><p>相对于串行处理来说，并发事务处理能力大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时会带来一下问题：</p><ul><li><strong>脏读</strong>： 一个事务正在对一条记录做修改，在这个事务提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读</li><li><strong>不可重复读</strong>： 一个事务正在读取某些已经发生了改变或某些记录已经被删除了!这种现象叫做“不可重复读”</li><li><strong>幻读</strong>： 一个事务按相同的查询条件重新读取以前检所过的数据，却发现其他事务插入了满足其条件的新数据，这种现象就称为”幻读“</li></ul></li></ol><p>以上出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证</p><ol start="3"><li><p>InnoDB的行锁模式及加锁情况</p><p><strong>共享锁(s)</strong>: 又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能在对A加S锁，而不能加X锁，知道T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何改动</p><p><strong>排它锁(x)</strong>: 又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集 共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁</p><p>MySQL InnoDB引擎默认的修改数据语句：<code>update</code>,<code>delete</code>,<code>insert</code>都会自动给涉及到的数据加上排他锁，select语句默认不会加任何类型锁。如果加排他锁可以使用<code>select ... for upadte;</code>语句，加共享锁可以使用<code>select ... lock in share mode;</code>语句。所以加排他锁的数据行在其他事务中是不能修改数据的，也不能通过<code>for update</code>和<code>lock in share mode</code>锁的方式查询数据，但可以直接通过<code>select ... from ...</code>查询数据，因为普通查询没有任何锁机制</p></li></ol><h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>给索引上的索引加说来实现行锁。这一点上MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着： <strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于MyISAM的表锁：</p><ol><li>共享读锁(s)之间是兼容的，但共享读锁(s)与排他写锁(X)之间，以及排他写锁(X)之间是互斥的，也就是说读和写是串行的。</li><li>在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和超如的锁争用问题</li><li>MyISAM默认的锁调度机制是写优先，但这不一定适合所有应用，用户可以通过设置<code>LOW_PRIORITY_UPDATES</code>参数，或在INSERT、UPDATE、DELETE语句中指定<code>LOW_PRIORITY</code>选项来调节读写锁的争用</li><li>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突</li></ol><p>对于InnoDB表锁：</p><ol><li>InnoDB行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁</li><li>在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同</li></ol><p>用户可以通过设计和SQL调整等措施减少锁冲突和死锁：</p><ul><li>尽量使用较低的隔离级别： 精心设计索引并尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会</li><li>选择合理的事务大小，小失误发生锁冲突的几率也更小</li><li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时在请求排他锁，这样容易产生死锁</li><li>不同的程序访问同一组表时，应尽量约定相同的顺序访问各表，对一个表而言尽可能以固定的顺序存取表中的行，这样可以大大减少死锁的机会</li><li>尽量使用相等条件范文数据，这样可以避免间隙锁对并发插入的影响；不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;
      
    
    </summary>
    
      <category term="Database, MySQL" scheme="http://garden.aezo.cn/categories/Database-MySQL/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="Database" scheme="http://garden.aezo.cn/tags/Database/"/>
    
      <category term="MySQL" scheme="http://garden.aezo.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://garden.aezo.cn/2020/10/27/java/beforeArchitect/%E5%8F%8D%E5%B0%84/"/>
    <id>http://garden.aezo.cn/2020/10/27/java/beforeArchitect/反射/</id>
    <published>2020-10-27T13:31:00.000Z</published>
    <updated>2023-02-24T08:23:43.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JAVA反射机制是在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法功能称为Java语言的反射机制。 </p><p>想要解剖一个类，必须先要获取到该类的字节码文件对象。而而解剖使用的就是Class类中的方法，所以现在要获取到每一个字节码文件对应的Class类型的对象。</p><h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><ol><li><p>通过class.forName()来获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.xx.entity.Emp"</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过<code>类名.class</code>来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Emp&gt; <span class="class"><span class="keyword">class</span> </span>= Emp.class;</span><br></pre></td></tr></table></figure></li><li><p>通过对象的<code>getClass()</code>来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Emp&gt; clazz = <span class="keyword">new</span> Emp().getClass();</span><br></pre></td></tr></table></figure></li><li><p>基本数据类型可以通过TYPE的方式获取class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br></pre></td></tr></table></figure></li></ol><p>推荐第1、2种方式</p><h2 id="Class对象方法"><a href="#Class对象方法" class="headerlink" title="Class对象方法"></a>Class对象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.xx.xx.类名"</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>getFields()</code></p><p>获取成员变量，包括子类、父类，同时只能包含公共的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field: fields) &#123;</span><br><span class="line">    <span class="comment">// 字段名称</span></span><br><span class="line">    field.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段类型</span></span><br><span class="line">    field.getType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段修饰符</span></span><br><span class="line">    field.getModifiers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getDeclaredFields()</code></p><p>获取当前类的所有属性，不仅仅是公共访问修饰符，所有的访问修饰符都可以拿到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// xx表示该类中的某个字段名</span></span><br><span class="line">Field xx = clazz.getDeclaredField(<span class="string">"xx"</span>);</span><br></pre></td></tr></table></figure></li><li><p>为对象设值</p><p>假设有一个类<code>Student</code>，含有私有属性<code>address</code>(用<code>private</code>修饰的字段)，正常情况下<code>private</code>修饰的属性无法被外界访问，但是通过反射能够为<code>address</code>字段设值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.xx.entity.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取address字段</span></span><br><span class="line">Field address = clazz.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将address字段的访问权限设置为可访问，true表示能访问</span></span><br><span class="line">address.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为address字段赋值</span></span><br><span class="line">Object o = clazz.newInstance();</span><br><span class="line">address.set(o, <span class="string">"上海市"</span>);</span><br></pre></td></tr></table></figure><p><strong>反射在一定程度上破坏了封装性，需要合理使用</strong></p></li><li><p><code>getMethods()</code></p><p>获取对象中的普通方法，包含当前对象和父类对象的公共方法</p></li><li><p><code>getDeclaredMethods()</code></p><p>获取当前类中的所有方法，包括私有方法</p></li><li><p><code>getConstructors()</code></p><p>获取对象所有的公有构造方法,不包含父类构造方法</p></li><li><p><code>getDeclaredConstructors()</code></p><p>获取对象的所有构造方法，包括私有,不包含父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用私有的构造方法</span></span><br><span class="line">Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object o2 = declaredConstructor.newInstance(<span class="string">"参数1"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;JAV
      
    
    </summary>
    
      <category term="Java" scheme="http://garden.aezo.cn/categories/Java/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="反射" scheme="http://garden.aezo.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://garden.aezo.cn/2020/10/25/java/beforeArchitect/JDBC/"/>
    <id>http://garden.aezo.cn/2020/10/25/java/beforeArchitect/JDBC/</id>
    <published>2020-10-25T14:54:00.000Z</published>
    <updated>2023-02-24T08:23:43.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul><li><p><code>ODBC</code>: 一套连接数据源的标准</p></li><li><p><code>JDBC</code>: <code>Java Database Connectivity</code></p><p>  基于Java语言访问数据库的一种技术。</p><p>  JDBC是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时JDBC也是个商标名</p><p>  JDBC设计思想： 由SUN公司提供访问数据库的接口，由数据库厂商提供对这些接口的实现，程序员编程时都是针对接口进行编程的。</p><p>  JDBC包括一套JDBC的API和一套程序员和数据库厂商都必须去遵守的规范。</p><pre><code>- java.sql包： 提供访问数据库基本的功能- javax.sql包： 提供扩展的功能</code></pre><p>  JDBC是数据库的中间件</p><p>  JDBC可以做什么？</p><pre><code>- 连接到数据库- 在java app中执行SQL命令- 处理结果</code></pre></li><li><p><code>SPI</code></p><p><code>Service Provider Interface</code><br>。是JDK内置的一种服务提供发现机制，SPI是一种动态替换发现的机制，比如有个接口，想运行时动态给它添加实现，你只需要添加一个实现。我们经常遇到的就是<code>java.sql.Driver</code>接口，其他不同厂商可以针对同一接口做出不同的实现，<code>mysql</code>和<code>posthresql</code>都有不同的实现提供给客户，而Java的SPI机制可以为某个接口寻找服务实现</p></li></ul><h2 id="面向接口编程-java-sql"><a href="#面向接口编程-java-sql" class="headerlink" title="面向接口编程 java.sql"></a>面向接口编程 java.sql</h2><p>如果需要建立连接，java中提供了一套标准，数据库厂商来进行实现，包含实现子类，实现子类的jar文件一般放在数据库安装目录下</p><ol><li>java.sql.Driver 驱动</li><li>java.sql.Connection 连接</li><li><p>java.sql.Statement 静态处理快</p><p>java.sql.PreparedStatement 预处理块</p></li><li><p>java.sql.ResultSet 结果集</p></li><li>java.sql.ResultSetMetaData 结果集元数据</li></ol><h3 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加载驱动</span></span><br><span class="line"><span class="comment">/* 当执行了当前代码之后，会返回一个class对象，在此对象的创建过程中，会调用具体类的静态代码块 */</span></span><br><span class="line"></span><br><span class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接</span></span><br><span class="line"><span class="comment">/** 第一步已经将driver对象注册到了drivermanager中，所以此时可以直接通过DriverManager来获取数据库连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要输入连接数据库的参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- url: 数据库的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- username： 用户名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- password： 密码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"scott"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 测试连接是否成功</span></span><br><span class="line">System.out.println(connection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义sql语句</span></span><br><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 准备静态处理块对象，需要一个对象来存放sql语句，将对象进行执行的时候调用的是数据库的服务，数据库会从当前对象中拿到对应的sql语句进行执行</span></span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 执行sql语句，返回值对象是结果集合</span></span><br><span class="line">ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 循环处理</span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 通过下标索引编号获取值，索引从1开始</span></span><br><span class="line">    <span class="keyword">int</span> anInt = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过列名获取值</span></span><br><span class="line">    String ename = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 关闭连接</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h1&gt;&lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Database" scheme="http://garden.aezo.cn/categories/Database/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="JDBC" scheme="http://garden.aezo.cn/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://garden.aezo.cn/2020/10/25/database/database/"/>
    <id>http://garden.aezo.cn/2020/10/25/database/database/</id>
    <published>2020-10-25T13:06:00.000Z</published>
    <updated>2023-02-24T08:23:43.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库表的创建、表的约束、索引、数据库"><a href="#数据库表的创建、表的约束、索引、数据库" class="headerlink" title="数据库表的创建、表的约束、索引、数据库"></a>数据库表的创建、表的约束、索引、数据库</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="标准的建表语法"><a href="#标准的建表语法" class="headerlink" title="标准的建表语法"></a>标准的建表语法</h3><p>数据库连接池： <code>C3P0</code> <code>DBCP</code> <code>druid</code></p><p><code>CREATE TABLE[schema.]table(column datatype [DEFAULT])</code> </p><p>例如：</p><p>建立一张用来存储学生信息的表，表中的字段包含学生的学号、姓名、年龄、入学日期、年纪、班级、email等信息，且为grade指定默认值为1</p><ul><li><p>创建</p><p><code>create table student (sty_id number(10), name varcher2(20), age number(3), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50))</code></p></li><li><p>插入</p><ul><li><p><code>insert into student values(20201025, &#39;zhangshan&#39;, 22, to_date(&#39;2020-10-25&#39;, &#39;YYYY-MM-DD&#39;), &#39;2&#39;, &#39;1&#39;, &#39;123@xx.com&#39;)</code></p></li><li><p><code>insert into student(sty_id, name, age, hiredate,classes,email) values(20201025, &#39;zhangshan&#39;, 22, to_date(&#39;2020-10-25&#39;, &#39;YYYY-MM-DD&#39;), &#39;1&#39;, &#39;123@xx.com&#39;)</code></p></li></ul></li></ul><p>注意事项： </p><ul><li>创建新表时，指定的表名必须不存在，否则报错</li><li>使用默认值时，当插入行不给出值，dbms将自动采用默认值</li><li>使用create语句创建基本表时，最初只是一个空的框架，用户可以使用insert命令将数据插入表中，即只包含表结构不包含表数据</li></ul><p><strong>正规的表结构设计需要使用第三方工具</strong></p><ul><li><p>修改表</p><p>例如： 在上述<code>student</code>表中添加字段<code>address</code></p><p><code>alter table student add address varchar2(100)</code></p><p>注： 新增加的列不能设置为 <code>not null</code>，基本表在增加一列后，原有元组在新增加的列上的值都定义为空值</p></li><li><p>删除表字段</p><p><code>alter table 表名 drop column 列名</code></p><p><code>alter table student drop column address</code></p></li><li><p>修改表字段类型</p><p><code>alter table 表名 modify(字段 字段类型);</code></p><p><code>alter table student modify(email varchar2(100));</code></p></li><li><p>删除表</p><p><code>drop table 表名</code></p><p>多表关联时不能随意删除，需要使用</p><ul><li><p>级联删除<code>cascade</code>: 如果表A和表B，A中的某一个字段与B中的某一个字段做关联，那么删除A表的时候，需要先将B表删除</p></li><li><p><code>set null</code>删除时，把表的关联字段设置为空</p></li><li><p><code>restrict</code>，只有当依赖表中没有一个外键值与要删除的主表中主键值相对应时，才可执行删除操作</p></li></ul></li><li><p>修改表名称</p><p><code>rename 原表名 to 新表名;</code></p><p><code>rename student to stu;</code></p></li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>创建表时同时可以指定所插入数据的一些规则，比如说某个字段不能为空，某个字段你的值不能小于0等，这些规则统称为约束。约束是在表上强制执行的<strong>数据校验规则</strong></p><p>Oracle支持以下五类完整型约束：</p><ul><li>NOT NULL 非空，插入数据时，指定列不允许为空</li><li>UNIQUE Key 唯一键， 可以限定某一列的值唯一，唯一键的列一般被用作索引列</li><li>PRIMARY KEY 主键， 非空且唯一，任何一张表一般情况下最好有主键用来唯一的标识一行记录</li><li><p>FOREIGN KEY 外键，多个表之间有关联关系(一个表的某个列的值依赖于另一张表的某个值)时，需要使用外键</p><ul><li>外键是表中的一个列，其值必须在另一表的主键或者唯一键中列出</li><li>作为“主键”的表称为“主表”，作为外键的关系称为“依赖表”</li><li>外键参照的是主表的主键或者唯一键</li><li>对于主表的删除和修改主键值的操作，回怼依赖关系产生影响，如要删除主表的某个记录（即删除一个主键值），那么对依赖的影响可采取<code>RESTRICT方式</code>、<code>CASCADE方式</code>、<code>SET NULL方式</code></li></ul><p>插入DEPT表中的DEPTNO列作为外键<br><code>create table student (sty_id number(10), name varcher2(20), age number(3), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50)), foreign key [DEPTNO] references DEPT[DEPTNO]</code></p></li><li><p>CHECK 自定义检查约束，可以根据用户自己的需求去限定某些列的值</p><p>例如： 限制0&lt;年龄&lt;150</p><p>   <code>create table student (sty_id number(10), name varcher2(20), age number(3) check(age &gt; 0 and age &lt; 150), hiredate date,grade varchar2(10) default 1, classes varchar2(10), email varchar2(50))</code></p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>索引是为了加快对数据的搜索速度而设立的。索引是方案(schema)中的一个数据库对象，与表独立存放</li><li>索引的作用： 在数据库中用来加速对表的查询，通过使用快速路径访问方法快读定位数据，减少了磁盘的I/O</li><li>sql中的索引是非显示索引，也就是在索引创建之后，在用户撤销它之前不会再用到该索引的名字，但是索引在用户查询时会自动起作用</li><li><p>索引的创建有两种情况</p><ul><li>自动： 当在表上定义一个<code>primary key</code> 或者 <code>unique 约束条件</code>时，Oracle数据库自动创建一个对应的唯一索引</li><li>手动： 用户可以创建索引以加速查询</li></ul></li></ul><h3 id="开发使用索引的要点"><a href="#开发使用索引的要点" class="headerlink" title="开发使用索引的要点"></a>开发使用索引的要点</h3><ol><li>索引改善检索操作的性能，但降低数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引</li><li>索引数据可能要占用大量的存储空间</li><li>并非所有数据都适合于索引。唯一性不好的数据（如省）从索引得到的好处不比具有股鞥多可能值的数据（如姓名）从索引中得到的好处多</li><li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能是索引的备选</li><li>可以在索引中定义多个列（例如省+市），这样的索引只在省+市的顺序排序时游泳。如果想按城市排序，则这种索引没用</li></ol><h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><ul><li><p>创建</p><p><code>create index 索引名称 on 表名(列名1[,列名2]...);</code></p></li><li><p>删除</p><p><code>drop index 索引名</code></p></li></ul><h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><p>在设计和数据库有关的系统时，数据库表的设计至关重要，这些设计关系整个系统的架构，需要精心的仔细考虑。数据库的设计主要包含了设计表结构和表之间的联系，在设计的过程中，有一些规则应该遵守</p><p><strong>三范式的存在是为了减少数据库中的数据冗余</strong></p><h2 id="第一范式-1NF-：-确保每列保持原子性"><a href="#第一范式-1NF-：-确保每列保持原子性" class="headerlink" title="第一范式(1NF)： 确保每列保持原子性"></a>第一范式(1NF)： 确保每列保持原子性</h2><p>第一范式是最基本的范式，如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式</p><p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行，但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对“地址”中某一部分操作的时候将非常方便，这样设计才满足了数据库的第一范式。</p><p>所谓的第一范式是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即<strong>列不可分</strong></p><h2 id="第二范式-2NF-：-确保表中的每列都和主键相关"><a href="#第二范式-2NF-：-确保表中的每列都和主键相关" class="headerlink" title="第二范式(2NF)： 确保表中的每列都和主键相关"></a>第二范式(2NF)： 确保表中的每列都和主键相关</h2><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><h2 id="第三范式-3NF-必须先满足第二范式"><a href="#第三范式-3NF-必须先满足第二范式" class="headerlink" title="第三范式(3NF): 必须先满足第二范式"></a>第三范式(3NF): 必须先满足第二范式</h2><p>第三范式要求在一个数据库表中不包含已在其他表中已包含的非主关键字信息。</p><p>例如： 存在一个部门信息表，其中每个部门有部门编号(dep_id)、部门名称、部门简介等信息，那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门先关的信息加入员工信息表中。如果不存在部门信息表，则根据第三范式，应该创建部门信息表，否则会有大量的数据冗余。</p><p>第三范式就是属性不依赖于其他非主属性</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p><h1 id="DBUtil及数据库连接池"><a href="#DBUtil及数据库连接池" class="headerlink" title="DBUtil及数据库连接池"></a>DBUtil及数据库连接池</h1><h2 id="DBUtil"><a href="#DBUtil" class="headerlink" title="DBUtil"></a>DBUtil</h2><p>Commons DbUtils: JDBC Utility Component</p><p>Apache封装的JDBC工具组件</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池的目的是为了减少频繁开关连接的时间，提高整个系统的响应能力，数据库连接池应该具备几个属性值：</p><ol><li>初始大小</li><li>每次扩容的大小</li><li>连接池的最大个数</li><li>空闲连接的死亡时间</li></ol><p>各种数据库连接池：</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li><li>hikariCP</li></ul><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a><code>DBCP</code></h3><p>Apache提供的数据库连接池，目前用的比较少</p><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a><code>C3P0</code></h3><p>开源的数据库连接池</p><ol><li><p>下载Jar包并导入项目中</p></li><li><p>使用步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.*;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 加载mysql驱动</span></span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass( <span class="string">"com.mysql.jdbc.Driver"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置URL、用户名、密码         </span></span><br><span class="line">cpds.setJdbcUrl( <span class="string">"jdbc:postgresql://localhost/testdb"</span> );</span><br><span class="line">cpds.setUser(<span class="string">"dbuser"</span>); </span><br><span class="line">cpds.setPassword(<span class="string">"dbpassword"</span>);</span><br></pre></td></tr></table></figure><p><code>c3p0</code>若要通过配置文件进行参数配置，则配置文件必须放置在根目录，且文件名为<code>c3p0.properties</code>(properties文件)或<code>c3p0-config.xml</code>(xml文件)</p></li></ol><p><strong>JDBC4之前是必须要填写驱动名称的，但是之后的版本不需要填写</strong></p><h3 id="druid"><a href="#druid" class="headerlink" title="druid"></a><code>druid</code></h3><h3 id="hikariCP"><a href="#hikariCP" class="headerlink" title="hikariCP"></a><code>hikariCP</code></h3><p>配置参见官方文档</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库表的创建、表的约束、索引、数据库&quot;&gt;&lt;a href=&quot;#数据库表的创建、表的约束、索引、数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库表的创建、表的约束、索引、数据库&quot;&gt;&lt;/a&gt;数据库表的创建、表的约束、索引、数据库&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Database" scheme="http://garden.aezo.cn/categories/Database/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="Database" scheme="http://garden.aezo.cn/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法基础</title>
    <link href="http://garden.aezo.cn/2020/08/18/algorithm/dataStructure&amp;algorithm/"/>
    <id>http://garden.aezo.cn/2020/08/18/algorithm/dataStructure&amp;algorithm/</id>
    <published>2020-08-18T07:47:00.000Z</published>
    <updated>2023-11-28T09:21:53.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复杂度、对数器、二分法、异或运算"><a href="#复杂度、对数器、二分法、异或运算" class="headerlink" title="复杂度、对数器、二分法、异或运算"></a>复杂度、对数器、二分法、异或运算</h1><p>常见的评估算法优劣的核心指标：</p><ul><li>时间复杂度(流程决定)</li><li>额外空间复杂度(流程决定)</li><li>常数项时间(实现细节决定)</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>什么是常数时间的操作？<br>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间，这样的操作被称为常数时间的操作。</p><p>常见的常数时间操作：</p><ul><li>算数运算(+ - * % /)等</li><li>常见的位运算(&gt;&gt; &gt;&gt;&gt; &lt;&lt; | &amp; ^)等</li><li>赋值、比较、自增、自减操作</li><li>数组寻址操作</li></ul><p><strong>执行时间固定的操作都是常数时间的操作，执行时间不固定的操作，都不是常数时间的操作</strong></p><blockquote><p>JAVA中LinkedList的get(i)就不是常数时间的操作</p></blockquote><p>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</p><ol><li>想象该算法流程所处理的数据状况，要按照最差情况来</li><li>把整个流程彻底拆分为一个个基本动作，保证<strong>每个动作都是常数时间的操作</strong></li><li>如果数据为N,看看基本动作的数量和N是什么关系</li></ol><p>如何确定算法流程的时间复杂度？<br>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。<br>记为O(忽略掉系数的高阶项)</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度就是来衡量在整个流程中发生了多少次的常数操作这件事.</p><p>时间复杂度的意义：<br>当我们要处理的样本很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的；真正重要的是最高阶项</p><p>时间复杂度是衡量算法流程的复杂度的一种指标，该指标只与数据量有关，与过程之外的优化无关</p><p>常见的时间复杂度排序(从好到差): O(1) &gt; O(logN) &gt; O(N) &gt; O(N*logN) &gt; O(N²)  O(N³)… O(N^k) &gt; O(2^N) O(3^N)… O(k^N) &gt; O(N!)</p><h2 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h2><ul><li>选择排序O(n²)： 轮询数组，将最小的数放到最前面</li><li>冒泡排序O(n²)： 数组之间两两元素顺序交换，大的值放后面</li><li>插入排序：将i位置上的数与前面的数相比较，只要前面的数比它大，就交换</li></ul><p>注：</p><ul><li>算法的过程和具体的语言无关</li><li>想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉</li><li>一定要确保在拆分算法的流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己用过的每一个系统api都是非常熟悉，否则会影响你对时间复杂度的估算</li></ul><h2 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h2><p>实现算法流程的过程中，你需要开辟一些新的空间来支持你的算法流程</p><p>作为输入参数的空间，不算额外空间<br>作为输出结果的空间，不算额外空间</p><p>因为输入参数和输出结果都是必要的、和现实目标有关的，所以都不算额外空间</p><p>除上述以外，你的流程中如果还需要开辟空间才能继续下去，这部分的空间就是额外空间</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)</p><h2 id="常数项时间"><a href="#常数项时间" class="headerlink" title="常数项时间"></a>常数项时间</h2><p>时间复杂度这个指标是忽略低阶项和所有常数系数的。<br>但同样的时间复杂度的流程，运行时实际也并不是一样好。<br>时间复杂度只是一个重要指标，如果两个时间复杂度一样的算法还要咋时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p><p>两个流程的常数项时间进行比拼不采用理论分析，直接生成随机数据测试</p><h2 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h2><p>一般情况下认为，解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解</p><p>一般最优解都是忽略掉常数项的，因为常数项这个因素只决定了实现层次的优化和考虑，和怎么解决整个问题的思想无关。</p><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><ol><li>你想要测的方法a</li><li>实现复杂度不好，但是容易实现的方法b</li><li>实现一个随机样本产生器</li><li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</li><li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b</li><li>当样本数量很多时，比对测试依然正确，可以确定方法a已经正确</li></ol><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><blockquote><p>算术运算怎么转换成位运算？</p></blockquote><ul><li>在一个有序数组中，找某个数是否存在</li><li>在一个有序数组中，找&gt;=某个数最左侧的位置</li><li>在一个有序数组中，找&lt;=某个数最右侧的位置</li><li>局部最小值问题</li></ul><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><p>异或运算： 相同为0，不同为1<br>同或运算： 相同为1，不同为0</p><p>异或运算其实就是无进位的相加，即产生了进位则忽略成0</p><p>异或运算的性质:</p><ol><li>0 ^ N == N  N ^ N == 0</li><li>异或运算满足交换律和结合律</li></ol><h3 id="异或运算的应用"><a href="#异或运算的应用" class="headerlink" title="异或运算的应用"></a>异或运算的应用</h3><ol><li><p>如何不用额外变量交换两个数？<br> int a = m;<br> int b = n;<br> a = a ^ b;<br> b = a ^ b;<br> a = a ^ b;</p><p> 最终结果： a = n; b = m;</p><p> 以上的交换只能a b的值为两个不同的内存空间才能操作，若a=b=arr[i]则不能用以上方法，因此实际使用时还是使用临时变量temp进行交换</p></li><li><p>一个数组中有一种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这种数？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor = eor ^ arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码运行出来最终得到的eor的值就是出现了奇数次的数</p></li><li><p>如何把一个int类型的数提取出最右侧的1来？</p><p> 例如：int N = 00…1101010000</p><p> 将最右侧的1提取出来的结果是：00…0000010000</p><p> N &amp; ((~N) + 1)</p><p> 先将N取反，取反后的值+1，最后将这个值与N进行与运算得到的结果就是只保留最右侧的1其他位为0</p></li><li><p>一个数组中有两种数出现了奇数次，其他都出现了偶数次，怎么找到并打印这两种数？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用eor=0将所有数都^一遍，最终得到的结果 eor = a ^ b</span></span><br><span class="line"><span class="comment">// 且eor != 0,表示eor必然有一个位置上是1</span></span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">eor ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取eor中最右侧的1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor ^ ((~eor) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新的变量onlyOne=0,将所有与eor最右侧是1同类的数进行操作</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// (arr[i] &amp; rightOne) != 0表示arr[i]在rightOne中为1的位数上也是1</span></span><br><span class="line">onlyOne ^= arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上得到的onlyOne的结果是a或者b</span></span><br><span class="line"><span class="comment">// 出现奇数次的两个数a b 分别是 onlyOne和 eor^onlyOne</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="链表结构、栈、队列、递归行为、哈希表"><a href="#链表结构、栈、队列、递归行为、哈希表" class="headerlink" title="链表结构、栈、队列、递归行为、哈希表"></a>链表结构、栈、队列、递归行为、哈希表</h1><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><ul><li><p>单向链表节点结构(可以实现成范型)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向链表节点结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单向链表和双向链表最简单的练习"><a href="#单向链表和双向链表最简单的练习" class="headerlink" title="单向链表和双向链表最简单的练习"></a>单向链表和双向链表最简单的练习</h3><ul><li><p>单链表和双链表如何反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 单向链表单反转 */</span></span><br><span class="line">    <span class="comment">// 1. 定义单向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            value = date;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*双向链表反转*/</span></span><br><span class="line">    <span class="comment">// 1. 定义双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">        DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">        DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            head.last = next;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除给定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定删除head中值为num的节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首次遍历，过滤头节点为num的情况</span></span><br><span class="line">    <span class="comment">// 找到第一个不需要删的位置</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.value != num) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.value == num) &#123;</span><br><span class="line">            <span class="comment">// 当前值为num,将当前值的下一位赋于pre.next</span></span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前值保留,记录当前值</span></span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="逻辑概念"><a href="#逻辑概念" class="headerlink" title="逻辑概念"></a>逻辑概念</h3><ul><li><p>栈： 先进后出</p></li><li><p>堆： 先进先出</p></li></ul><h3 id="实际实现"><a href="#实际实现" class="headerlink" title="实际实现"></a>实际实现</h3><ul><li><p>双向链表实现</p></li><li><p>数组实现</p></li></ul><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ol><li><p>怎么用数组实现不超过固定大小的队列和栈</p><p>栈： 正常使用</p><p>队列： 环形数组</p></li><li><p>实现一个特殊的栈，在基本功能的基础上再实现返回栈中最小元素的功能</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;复杂度、对数器、二分法、异或运算&quot;&gt;&lt;a href=&quot;#复杂度、对数器、二分法、异或运算&quot; class=&quot;headerlink&quot; title=&quot;复杂度、对数器、二分法、异或运算&quot;&gt;&lt;/a&gt;复杂度、对数器、二分法、异或运算&lt;/h1&gt;&lt;p&gt;常见的评估算法优劣的核心指标
      
    
    </summary>
    
      <category term="algorithm" scheme="http://garden.aezo.cn/categories/algorithm/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="algorithm" scheme="http://garden.aezo.cn/tags/algorithm/"/>
    
      <category term="basic" scheme="http://garden.aezo.cn/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>面向面试查漏补缺</title>
    <link href="http://garden.aezo.cn/2020/08/18/java/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://garden.aezo.cn/2020/08/18/java/面向面试查漏补缺/</id>
    <published>2020-08-18T06:57:00.000Z</published>
    <updated>2023-02-24T08:23:43.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组相当于是一种数据结构，很多数据在进行存储的时候需要使用数组</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度： <code>O(n^2)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 冒泡排序: 前一个数字与后一个数字比较，若后者大于前者，两者交换</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length -<span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>平均时间复杂度：O(n2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 选择排序:</span></span><br><span class="line"><span class="comment">* 在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；</span></span><br><span class="line"><span class="comment">* 第二次遍历n-2个数，找到最小的数值与第二个元素交换；</span></span><br><span class="line"><span class="comment">* ...</span></span><br><span class="line"><span class="comment">* 第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取最小值下标</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; arr[j]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[k]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>平均时间复杂度：O(n2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 插入排序：</span></span><br><span class="line"><span class="comment">* 假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。</span></span><br><span class="line"><span class="comment">* 如此反复循环，直到全部排好顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 第n个数小于前n-1已排好序的数组的最后一位，换位</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第n个数大于前n-1已排好序的数组的最后一位，直接跳过进入第n+1个数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序：</span></span><br><span class="line"><span class="comment"> * 采用分治策略</span></span><br><span class="line"><span class="comment"> * 1．先从数列中取出一个数作为基准数。</span></span><br><span class="line"><span class="comment"> * 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</span></span><br><span class="line"><span class="comment"> * 3．再对左右区间重复第二步，直到各区间只有一个数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin 排序起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 排序最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[begin];<span class="comment">// 定义数组最左边一个数为基准值</span></span><br><span class="line">    <span class="keyword">boolean</span> rtl = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = begin;</span><br><span class="line">    <span class="keyword">int</span> right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rtl) &#123;</span><br><span class="line">            <span class="comment">// 从右往左移动，将右边的值与基准值比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[right] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 若右边的值小于基准值，将右边的值填入左边的位置上，左指针向后移动</span></span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                left++;</span><br><span class="line">                rtl = <span class="keyword">false</span>;<span class="comment">// 移动左指针</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右边的值大于基准值，右指针向前移动</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从左往右，将左边的值与基准值比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[left] &gt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 若左边的值大于基准值，将左边的值填入右指针位置，右指针向前移动</span></span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">                right--;</span><br><span class="line">                rtl = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            arr[left] = pivot;</span><br><span class="line">            <span class="comment">// 分别对左右数组排序</span></span><br><span class="line">            <span class="keyword">if</span>(left-<span class="number">1</span> &gt;= begin) &#123;</span><br><span class="line">                quickSort(arr, begin, left-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right+<span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">                quickSort(arr, right+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="常用的消息队列"><a href="#常用的消息队列" class="headerlink" title="常用的消息队列"></a>常用的消息队列</h2><p><code>ActiveMQ</code> <code>rabbitMQ</code> <code>rocketMQ</code> <code>kafka</code></p><h3 id="activeMQ"><a href="#activeMQ" class="headerlink" title="activeMQ"></a>activeMQ</h3><h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><h4 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h4><p>答题思路： 你们公司有什么业务场景，这个场景有什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多好处</p><p><strong>面试技巧</strong>： 考虑下你负责的系统中是否有类似场景，就是一个系统或者一个模块调用了多个系统或者模块，互相之间的调用很复杂， 维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的。你就需要去考虑在你的项目中，是不是可以运用这个MQ去进行系统的解释</p><ul><li>消息队列的常用场景： 解耦、异步、削峰</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;数组相当于是一种数据结构，很多数据在进行存储的时候需要使用数组&lt;/p&gt;
&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; clas
      
    
    </summary>
    
      <category term="others" scheme="http://garden.aezo.cn/categories/others/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="basic" scheme="http://garden.aezo.cn/tags/basic/"/>
    
      <category term="others" scheme="http://garden.aezo.cn/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://garden.aezo.cn/2020/08/17/java/beforeArchitect/SpringMVC/"/>
    <id>http://garden.aezo.cn/2020/08/17/java/beforeArchitect/SpringMVC/</id>
    <published>2020-08-17T14:02:00.000Z</published>
    <updated>2023-02-24T08:23:43.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC初识"><a href="#SpringMVC初识" class="headerlink" title="SpringMVC初识"></a>SpringMVC初识</h1><h2 id="什么是MVC？"><a href="#什么是MVC？" class="headerlink" title="什么是MVC？"></a>什么是MVC？</h2><p><code>MVC</code>是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。将业务逻辑、数据、显示分离方法来组织代码。MVC主要作用是降低了视图与业务逻辑间的双向耦合。是一种<strong>架构模式</strong></p><p><code>Model</code>(模型): 数据模型。提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都是分离开来： Value Object（数据DAO） 和服务层（行为Service），也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p><p><code>View</code>(视图)： 负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西</p><p><code>Controller</code>（控制器）： 接收用户请求、委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。控制器做了个调度员的工作</p><p><strong>最典型MVC: JSP + Servlet + JavaBean</strong></p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是Spring框架的一个模块</p><p>SpringMVC运行流程：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC初识&quot;&gt;&lt;a href=&quot;#SpringMVC初识&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC初识&quot;&gt;&lt;/a&gt;SpringMVC初识&lt;/h1&gt;&lt;h2 id=&quot;什么是MVC？&quot;&gt;&lt;a href=&quot;#什么是MVC？&quot; c
      
    
    </summary>
    
      <category term="framework,SpringMVC" scheme="http://garden.aezo.cn/categories/framework-SpringMVC/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="framework" scheme="http://garden.aezo.cn/tags/framework/"/>
    
      <category term="SpringMVC" scheme="http://garden.aezo.cn/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://garden.aezo.cn/2020/08/10/java/beforeArchitect/spring/"/>
    <id>http://garden.aezo.cn/2020/08/10/java/beforeArchitect/spring/</id>
    <published>2020-08-10T13:13:00.000Z</published>
    <updated>2023-06-02T02:52:52.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring初识"><a href="#Spring初识" class="headerlink" title="Spring初识"></a>Spring初识</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>什么是框架？某些个人或组织定义了一系列的类或接口，提前定义好一些实现，用户可以在这些类和接口的基础上使用这些类来迅速形成某个领域或者某个行业的解决方案，简化开发过程，提高开发效率。</p><h2 id="软件设计发展历程"><a href="#软件设计发展历程" class="headerlink" title="软件设计发展历程"></a>软件设计发展历程</h2><h3 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h3><p>ORM： Object Relational Mapping 对象关系映射</p><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起以减少部署节点和成本，此时用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>当访问量逐渐增大，单一应用增加及其带来的及速度月俩月小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率此时用于加速前端页面开发的Web框架(MVC)是关键。</p><h3 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h3><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务服用及整合的分布式服务框架(RPC)是关键。</p><h3 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><p><strong>Spring出现之前使用的是EJB</strong></p><h2 id="主流框架演变之路"><a href="#主流框架演变之路" class="headerlink" title="主流框架演变之路"></a>主流框架演变之路</h2><ol><li><p>JSP + Servlet + JavaBean</p><ul><li><p>JSP: Java Server Page 能内置Java代码，但配置比较麻烦</p></li><li><p>Servlet: Server Applet</p></li><li><p>JavaBean: 更多用于描述现实世界某个具体事物的抽象</p></li></ul></li><li><p>MVC三层架构</p><p>Model + View + Control</p><p> 层次分清，耦合性低</p></li><li><p>使用EJB进行应用开发，但是EJB是重量级框架，使用时有过多的接口和依赖，侵入性强，在使用上比较麻烦</p></li><li><p>SSH(Struts1/Struts2 + Hibernate + Spring)</p></li><li><p>SpringMVC + MyBatis + Spring</p></li><li><p>SpringBoot开发，约定大于配置</p></li></ol><h1 id="Spring理论概念"><a href="#Spring理论概念" class="headerlink" title="Spring理论概念"></a>Spring理论概念</h1><p><strong>Spring框架作为主流框架立于不败之地在于其生态</strong></p><p>官网： <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></p><h2 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h2><ul><li><p>GA（General Availability）：表示正式发布的版本，官方推荐使用此版本</p></li><li><p>PRE： 预览版，内部测试版，主要给开发人员和测试人员测试用</p></li><li>SNAPSHOT： 快照版，可稳定使用，且仍在继续改进版本</li></ul><h2 id="核心解释"><a href="#核心解释" class="headerlink" title="核心解释"></a>核心解释</h2><p>Spring是一个开源框架，为了简化企业开发而生，使开发变得更加优雅和简洁</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>通过DI、AOP和消除样板式代码来简化企业开发</p></li><li><p>Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同领域，如Web服务、REST、移动开发以及NoSQL</p></li><li>低侵入式设计，代码的污染极低</li><li>独立于各种应用服务器，基于Spring的框架的应用可以真正实现Write Once, Run Anywhere</li><li>Spring的IOC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的服用</li><li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>Spring的高度开放性，并不强制应用完全依赖于Spring,开发者可自由选用Spring框架的部分或者全部</li></ol><h2 id="IOC-Inversion-of-Control-控制反转"><a href="#IOC-Inversion-of-Control-控制反转" class="headerlink" title="IOC(Inversion of Control) 控制反转"></a>IOC(Inversion of Control) 控制反转</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>IOC与依赖注入(DI)同理，这是一个通过依赖注入对象的过程，也就是说他们所使用的对象，是通过构造函数参数、工厂方法的参数或从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。这个过程相对于普通创建对象的过程是反向的，因此称之为IOC。</p><p>谁控制谁： IOC容器控制对象</p><p>控制什么： 实现过程中所需要依赖的对象</p><p>什么是反转： IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转；有了IOC之后依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转</p><p>哪些方面被反转：依赖的对象</p><h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>IOC是设计思想，DI是具体的实现方式</p><p>DI： Dependency Injecttion 依赖注入</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>耦合关系不仅是对象与对象之间，也会出现在软件系统的各个模块之间。可通过IOC来实现对象之间的解耦</p><h1 id="Spring的使用"><a href="#Spring的使用" class="headerlink" title="Spring的使用"></a>Spring的使用</h1><p>Spring核心模块包：Beans Core Context SpEL(Spring expression)</p><p>beans和context包是Spring IoC的核心包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>);</span><br><span class="line">context.getBean(<span class="string">"对象名"</span>);</span><br></pre></td></tr></table></figure><p>ApplicationContext表示IOC容器入口，想要获取对象，必须要创建该类。该类有两个读取配置文件的实现类：</p><ul><li>ClassPathXmlApplicationContext： 表示从classpath中读取数据（常用）</li><li>FileSysytemXmlApplicationContext: 表示从当前文件系统读取数据</li></ul><p>使用<code>context.getBean(&quot;person&quot;)</code>来获取对象，需要进行类型强转</p><p><code>context.getBean(&quot;person&quot;, Person.Class)</code> 这种方式获取对象时不需要强转数据类型</p><p>这种方式无需手动创建对象，而是将创建对象的过程交给了spring容器。容器中的对象在容器创建完成之前就已经把对象创建好了，<br>即使没有使用getBean方法来获取对象，对象也已经创建好了，而不是get的时候再创建</p><p>对象的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"对象所在包"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;bean&gt;</code>标签表示要创建的bean对象：</p><ul><li>id为bean的唯一标识，为了与其他bean进行区分</li><li>class表示要创建的bean的完全限定名</li><li>property标签表示bean的属性，name为名称，value为具体的属性值</li></ul><h2 id="通过Maven的方式来创建项目"><a href="#通过Maven的方式来创建项目" class="headerlink" title="通过Maven的方式来创建项目"></a>通过Maven的方式来创建项目</h2><h3 id="第一步-导包"><a href="#第一步-导包" class="headerlink" title="第一步 导包"></a>第一步 导包</h3><p>使用IDEA选择Maven创建Spring项目，创建完成后会自动生成pom.xml配置文件</p><p>在Pom.xml文件里面添加Spring配置包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第二步-创建对象文件"><a href="#第二步-创建对象文件" class="headerlink" title="第二步 创建对象文件"></a>第二步 创建对象文件</h3><p>在java文件夹下创建所需的对象属性</p><h3 id="第三步-创建配置文件"><a href="#第三步-创建配置文件" class="headerlink" title="第三步 创建配置文件"></a>第三步 创建配置文件</h3><p>在resource文件夹下创建对应的配置文件</p><h3 id="第四步-测试对象是否创建成功"><a href="#第四步-测试对象是否创建成功" class="headerlink" title="第四步 测试对象是否创建成功"></a>第四步 测试对象是否创建成功</h3><p>注意： 配置文件的位置不要放错</p><h2 id="Spring总结"><a href="#Spring总结" class="headerlink" title="Spring总结"></a>Spring总结</h2><ol><li><p>ApplicationContext就是IOC容器的接口，可以通过此对象获取容器中创建的对象</p></li><li><p>对象在Spring容器中默认是在容器创建完成之前就已经创建完成，不是需要用的时候才创建。多例模式下不会提前创建对象</p></li><li><p>对象在IOC容器中存储的时候都是单例的，如果需要多例则需要修改属性</p><p>在xml配置文件的bean上添加属性 <code>scope=prototype</code>,变成多例模式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"奇一星"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建对象给属性赋值的过程是通过setter方法实现的</p></li><li><p>对象的属性是由setter/getter方法决定的，而不是定义的成员属性</p></li></ol><h2 id="Spring对象的获取和属性赋值的方式"><a href="#Spring对象的获取和属性赋值的方式" class="headerlink" title="Spring对象的获取和属性赋值的方式"></a>Spring对象的获取和属性赋值的方式</h2><ol><li><p>通过bean的id获取IOC容器中的对象： <code>context.getBean(&quot;bean的id&quot;)</code></p></li><li><p>通过bean的类型获取对象: <code>context.getBean(Person.class)</code></p><p>根据类型获取对象时，如果存在两个相同的类型的对象则会报错</p></li><li><p>通过构造器给bean对象进行赋值</p><p>当需要从容器中获取对象的时候，最好要保留无参构造方法，因为底层的实现是反射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"LuckyStar"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置构造器时如果出现了报错，说明对应的对象里面没有找到该构造函数。此时参数的name属性是根据构造方法的参数名称决定的。name属性可以省略不写，但是需要注意顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"ioc.xml"</span>);</span><br><span class="line">Person person = context.getBean(<span class="string">"person2"</span>, Person.class);</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure><p>在进行框架配置的时候，可以使用xml文件，也可以使用注解的方式。实际项目中是xml配置和注解配置一起使用</p></li><li><p>通过命名空间为bean赋值，简化配置文件中属性声明的写法</p><p>使用p命名空间来给属性赋值</p><ol><li>引入p命名空间， 添加<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code>；xmlns xml命名空间(namespace) 简称</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用p命名空间简写，省略property</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person3"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">p:id</span>=<span class="string">"3"</span> <span class="attr">p:name</span>=<span class="string">"一星"</span> <span class="attr">p:age</span>=<span class="string">"18"</span> <span class="attr">p:gender</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为复杂类型进行赋值操作</p><p>复杂类型如集合、数组、其他对象等。</p><p>对象实体类Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qiyixing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String[] hobbies;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; lists;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Map&lt;String, Object&gt; map;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">               <span class="string">"id="</span> + id +</span><br><span class="line">               <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", age="</span> + age +</span><br><span class="line">               <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", hobbies="</span> + Arrays.toString(hobbies) +</span><br><span class="line">               <span class="string">", address="</span> + address +</span><br><span class="line">               <span class="string">", lists="</span> + lists +</span><br><span class="line">               <span class="string">", map="</span> + map +</span><br><span class="line">               <span class="string">", sets="</span> + sets +</span><br><span class="line">               <span class="string">", properties="</span> + properties +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String[] getHobbies() &#123;</span><br><span class="line">      <span class="keyword">return</span> hobbies;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbies</span><span class="params">(String[] hobbies)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hobbies = hobbies;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.address = address;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">getLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lists;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLists</span><span class="params">(List&lt;Address&gt; lists)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lists = lists;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.map = map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sets;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sets = sets;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> properties;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.properties = properties;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"person被创建"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的配置文件ioc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"奇一星"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 使用array标签为数组赋值 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>book<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>movie<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 使用ref给引用类型赋值 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给list赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 使用内部bean,无法从容器中直接获取对象的值，即使用context.getBean("address2")是无法获取到数据的--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address2"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"江西"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"湖北"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">&lt;!-- 使用外部bean， 可以使用context.getBean("address")获取到address对象--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给set属性赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sets"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 给Map赋值,entry可以有各种写法--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"111"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"address"</span> <span class="attr">value-ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"address2"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"江西"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>keykeykey<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">value</span>&gt;</span>val<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!--给properties赋值--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"111"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"222"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"town"</span> <span class="attr">value</span>=<span class="string">"上海"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>继承关系bean的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"4"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"父类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"son"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"子类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>context.getBean(&quot;son&quot;)</code>能将son和parent的值都获取到</p><p>如果只想实例化子类不想实例化父类，可以将父类变成抽象类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"4"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"父类"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时<code>context.getBean(&quot;parent&quot;)</code>会报错，因为抽象类不能被实例化</p></li><li><p>bean对象创建的依赖关系</p><p>bean对象创建时，是按照xml配置文件定义的顺序创建的，写在前面的类会先被创建，后面的类后创建。如果需要打乱这种创建顺序，可以使用属性<code>depends-on</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述情况会先创建person对象后创建address对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">depends-on</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上属性<code>depends-on</code>之后则是先创建address对象后创建person对象。实际工作中不需要关注bean的创建顺序</p></li><li><p>bean的作用于控制，是否是单例</p><p><code>scope</code>属性可以指定当前bean的作用域，默认是单例模式singleton;prototype表示多例模式；</p><p>Spring4.x版本中还包含另外两种作用域：request和session</p><p>request表示请求，每次发送请求都会有一个新的对象</p><p>session表示吗，每次会话都会有一个新的对象</p><p>但request和session几乎不用，因此5.x之后就淘汰了</p><p>单例作用域在IOC容器创建之前就已经创建了bean对象，多例作用域只有在获取对象的的时候才会创建对象</p></li><li><p>利用工厂模式创建bean对象</p><p>之前的案例中，所有bean对象都是通过反射得到bean实例，Spring中还包含另外一种通过工厂模式创建对象的方式。利用工厂模式创建bean对象分为静态工厂和实例工厂</p><p>静态工厂： 工厂本身不需要创建对象，但可以通过静态方法调用，对象=工厂类.静态方法名()</p><ul><li><p>创建java静态工厂类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonStaticFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">1</span>);</span><br><span class="line">      person.setName(name);</span><br><span class="line">      person.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用静态工厂方法创建bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personStatic"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.PersonStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"静态工厂创建的bean"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>实例工厂： 工厂本身需要创建对象，工厂类 工厂对象=new 工厂类； 工厂对象.get对象名()</p><ul><li><p>创建java实例工厂类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInstanceFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">2</span>);</span><br><span class="line">      person.setName(name);</span><br><span class="line">      person.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用实例工厂方法创建bean --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 先创建工厂实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.PersonInstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 调用工厂实例方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personInstance"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.bean.Person"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"实例工厂创建的bean"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>   <code>factory-bean</code>是指具体的工厂实例；<code>factory-method</code>指的是工厂类中的方法，方法中的参数写在<code>constructor-arg</code>中</p><ol start="10"><li><p>继承FactoryBean来创建对象</p><p>  FactoryBean是Spring规定的一个接口，当前接口的实现FactoryBean类时，Spring都会将其作为一个工厂，但是在ioc容器启动的时候不会创建实例，只有在使用的时候才会创建对象。</p><ul><li><p>创建自定义对象实现FactoryBean类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回获取的bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setId(<span class="number">7</span>);</span><br><span class="line">      person.setName(<span class="string">"继承FactoryBean创建对象"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回获取的bean的类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">      <span class="keyword">return</span> Person.class;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前bean是否是单例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置此对象,即表示将自定义的FactoryBean交由spring的IoC容器管理</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myFactoryBean"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.MyFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>此方式是Spring创建对象的一种补充，用户可以按照需求创建对象，创建的对象交由Spring IoC进行管理，对象只有在被用到时才会被创建</code></pre><ol start="11"><li><p>对象的初始化和销毁方法</p><p>Spring在创建对象的时候可以指定具体的初始化和销毁方法,属性分别为<code>init-method</code>和<code>destory-method</code></p></li><li><p>配置bean对象初始化方法的前后处理方法</p><p>Spring中包含一个BeanPostProcessor的接口，可以在bean的初始化方法的前后调用该方法，如果配置了初始化方法的潜质和后置处理器，无论是否包含初始化方法，都会进行调用</p><ul><li><p>编写前置/后置处理器业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化方法前置处理器</span></span><br><span class="line"><span class="comment">   * 在每一个对象的初始化方法前面执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"postProcessBeforeInitialization: "</span> + beanName);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化方法后置处理器</span></span><br><span class="line"><span class="comment">   * 在每一个对象的初始化方法后面执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"postProcessAfterInitialization: "</span> + beanName);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件，交由Spring容器管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.factory.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>   运行测试用例后可以看出，无论是否指定初始化方法，<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>都会被执行，并且是在每个对象创建之后都会执行一次</p><h2 id="Spring创建第三方bean对象"><a href="#Spring创建第三方bean对象" class="headerlink" title="Spring创建第三方bean对象"></a>Spring创建第三方bean对象</h2><p>Spring中，很多对象都是单例的，日常开发中经常需要使用某些外部的单实例对象，例如数据库连接池等，此时就需要在Spring中创建第三方Bean实例。</p><ol><li><p>导入数据库连接池的Pom文件</p><p>在<code>pom.xml</code>文件中添加以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置xml文件管理bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3360/demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>context.getBean(&quot;dataSource&quot;, DruidDataSource.class)</code>获取bean对象</p></li></ol><h2 id="Spring引入第三方配置文件"><a href="#Spring引入第三方配置文件" class="headerlink" title="Spring引入第三方配置文件"></a>Spring引入第三方配置文件</h2><ol><li><p>新建properties文件 <code>db.properties</code>,在配置文件中写业务相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql://localhost:3360/demo</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure></li><li><p>在ioc.xml文件中导入一些context命名空间</p><p><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p><p><code>http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</code></p><p>完整配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   "</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource2"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driverClassName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring容器在进行启动的时候会读取当前系统的某些环境变量的配置，因此最好的方式是添加前缀来做区分，例如数据库中的username改为jdbc.username</p></li></ol><h2 id="基于xml文件自动装配"><a href="#基于xml文件自动装配" class="headerlink" title="基于xml文件自动装配"></a>基于xml文件自动装配</h2><p>   Spring自动装配会把某些bean注入到另外的bean中，使用<code>autowire</code>属性实现，<code>autowire</code>属性取值：</p><ul><li><p><code>default/no</code>不装配</p></li><li><p><code>byName</code> 根据set方法后面首字母小写的名称装配</p></li><li><p><code>byType</code> 按照bean的类型进行装配，但是如果有多个类型就会报错</p></li><li><p><code>constructor</code> 按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接配null；如果按类型找到了多个，那么就是用参数名为id继续匹配，匹配不到就null</p></li></ul><h2 id="基于SpEL的使用"><a href="#基于SpEL的使用" class="headerlink" title="基于SpEL的使用"></a>基于SpEL的使用</h2><p>   SpEL： Spring Expression Language. Spring的表达式语言，支持运行时查询操作对象，使用<code>#{}</code>作为语法规则，所有的大括号中的字符都认为是SpEL</p><h2 id="Spring-Ioc的注解应用"><a href="#Spring-Ioc的注解应用" class="headerlink" title="Spring Ioc的注解应用"></a>Spring Ioc的注解应用</h2><h3 id="使用注解的方式将bean注册到spring-IoC容器中"><a href="#使用注解的方式将bean注册到spring-IoC容器中" class="headerlink" title="使用注解的方式将bean注册到spring IoC容器中"></a>使用注解的方式将bean注册到spring IoC容器中</h3><p>常用注解： <code>@Component</code> <code>@Controller</code> <code>@Service</code> <code>@Repository</code> </p><p>这四个注解写在类上面的时候就能完成注册bean的功能，Spring并不会根据这些注解进行区分，而是直接扫描注册，这四个注解主要是为了在实际开发中区分开来以提高代码的可读性</p><ul><li><p><code>@Component</code></p><p>组件，理论上可以在任何类上添加，扫描时会完成注册</p></li><li><p><code>@Controller</code></p><p> 放在控制层，用于接收用户的请求</p></li><li><p><code>@Service</code></p><p> 放在业务逻辑层</p></li><li><p><code>@Repository</code></p><p> 放在数据访问层</p></li></ul><p>在使用注解的时候必须先告诉Spring应该从哪个包开始扫描，在配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用注解的时候没有定义id和class,需要把当前类的名称首字母小写作为识别。例如定义一个<code>PersonController</code>类，添加注解<code>@Controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试用例中使用<code>context.getBean(&quot;personController&quot;, PersonController.class)</code>就能获取到对象，但如果getBean的名称不是personController则会报错<code>No bean named &#39;xxx&#39; available</code>。如果需要改变名称，则需要在注解上添加value属性<br>即 <code>@Controller(value=&quot;xxx&quot;)</code></p><p>组件默认情况下都是单例的，如果需要配置多例模式，可以在注解下添加<code>@Scope</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义扫描包时要包含的类和不包含的类"><a href="#定义扫描包时要包含的类和不包含的类" class="headerlink" title="定义扫描包时要包含的类和不包含的类"></a>定义扫描包时要包含的类和不包含的类</h3><p><code>&lt;context:component-scan base-package=&quot;com.qiyixing&quot;&gt;&lt;/context:component-scan&gt;</code>这种写法只能定义需要扫描的包，如果想要跳过一些包的扫描，则需要使用属性<code>context:exclude-filter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 需要包含扫描的注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 需要排除扫描的注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>type表示规则的类型，expression为表达式。type的可选值有： </p><ul><li><p>assignable</p><p> 可以指定对应类的名称，但expression必须是完全限定名，不能写*这种通配符</p></li><li><p>annotation</p><p> 注解，expression必须是注解的完全限定名</p></li><li><p>regex</p><p> 正则表达式 一般不用</p></li><li><p>aspectj</p><p> 使用切面的方式，一般不用</p></li><li><p>custom</p><p> 使用自定义方式，自定义筛选规则，一般不用</p></li></ul><h3 id="自动装配的注解-Autowired和-Resource"><a href="#自动装配的注解-Autowired和-Resource" class="headerlink" title="自动装配的注解@Autowired和@Resource"></a>自动装配的注解@Autowired和@Resource</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p><code>@Autowired</code> 自动注入的注解，默认情况下是按照byType来进行装配的</p><ul><li><p>如果只找到一个类型，直接赋值；</p></li><li><p>如果没找到则抛出异常；</p></li><li><p>如果找到多个类型一样的，则会按照id来进行查找，默认id是类名首字母小写(存在多个类型的时候不能乱取名字)</p></li></ul><p>如果想要通过名字进行查找，可以规定自己的名称，使用注解<code>@Qualifier</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"personService"</span>)</span><br><span class="line"><span class="keyword">private</span> PersonService personService2;</span><br></pre></td></tr></table></figure><p>Autowired一般放在属性上，还能别的地方。</p><p>当@Autowired放在方法上时，此方法在创建对象的时候会默认调用，方法中的参数会进行自动装配；</p><p>@Qualifier注解也可以定义在方法的参数列表中，可以指定当前属性的id名称</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>使用@Resource可以完成与@Autowired相同的功能，但两者还有些区别：</p><ul><li><p>@Resource是JDK提供的功能，@Autowired是Spring提供的功能</p></li><li><p>@Resource可以在其他框架中使用，@Autowired只能在Spring中提供</p></li><li><p>@Resource扩展性好，@Autowired支持的框架比较单一</p></li><li><p>@Resource是按照名称进行装配的，如果名字找不到就使用类型；@Autowired是按照类型进行装配，类型找不到就使用名字</p></li></ul><h3 id="泛型依赖注入"><a href="#泛型依赖注入" class="headerlink" title="泛型依赖注入"></a>泛型依赖注入</h3><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP Aspect Oriented Programming 面向切面编程</p><p>OOP Object Oriented Programming 面向对象编程</p><p>面向切面编程是基于OOP基础上的新的编程思维，OOP面向的主要对象是类，而AOP面向的主要时切面，在处理日志、安全管理、事务管理等方面有非常重要的作用。</p><p>AOP是Spring中重要的核心点，虽然IoC容器没有依赖AOP，但AOP提供了非常强大的功能，用来作IoC的补充。</p><p>通俗来说，AOP就是将某段代码动态切入到指定方法的指定位置进行运行的编程方式</p><p>Spring中使用两种动态代理方式，一种是JDK提供的，另一种是cglib</p><p>使用JDK提供的reflect包下的类要求每个类都要有实现的接口，但实际开发中并不能保证如此，因此需要换cglib的方式</p><p>Spring AOP 的底层原理是动态代理</p><p>切面： 关注点模块化。Spring SOP中，切面可以使用通用类基于模式方式或者在普通类中使用注解@AspectJ来实现</p><p>通知： 在切面的某个特定的连接点上执行的动作，很多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链</p><pre><code>通知的注解有以下几种类型： - @Before 前置通知，在方法执行前完成- @After 后置通知，在方法执行后完成- @AfterReturning 返回通知，在返回结果之后运行- @AfterThrowing 异常通知，出现异常的时候使用- @Around 环绕通知，</code></pre><p>连接点： 每个方法中可以填入额外代码的地方</p><p>切入点： 切入点是连接点的子集，是直接切入代码的连接点。可以通过表达式来控制切入点</p><p>织入： 把切面连接到其他应用程序类型或对象上，并创建一个被通知的对象的过程</p><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><ol><li><p>导入依赖: <code>spring-aop</code>(可不导入，Spring-context中已集成此依赖) <code>cglib</code> <code>aspectJ</code> <code>aop alliance</code> <code>Spring Aspects</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置</p><ul><li>将目标类和切面类加入到Ioc容器中，在对应的类上添加组件注解</li></ul><p>@Aspect 将类声明成切面类 @Component 将类交由Spring管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Before</span>的后面固定写execution，execution里面写方法名的完全限定名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Before</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法开始执行"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterReturning</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法结束执行"</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterThrowing</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法抛出异常"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"方法执行结束： over"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将服务注册到Spring Ioc 容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalculator</span> <span class="keyword">implements</span> <span class="title">Calculator</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer i, Integer j)</span> </span>&#123;</span><br><span class="line">      Integer result = i+j;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置spring扫描包，配置AOP注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 开启包的扫描 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.qiyixing"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 开启AOP注解 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>Spring AOP底层使用动态代理，使用时会判断当前对象是否有对应的接口，若有则使用JDK代理模式，没有接口则是cglib代理模式</p><p>早期JDK性能不如cglib，但由于JDK不断在更新，cglib没在更新，两者性能差不多</p><h3 id="切入点的表达式"><a href="#切入点的表达式" class="headerlink" title="切入点的表达式"></a>切入点的表达式</h3><p>切入点的表达式使用完全限定名（如<code>@Before(&quot;execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))&quot;)</code>）过于死板，实际开发中更多使用的是通配符的方式</p><ul><li><p>通配符 <code>*</code> </p><ol><li><p>可以用来匹配一个或多个字符</p><p><code>execution(public Integer com.qiyixing.service.MyCalculator.*(Integer, Integer))</code></p><p>匹配MyCalculator类中所有的方法</p></li><li><p>可以用来匹配任意类型的参数</p><p><code>execution(public Integer com.qiyixing.service.MyCalculator.*(*, *))</code></p></li><li><p>*在进行匹配的时候只能匹配一层路径，不能匹配多层</p></li><li><p>*不能用来匹配访问修饰符，如果不确定访问修饰符可以不写</p><p> <code>execution(Integer com.qiyixing.service.MyCalculator.*(*, *))</code></p></li><li><p>返回值可以使用*来匹配</p><p> <code>execution(* com.qiyixing.service.MyCalculator.*(*, *))</code></p></li></ol></li><li><p>通配符<code>..</code></p><ol><li><p>可以用来匹配多个参数，任意类型</p><p><code>execution(* com.qiyixing.service.MyCalculator.*(..))</code></p></li><li><p>可以匹配多层路径</p><p><code>execution(* com.qiyixing.service..*(..))</code></p></li></ol></li></ul><p>表达式最偷懒的方式就是写成<code>* *(..)</code>,表达式以<code>*</code>开头能代表所有</p><p>使用通配符不是越简洁越好，更多的是要符合要求或者符合项目规则的匹配方式</p><ul><li><p>逻辑运算<code>&amp;&amp;</code>(与) <code>||</code>(或) <code>!</code>(非)</p><p> <code>execution(* com.qiyixing.service.MyCalculator.*(..)) &amp;&amp; execution(* *(..))</code></p><p> 同时满足两种表达式</p><p> <code>execution(* com.qiyixing.service.MyCalculator.*(..)) || execution(* *(..))</code></p><p> 两种表达式满足一种就行</p><p>  <code>execution(* com.qiyixing.service.MyCalculator.*(..)) || execution(* *(..))</code></p></li></ul><p>通知的执行顺序：</p><p>   正常执行： @Before –&gt; @After –&gt; @AfterReturning</p><p>   发生异常： @Before –&gt; @After –&gt; @AfterThrowing</p><p>如果要在方法中获取对应的参数或者方法名称等信息，必须使用JoinPoint对象，且此参数必须是第一个。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">   Signature signature = joinPoint.getSignature();<span class="comment">// 获取方法签名</span></span><br><span class="line">   Object[] args = joinPoint.getArgs();<span class="comment">// 获取参数信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"方法开始执行.方法签名："</span> + signature + <span class="string">";方法参数："</span>+ args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法中有返回值，那么必须要在注解中添加Returning=”xxx”，这个xxx必须要和参数列表中的参数名称保持一致</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(value = <span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"方法结束执行"</span> + result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果需要添加异常信息，注解中需要添加throwing=”xxx”,xxx必须和参数列表中的名称保持一致</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Throwable e)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"方法抛出异常"</span> + e.getMessage());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通知方法在定义时，对于访问修饰符 类型都没有明确要求，但是参数不能随便添加</p><p>若多个匹配的表达式相同，则可以将表达式抽象出来</p><p>   先定义一个无返回值的空方法，将此空方法添加注释@PointCut,填入表达式</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.add(Integer, Integer))"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>   使用时可直接调用空方法</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"myPointCut()"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">     Signature signature = joinPoint.getSignature();<span class="comment">// 获取方法签名</span></span><br><span class="line">     Object[] args = joinPoint.getArgs();<span class="comment">// 获取参数信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"方法开始执行.方法签名："</span> + signature + <span class="string">";方法参数："</span>+ args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Around通知"><a href="#Around通知" class="headerlink" title="Around通知"></a>Around通知</h3><p>环绕通知<code>@Around</code>,执行时优先于普通通知</p><p>正常结束执行顺序： </p><p>环绕前置通知 –&gt; @Before –&gt; 环绕后置通知 –&gt; 环绕返回通知 –&gt; @After –&gt; @AfterReturning</p><p>发生异常的执行顺序：</p><p>环绕前置通知 –&gt; @Before –&gt; 环绕异常通知 –&gt; 环绕返回通知 –&gt; @After –&gt; @AfterThrowing</p><p>如果环绕通知中捕获了异常，那么在普通通知中无法接收到的，如果想要普通通知接收异常，则不能捕获异常只能抛出</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="meta">@Around</span>(value = <span class="string">"myPointCut()"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">   Signature signature = pjp.getSignature();</span><br><span class="line">   Object[] args = pjp.getArgs();</span><br><span class="line">   Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过反射的方式调用目标方法，相当于执行method.invoke()</span></span><br><span class="line">      result = pjp.proceed(args);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      throwable.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个切面类执行顺序"><a href="#多个切面类执行顺序" class="headerlink" title="多个切面类执行顺序"></a>多个切面类执行顺序</h3><p>   当应用程序中包含多个切面类时，默认的执行顺序是按照切面类的类名首字母进行排序，按照字典序</p><p>   如果要指定执行顺序，需要在切面类上添加注释<code>@Order()</code> 例如<code>@Order(100)</code> 比 <code>@Order(200)</code>先执行</p><h3 id="使用配置文件配置AOP"><a href="#使用配置文件配置AOP" class="headerlink" title="使用配置文件配置AOP"></a>使用配置文件配置AOP</h3><ol><li><p>创建xml文件，导入aop命名空间</p></li><li><p>配置bean，扫描切面</p></li><li><p>配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logUtil"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.utils.LogUtil"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCalculator"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.service.MyCalculator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logUtil"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"start"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"logFinally"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"stop"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">returning</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"logException"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">throwing</span>=<span class="string">"e"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>配置文件也能将表达式抽取出来：</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logUtil"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.utils.LogUtil"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCalculator"</span> <span class="attr">class</span>=<span class="string">"com.qiyixing.service.MyCalculator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logUtil"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"start"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"logFinally"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"stop"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">returning</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"logException"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> <span class="attr">throwing</span>=<span class="string">"e"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以将表达式抽取到最外层，这样多个切面都能用</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"globalPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(public Integer com.qiyixing.service.MyCalculator.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"bbb"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="声明式事务和传播特性"><a href="#声明式事务和传播特性" class="headerlink" title="声明式事务和传播特性"></a>声明式事务和传播特性</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring初识&quot;&gt;&lt;a href=&quot;#Spring初识&quot; class=&quot;headerlink&quot; title=&quot;Spring初识&quot;&gt;&lt;/a&gt;Spring初识&lt;/h1&gt;&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="framework,Spring" scheme="http://garden.aezo.cn/categories/framework-Spring/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="Spring" scheme="http://garden.aezo.cn/tags/Spring/"/>
    
      <category term="framework" scheme="http://garden.aezo.cn/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://garden.aezo.cn/2020/08/10/java/beforeArchitect/networkBase/"/>
    <id>http://garden.aezo.cn/2020/08/10/java/beforeArchitect/networkBase/</id>
    <published>2020-08-10T11:11:00.000Z</published>
    <updated>2023-02-24T08:23:43.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>什么是服务器？</p><p>服务器又称伺服器，只要是一台功能、性能差不多的电脑就能作为服务器。</p><p>服务器的主要作用是提供数据来源</p><p>Apache服务器： 世界排名第一的Web服务器软件</p><p>Nginx服务器： 高性能Http和反向代理web服务器</p><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>域名解析： 目的是让服务器认识域名，让域名也认识服务器</p><h2 id="超文本传输协议-HTTP协议"><a href="#超文本传输协议-HTTP协议" class="headerlink" title="超文本传输协议(HTTP协议)"></a>超文本传输协议(HTTP协议)</h2><h3 id="认知HTTP协议"><a href="#认知HTTP协议" class="headerlink" title="认知HTTP协议"></a>认知HTTP协议</h3><p>在网络请求别人网站的时候，地址(URL)必须以HTTP或HTTPs开头</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ol><li><p>当用户在浏览器地址栏中输入网址(URL)后按回车后到底发生了什么？</p><p> 用户输入地址按回车 –&gt; 浏览器向服务器端发起一次<strong>上行请求</strong> –&gt; 服务器收到上行请求做出<strong>下行响应</strong> –&gt; 浏览器拿到下行响应渲染页面</p></li><li><p>HTTP与HTTP有何异同</p><p> 相同点： 都是超文本传输协议，但是HTTPS相对更安全一点</p></li></ol><ol start="3"><li><p>一个网址的URL是由什么组成的</p><ul><li><p><code>http</code>: 超文本传输协议</p></li><li><p><code>www</code>: 别名</p></li><li><p><code>taobao</code>: 域名</p></li><li><p><code>.com</code>: 域名尾缀</p></li></ul><p>常用的域名尾缀</p><p> | 域名尾缀 | 描述 |<br> | – | — |<br> | .cn | 中国国家顶级域名 |<br> | .gov | 政府机构域名尾缀 |<br> | .com | 盈利商业组织（公司） |<br> | .me | 前南斯拉夫地区西南部的国家黑山共和国的国家域名 (饿了么网站使用的域名尾缀就是.me)</p><ul><li><p><code>:8080</code> :端口号,范围（0~65535）</p><p>  服务器默认端口8080</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;服务器&quot;&gt;&lt;a href=&quot;#服务器&quot; class=&quot;headerlink&quot; title=&quot;服务器&quot;&gt;&lt;/a&gt;服务
      
    
    </summary>
    
      <category term="network,basic" scheme="http://garden.aezo.cn/categories/network-basic/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="basic" scheme="http://garden.aezo.cn/tags/basic/"/>
    
      <category term="network" scheme="http://garden.aezo.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://garden.aezo.cn/2020/04/29/java/beforeArchitect/springboot/"/>
    <id>http://garden.aezo.cn/2020/04/29/java/beforeArchitect/springboot/</id>
    <published>2020-04-29T09:18:00.000Z</published>
    <updated>2023-02-24T08:23:43.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h1><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>SpringBoot主要解决的是在微服务架构下简化配置（有快速配置）、前后端分离、快速开发</p><p>优点： </p><ul><li>提供了快速启动入门</li><li>开箱即用、提供默认配置</li><li>内嵌容器化web项目</li><li>没有冗余代码生成和XML配置要求</li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>模板引擎： 如 <code>Thymeleaf</code>, <code>FreeMarker</code></p><p>有嵌套和解析的过程，先加载静态页面，在静态页面上添加一些标记，模板引擎的内核会根据添加的标记动态渲染数据</p><p><strong>计算向数据移动</strong></p><h3 id="MVC架构思想"><a href="#MVC架构思想" class="headerlink" title="MVC架构思想"></a>MVC架构思想</h3><p>? JVM垃圾回收机制现在已经不是引入计数器的方式，改为GCroot</p><p>? Spring不支持循环引用，主要是因为其自身结构问题。</p><h3 id="基于SpringBoot的MVC"><a href="#基于SpringBoot的MVC" class="headerlink" title="基于SpringBoot的MVC"></a>基于SpringBoot的MVC</h3><ul><li>数据的展示查询</li></ul><h3 id="分层解释"><a href="#分层解释" class="headerlink" title="分层解释"></a>分层解释</h3><ul><li><p><code>Controller</code>层</p><p>一般写业务逻辑跳转</p></li><li><p><code>Service</code>层</p><p>业务层逻辑代码</p></li><li><p><code>DAO</code>层</p><p>操作持久层</p></li></ul><h3 id="各种依赖"><a href="#各种依赖" class="headerlink" title="各种依赖"></a>各种依赖</h3><h4 id="JPA-Java-Persistence-API"><a href="#JPA-Java-Persistence-API" class="headerlink" title="JPA(Java Persistence API)"></a>JPA(Java Persistence API)</h4><p>  添加依赖 <code>Spring-data-jpa</code>, 用于访问数据源的框架，可以把数据库的表映射成对象，一一对应</p><h3 id="注释解说"><a href="#注释解说" class="headerlink" title="注释解说"></a>注释解说</h3><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a><code>@RequestMapping</code></h4><p>请求路径</p><h4 id="PathVariable-quot-key-quot"><a href="#PathVariable-quot-key-quot" class="headerlink" title="@PathVariable(&quot;key&quot;)"></a><code>@PathVariable(&quot;key&quot;)</code></h4><p>取URI中<code>key</code>对应的值</p><h1 id="实践中报错记录"><a href="#实践中报错记录" class="headerlink" title="实践中报错记录"></a>实践中报错记录</h1><h2 id="下载依赖包速度过慢"><a href="#下载依赖包速度过慢" class="headerlink" title="下载依赖包速度过慢"></a>下载依赖包速度过慢</h2><p>解决方法： 配置阿里云镜像地址</p><p>全局配置步骤： </p><ol><li>找到maven的<code>setting.xml</code>文件，若没有可以新建</li><li><p>在<code>setting.xml</code>文件的<code>mirrors</code>节点下面添加子节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="运行成功并退出"><a href="#运行成功并退出" class="headerlink" title="运行成功并退出"></a>运行成功并退出</h2><p><code>Process finished with exit code 0</code></p><p>原因： <code>Pom.xml</code>文件缺少依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引入spring-security每次调用需要输入登录名密码"><a href="#引入spring-security每次调用需要输入登录名密码" class="headerlink" title="引入spring-security每次调用需要输入登录名密码"></a>引入<code>spring-security</code>每次调用需要输入登录名密码</h2><p>解决办法： 关闭验证</p><ol><li><p><code>springboot 2.0</code> 之前可通过yml配置关闭验证：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">security.basic.enabled=false</span></span><br><span class="line"><span class="string">management.security.enabled=false</span></span><br></pre></td></tr></table></figure></li><li><p><code>springboot 2.x</code>后关闭验证</p><p> <code>springboot 2.x</code> 后上述配置被废除，需要在启动类前的 <code>@SpringBootApplication</code> 注解中加入 <code>exclude</code> 属性 <code>scurityAutoConfiguration</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = SecurityAutoConfiguration.class)</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库连接报错"><a href="#数据库连接报错" class="headerlink" title="数据库连接报错"></a>数据库连接报错</h2><p>报错内容: <code>java.sql.SQLException: The server time zone value &#39;�й���׼ʱ��&#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the &#39;serverTimezone&#39; configuration property) to use a more specifc time zone value if you want to utilize time zone support.</code></p><p>报错原因： 数据库连接时区配置问题</p><p>解决方法： 数据库配置添加时区配置 <code>serverTimezone=UTC</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">$&#123;MYSQL_USER:root&#125;</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">$&#123;MYSQL_PASSWORD:123456&#125;</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:$&#123;MYSQL_PORT:3306&#125;/$&#123;MYSQL_DATABASE:dbname&#125;?serverTimezone=UTC&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8</span></span><br></pre></td></tr></table></figure><hr><p>参考资料：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot基础&quot;&gt;&lt;a href=&quot;#SpringBoot基础&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot基础&quot;&gt;&lt;/a&gt;SpringBoot基础&lt;/h1&gt;&lt;h2 id=&quot;框架介绍&quot;&gt;&lt;a href=&quot;#框架介绍&quot; cla
      
    
    </summary>
    
      <category term="framework,Springboot" scheme="http://garden.aezo.cn/categories/framework-Springboot/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="framework" scheme="http://garden.aezo.cn/tags/framework/"/>
    
      <category term="Springboot" scheme="http://garden.aezo.cn/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>前端基础之canvas</title>
    <link href="http://garden.aezo.cn/2020/03/21/frontend/canvas/"/>
    <id>http://garden.aezo.cn/2020/03/21/frontend/canvas/</id>
    <published>2020-03-21T02:59:00.000Z</published>
    <updated>2023-02-24T08:23:43.359Z</updated>
    
    <content type="html"><![CDATA[<p>canvas最早由Apple引入WebKit，用于Mac OS X的dashboard，后来又在safari和Google Chrome被实现。基于Geoko 1.8的浏览器（如firefox1.5）支持此元素。</p><p><code>&lt;canvas&gt;</code>元素是WhatWG Web applications 1.0规范的一部分，也包含于HTML5中。<code>&lt;canvas&gt;</code>不再是语义化标签，存在兼容性问题，因此使用语义化标签兼容插件无法解决兼容问题。</p><h1 id="canvas体验"><a href="#canvas体验" class="headerlink" title="canvas体验"></a>canvas体验</h1><p>绘图步骤：</p><ol><li><p>准备画布</p><p> 使用<code>&lt;canvas&gt;</code>标签定义一个画布，默认画布为透明色(<code>rgba(0, 0, 0, 0)</code>)，大小为300*150</p><p> 可在<code>&lt;canvas&gt;</code>的样式中设置边框，但不设置大小，画布大小在<code>&lt;canvas&gt;</code>属性中设置</p><h2 id="canvas尺寸设置"><a href="#canvas尺寸设置" class="headerlink" title="canvas尺寸设置"></a>canvas尺寸设置</h2><ul><li><p>在样式中设置<code>canvas</code>尺寸：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果：</p><p>  <img src="/source/data/img/html/canvas/canvas尺寸样式.png" alt="canvas使用样式设置尺寸"></p></li><li><p>使用<code>canvas</code>属性设置画布尺寸</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  运行结果：</p><p>  <img src="/source/data/img/html/canvas/canvas尺寸属性.png" alt="canvas使用属性设置尺寸"></p><p>可以看出虽然两种方法设置的画布最终大小是一致的，但画布中的内容却不一样。</p><p><strong>使用样式设置画布大小，相当于对画布进行了放大操作，画布中的内容也会被拉伸；使用canvas自带属性设置画布大小设置的是画布的实际大小，内容不会有影响</strong></p></li></ul></li><li><p>准备绘图工具</p><p> <code>&lt;canvas&gt;</code>标签中不能写内容，因此绘图工具只能在js中设置</p></li><li><p>利用工具绘图</p><p> 绘图步骤也需写在JS中</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取canvas元素</span></span><br><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取上下文(此处上下文为canvas的回执工具箱)</span></span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 移动画笔</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绘制直线(轨迹/绘制路径)</span></span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 描边</span></span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure></li></ol><p><strong>canvas不支持3d效果，一般使用web gl绘制3d效果的网页</strong></p><h1 id="绘制平行线"><a href="#绘制平行线" class="headerlink" title="绘制平行线"></a>绘制平行线</h1><h2 id="绘制两条平行线"><a href="#绘制两条平行线" class="headerlink" title="绘制两条平行线"></a>绘制两条平行线</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第一条线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第二条线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描边</span></span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><h2 id="关于描边"><a href="#关于描边" class="headerlink" title="关于描边"></a>关于描边</h2><p>描边默认的宽度是1px,默认颜色为黑色，但实际在浏览器显示为2px,浅黑色</p><p>描边线的中心位置与刻度线对齐，因此描边线会占据浏览器上下各0.5px，但浏览器无法解析0.5px，只能解析1px，因此最终显示结果是宽度为2px,颜色饱和度降低</p><p>解决方案： 前后(Y轴)移动0.5px</p><h3 id="绘制三条不同颜色的平行线"><a href="#绘制三条不同颜色的平行线" class="headerlink" title="绘制三条不同颜色的平行线"></a>绘制三条不同颜色的平行线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCanvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = myCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制第一条蓝线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"><span class="comment">// 绘制第二条红线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新路径</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line"><span class="comment">// 绘制第三条绿线</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">'green'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">30</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>绘制不同属性的线条时，需要用<code>ctx.beginPath();</code>来开启新路径解决样式覆盖问题</p><h1 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>使用此方法绘制出的三角形会出现起始点和lineto的连接点无法闭合产生缺角的问题:</p><p><img src="/source/data/img/html/canvas/canvas手动闭合三角形.png" alt="canvas绘制手动闭合三角形"></p><p>解决方案：使用<code>ctx.closePath()</code>让canvas自动闭合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">// ctx.lineTo(200,100);</span></span><br><span class="line">ctx.closePath();<span class="comment">// 关闭路径</span></span><br><span class="line">ctx.lineWidth = <span class="number">10</span>;    </span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p><img src="/source/data/img/html/canvas/canvas自动闭合三角形.png" alt="canvas绘制自动闭合三角形"></p><h2 id="绘制填充的三角形"><a href="#绘制填充的三角形" class="headerlink" title="绘制填充的三角形"></a>绘制填充的三角形</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">'#FF4040'</span>;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>绘制结果：</p><p><img src="/source/data/img/html/canvas/canvas填充三角形.png" alt="canvas绘制填充三角形"></p><p><strong>填充时不再使用<code>ctx.stroke()</code>而是使用<code>ctx.fill()</code>,同样的，填充样式属性用的是<code>fillStyle</code>而不是<code>strokeStyle</code></strong></p><h1 id="绘制镂空正方形"><a href="#绘制镂空正方形" class="headerlink" title="绘制镂空正方形"></a>绘制镂空正方形</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺时针绘制100*100小正方形</span></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.lineTo(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆时针绘制200*200大正方形</span></span><br><span class="line">ctx.moveTo(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line">ctx.lineTo(<span class="number">250</span>,<span class="number">250</span>);</span><br><span class="line">ctx.lineTo(<span class="number">50</span>,<span class="number">250</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line">ctx.fill();<span class="comment">// 非零环绕填充规则进行填充</span></span><br></pre></td></tr></table></figure><p>绘制结果：</p><p><img src="/source/data/img/html/canvas/canvas绘制镂空正方形.png" alt="canvas绘制镂空正方形"></p><p><strong>非零环绕规则</strong>：从区域内往外画一条足够长的线，线与顺时针路径相交，计数器+1，与逆时针路径相交，计数器-1，计数器最终不为0则填充</p><p><img src="/source/data/img/html/canvas/非零环绕规则图解.png" alt="非零环绕规则图解"></p><h2 id="与线条相关的属性-画笔状态"><a href="#与线条相关的属性-画笔状态" class="headerlink" title="与线条相关的属性(画笔状态)"></a>与线条相关的属性(画笔状态)</h2><ul><li><p><code>lineWidth</code>: 线宽，默认1px</p></li><li><p><code>lineCap</code>: 线末端属性： butt、round、square</p></li><li><p><code>lineJoin</code>: 相交线的拐点： miter(默认)、round、bevel</p></li><li><p><code>strokeStyle</code>: 线的颜色</p></li><li><p><code>fillStyle</code>: 填充颜色</p></li><li><p><code>setLineDash()</code>: 设置虚线</p><p>  <code>setLineDash()</code>方法中需要传一个数组，用来描述虚线的排列方式,如<code>ctx.setLineDash([5,10,15,20])</code></p></li></ul><ul><li><p><code>getLineDash()</code>: 获取虚线宽度集合</p></li><li><p><code>lineDashOffset</code>: 设置虚线偏移量(负值向右偏移)</p></li></ul><h1 id="绘制渐变色矩形"><a href="#绘制渐变色矩形" class="headerlink" title="绘制渐变色矩形"></a>绘制渐变色矩形</h1><p>绘制思路： 绘制点组成线，为每个点上色</p><h1 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h1><p>绘制流程： 绘制网格 –&gt; 绘制坐标系 –&gt; 绘制点 –&gt; 连点成线</p><p>具体实现： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造函数</span></span><br><span class="line"><span class="keyword">var</span> LineChart = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取绘制工具</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx || <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置画布大小</span></span><br><span class="line">    <span class="keyword">this</span>.canvasWidth = <span class="keyword">this</span>.ctx.canvas.width;</span><br><span class="line">    <span class="keyword">this</span>.canvasHeight = <span class="keyword">this</span>.ctx.canvas.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置网格大小</span></span><br><span class="line">    <span class="keyword">this</span>.gridSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置坐标系的间距</span></span><br><span class="line">    <span class="keyword">this</span>.space = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置坐标原点位置</span></span><br><span class="line">    <span class="keyword">this</span>.x0 = <span class="keyword">this</span>.space;</span><br><span class="line">    <span class="keyword">this</span>.y0 = <span class="keyword">this</span>.canvasHeight - <span class="keyword">this</span>.space;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置箭头大小</span></span><br><span class="line">    <span class="keyword">this</span>.arrowSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置点的大小</span></span><br><span class="line">    <span class="keyword">this</span>.dotSize = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 行为和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">LineChart.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.drawGrid();</span><br><span class="line">    <span class="keyword">this</span>.drawCoordinate();</span><br><span class="line">    <span class="keyword">this</span>.drawDots(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制网格</span></span><br><span class="line">LineChart.prototype.drawGrid = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// X轴方向线条数 = 画布高度 / 网格大小  向下取整</span></span><br><span class="line">    <span class="keyword">var</span> xLine = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.canvasHeight / <span class="keyword">this</span>.gridSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制x轴方向线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= xLine; i++) &#123;</span><br><span class="line">       <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">       <span class="keyword">this</span>.ctx.moveTo(<span class="number">0</span>, i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth, i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'#eee'</span>;</span><br><span class="line">       <span class="keyword">this</span>.ctx.stroke();            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y轴方向线条数 = 画布宽度 / 网格大小 向下取整</span></span><br><span class="line">    <span class="keyword">var</span> yLine = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.canvasWidth / <span class="keyword">this</span>.gridSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制Y轴方向线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= yLine; i++) &#123;</span><br><span class="line">       <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">       <span class="keyword">this</span>.ctx.moveTo(i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">this</span>.ctx.lineTo(i * <span class="keyword">this</span>.gridSize - <span class="number">0.5</span>, <span class="keyword">this</span>.canvasHeight);</span><br><span class="line">       <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'#eee'</span>;</span><br><span class="line">       <span class="keyword">this</span>.ctx.stroke();            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制坐标系</span></span><br><span class="line">LineChart.prototype.drawCoordinate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制X轴</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">    <span class="keyword">this</span>.ctx.moveTo(<span class="keyword">this</span>.x0, <span class="keyword">this</span>.y0);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space, <span class="keyword">this</span>.y0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X轴箭头</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space - <span class="keyword">this</span>.arrowSize, <span class="keyword">this</span>.y0 - <span class="keyword">this</span>.arrowSize / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space - <span class="keyword">this</span>.arrowSize, <span class="keyword">this</span>.y0 + <span class="keyword">this</span>.arrowSize / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.canvasWidth - <span class="keyword">this</span>.space, <span class="keyword">this</span>.y0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill();</span><br><span class="line">    <span class="keyword">this</span>.ctx.strokeStyle = <span class="string">'black'</span>;</span><br><span class="line">    <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制Y轴</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">    <span class="keyword">this</span>.ctx.moveTo(<span class="keyword">this</span>.x0, <span class="keyword">this</span>.y0);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.space, <span class="keyword">this</span>.space);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y轴箭头</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.x0 + <span class="keyword">this</span>.arrowSize / <span class="number">2</span>, <span class="keyword">this</span>.space + <span class="keyword">this</span>.arrowSize);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.x0 - <span class="keyword">this</span>.arrowSize / <span class="number">2</span>, <span class="keyword">this</span>.space + <span class="keyword">this</span>.arrowSize);</span><br><span class="line">    <span class="keyword">this</span>.ctx.lineTo(<span class="keyword">this</span>.space, <span class="keyword">this</span>.space);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.ctx.fill();</span><br><span class="line">    <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制点</span></span><br><span class="line">LineChart.prototype.drawDots = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 传入数据的坐标不是canvas坐标，因此需要先转换成canvas坐标，再进行绘制和连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = data[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> canvasX = _this.x0 + item.x;<span class="comment">// canvas x轴坐标 = canvas原点X轴坐标 + 数据X轴坐标</span></span><br><span class="line">        <span class="keyword">var</span> canvasY = _this.y0 - item.y;<span class="comment">// canvas y轴坐标 = canvas原点y轴坐标 - 数据Y轴坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制点</span></span><br><span class="line">        _this.ctx.beginPath();</span><br><span class="line">        _this.ctx.moveTo(canvasX - _this.dotSize / <span class="number">2</span>, canvasY - _this.dotSize / <span class="number">2</span>);<span class="comment">// 起始位置为点的左上角位置</span></span><br><span class="line">        _this.ctx.lineTo(canvasX + _this.dotSize / <span class="number">2</span>, canvasY - _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.lineTo(canvasX + _this.dotSize / <span class="number">2</span>, canvasY + _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.lineTo(canvasX - _this.dotSize / <span class="number">2</span>, canvasY + _this.dotSize / <span class="number">2</span>);</span><br><span class="line">        _this.ctx.closePath();</span><br><span class="line"></span><br><span class="line">        _this.ctx.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将点连成线 (第一个点起点为(x0,y0),其他坐标起点为上一个点)</span></span><br><span class="line">        _this.ctx.beginPath();</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">            _this.ctx.moveTo( _this.x0,  _this.y0);                </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            _this.ctx.moveTo( _this.x0 + data[i<span class="number">-1</span>].x, _this.y0 - data[i<span class="number">-1</span>].y);</span><br><span class="line">        &#125;</span><br><span class="line">        _this.ctx.lineTo(canvasX, canvasY);</span><br><span class="line"></span><br><span class="line">        _this.ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化</span></span><br><span class="line"><span class="keyword">var</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">100</span>,</span><br><span class="line">        y: <span class="number">120</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">150</span>,</span><br><span class="line">        y: <span class="number">300</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">400</span>,</span><br><span class="line">        y: <span class="number">360</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">430</span>,</span><br><span class="line">        y: <span class="number">200</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        x: <span class="number">470</span>,</span><br><span class="line">        y: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lineChart = <span class="keyword">new</span> LineChart();</span><br><span class="line">lineChart.init(data);</span><br></pre></td></tr></table></figure><h1 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h1><p>矩形：</p><ul><li><p><code>rect(x轴坐标,Y轴坐标,长度,高度)</code> </p><ul><li><p>X轴坐标、Y轴坐标表示矩形左上角的点的位置</p></li><li><p>此方法绘制的是轨迹，要显示出来还必须使用<code>stroke()</code>或<code>fill()</code>进行描边或填充</p></li><li><p>绘制的路径不是独立路径</p></li></ul></li><li><p><code>strokeRect(x轴坐标,Y轴坐标,长度,高度)</code></p><ul><li><p>绘制描边矩形</p></li><li><p>此方法绘制有自己的独立路径，即默认自带<code>beginPath()</code>，不会被其他路径样式覆盖</p></li></ul></li><li><p><code>fillRect(x轴坐标,Y轴坐标,长度,高度)</code></p><ul><li><p>绘制填充矩形</p></li><li><p>此方法绘制有自己的独立路径，即默认自带<code>beginPath()</code>，不会被其他路径样式覆盖</p></li></ul></li><li><p><code>clearRect(x轴坐标,Y轴坐标,长度,高度)</code></p><ul><li>清除矩形内容</li></ul></li></ul><h2 id="绘制渐变矩形"><a href="#绘制渐变矩形" class="headerlink" title="绘制渐变矩形"></a>绘制渐变矩形</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearGradient = ctx.createLinearGradient(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">100</span>);<span class="comment">// 设置渐变方向，以两点的坐标来定</span></span><br><span class="line">linearGradient.addColorStop(<span class="number">0</span>,<span class="string">'pink'</span>);<span class="comment">// 起始颜色，若中间需要加别的颜色可以调整第一个参数为0~1之间</span></span><br><span class="line">linearGradient.addColorStop(<span class="number">1</span>,<span class="string">'blue'</span>);<span class="comment">// 结束颜色</span></span><br><span class="line"></span><br><span class="line">ctx.fillStyle = linearGradient;</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure><h1 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h1><h2 id="弧形"><a href="#弧形" class="headerlink" title="弧形"></a>弧形</h2><p>一个弧度 = 一个半径的长度</p><ul><li><p><code>arc(圆心x轴,圆心y轴,起始弧度,结束弧度,绘制方向)</code></p><ul><li><p>圆心x轴,圆心y轴为圆心坐标，类型为<code>number</code></p></li><li><p>起始弧度与结束弧度类型为<code>number</code>,π用<code>Math.PI</code>表示</p></li><li><p>绘制方向类型为<code>boolean</code>，默认为顺时针</p></li><li><p>此方法绘制的是路径，需要使用描边才能显示</p><h2 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h2></li></ul></li></ul><p>起始点放在弧线的圆心位置，绘制弧线，闭合路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">ctx.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">ctx.arc(<span class="number">100</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="built_in">Math</span>.PI * <span class="number">3</span> / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">ctx.closePath();</span><br><span class="line"></span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><p>起始点若不设置直接闭合，则绘制出的为扇形</p><h2 id="n等分随机颜色的圆"><a href="#n等分随机颜色的圆" class="headerlink" title="n等分随机颜色的圆"></a>n等分随机颜色的圆</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;<span class="comment">// 等分数</span></span><br><span class="line"><span class="keyword">var</span> angle = <span class="built_in">Math</span>.PI * <span class="number">2</span> / num;<span class="comment">// 每份弧度</span></span><br><span class="line"><span class="keyword">var</span> startAngle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> w = ctx.canvas.width;<span class="comment">// 画布宽度</span></span><br><span class="line"><span class="keyword">var</span> h = ctx.canvas.height;<span class="comment">// 画布高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机颜色</span></span><br><span class="line"><span class="keyword">var</span> getRandomColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'rgb('</span>+ r + <span class="string">','</span> + g + <span class="string">','</span> + b +<span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机等分圆形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    startAngle = i * angle;</span><br><span class="line">    <span class="keyword">var</span> endAngle = (i + <span class="number">1</span>) * angle;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(w / <span class="number">2</span>,h / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(w / <span class="number">2</span>,h / <span class="number">2</span>, h / <span class="number">2</span>,startAngle,endAngle);</span><br><span class="line">    ctx.closePath();</span><br><span class="line">    ctx.fillStyle = getRandomColor();</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据数据绘制饼图"><a href="#根据数据绘制饼图" class="headerlink" title="根据数据绘制饼图"></a>根据数据绘制饼图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">3</span>];<span class="comment">// 动态数据    </span></span><br><span class="line"><span class="keyword">var</span> w = ctx.canvas.width;<span class="comment">// 画布宽度</span></span><br><span class="line"><span class="keyword">var</span> h = ctx.canvas.height;<span class="comment">// 画布高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机颜色</span></span><br><span class="line"><span class="keyword">var</span> getRandomColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'rgb('</span>+ r + <span class="string">','</span> + g + <span class="string">','</span> + b +<span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取总数</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    total = total + data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据每份比例绘制饼图</span></span><br><span class="line"><span class="keyword">var</span> startAngle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;      </span><br><span class="line">    <span class="keyword">var</span> endAngle = startAngle +  <span class="built_in">Math</span>.PI * <span class="number">2</span> * (data[i] / total);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(w / <span class="number">2</span>,h / <span class="number">2</span>);</span><br><span class="line">    ctx.arc(w / <span class="number">2</span>,h / <span class="number">2</span>, h / <span class="number">2</span>,startAngle,endAngle);</span><br><span class="line">    ctx.closePath();</span><br><span class="line">    ctx.fillStyle = getRandomColor();</span><br><span class="line">    ctx.fill();</span><br><span class="line"></span><br><span class="line">    startAngle = endAngle;<span class="comment">// 下一区域起始弧度为本区域结束弧度，此处必须要赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><ul><li><p><code>strokeText(文本内容,x坐标,y坐标)</code></p><ul><li><p>文本绘制的起点在左下角，矩形绘制的起点在左上角</p></li><li><p><code>strokeText</code>绘制出的是描边的文字，字体为空心，若要实心则使用<code>fillText</code>绘制</p></li></ul></li><li><p><code>textAlign</code></p><ul><li>文本对齐方式，基于起始坐标的对齐方式</li></ul></li><li><p><code>font</code></p><ul><li>设置文本大小、字体</li></ul></li><li><p><code>textBaseline</code></p><ul><li><p>设置基线（垂直对齐方式），基于起始坐标的对齐方式</p></li><li><p>可取值： <code>top</code>、<code>middle</code>、 <code>bottom</code>、 <code>hanging</code>、 <code>alphabetic</code>、 <code>ideographic</code></p></li><li><p><code>hanging</code> 文本的基线处于文本的正上方并且和文本相粘合(适用于印度文)</p></li><li><p><code>alphabetic</code> 默认值，基线处于文本下方，并穿过文字(适用于英文)</p></li><li><p><code>ideographic</code> 与 <code>bottom</code> 相似(适用于中文)</p></li></ul></li><li><p><code>measureText(文本内容)</code></p><ul><li><p>获取文本的宽度对象</p></li><li><p><strong>若取文本长度则需要xxx.ctx.measureText(xx).width</strong></p></li></ul></li></ul><h1 id="绘制带文本的饼图"><a href="#绘制带文本的饼图" class="headerlink" title="绘制带文本的饼图"></a>绘制带文本的饼图</h1><p><a href="https://garden.aezo.cn/demos/canvas饼状图.html">https://garden.aezo.cn/demos/canvas饼状图.html</a></p><h1 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h1><p>绘制图片使用方法<code>drawImage()</code>,可传三个参数、五个参数、九个参数</p><h2 id="绘制思路"><a href="#绘制思路" class="headerlink" title="绘制思路"></a>绘制思路</h2><ol><li><p>加载图片至内存,创建image对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">var</span> img = doucment.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();<span class="comment">// Image()为JS提供的内置构造函数</span></span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br></pre></td></tr></table></figure></li><li><p>图片加载完成才能执行代码，因此必须写在onload函数里面</p><p> <strong>部分浏览器如果有缓存时，图片可能会在onload函数触发之前就已经加载完毕，第一次加载图片时已经触发了onload事件，含有缓存时不再触发onload事件，为保证兼容性，最好把onload事件写在图片加载之前</strong></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();<span class="comment">// Image()为JS提供的内置构造函数</span></span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处实现图片绘制</span></span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'image/dude.png'</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三种绘制方法"><a href="#三种绘制方法" class="headerlink" title="三种绘制方法"></a>三种绘制方法</h2><ul><li><p>三个参数 <code>darwImage(img, x, y)</code></p><ul><li><p><code>img</code> 图片对象、canvas对象、 video对象</p></li><li><p><code>x</code>、<code>y</code> 图片绘制的左上角</p></li></ul></li><li><p>五个参数 <code>darwImage(img, x, y, w, h)</code></p><ul><li><p><code>img</code> 图片对象、canvas对象、 video对象</p></li><li><p><code>x</code>、<code>y</code> 图片绘制的左上角</p></li><li><p><code>w</code>、<code>h</code> 图片绘制尺寸设置，会对图片进行缩放而不是裁剪</p></li></ul></li><li><p>九个参数 <code>drawImage(img, x, y, w, h, x1, y1, w1, h1)</code></p><ul><li><p><code>img</code> 图片对象、canvas对象、 video对象</p></li><li><p><code>x</code>、<code>y</code>、<code>w</code>、<code>h</code> 图片中的一个矩形区域</p></li><li><p><code>x1</code>、<code>y1</code>、<code>w1</code>、<code>h1</code> 画布中的一个矩形区域, <code>w1</code>、<code>h1</code>是图片的缩放尺寸而不是裁剪</p></li></ul></li></ul><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><h3 id="绘制关键思路"><a href="#绘制关键思路" class="headerlink" title="绘制关键思路"></a>绘制关键思路</h3><ol><li><p>动态获取当前图片的尺寸</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imageWidth = image.width;</span><br><span class="line"><span class="keyword">var</span> imageHeight = image.height;</span><br></pre></td></tr></table></figure></li><li><p>计算出每个小人物的尺寸</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://garden.aezo.cn/demos/canvas帧动画.html">https://garden.aezo.cn/demos/canvas帧动画.html</a></p><h3 id="方向键控制精灵行走的帧动画"><a href="#方向键控制精灵行走的帧动画" class="headerlink" title="方向键控制精灵行走的帧动画"></a>方向键控制精灵行走的帧动画</h3><p><a href="https://garden.aezo.cn/demos/canvas方向键控制行走动画.html">https://garden.aezo.cn/demos/canvas方向键控制行走动画.html</a></p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><hr><p>参考视频</p><p> <a href="https://www.bilibili.com/video/av53813293?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av53813293?p=2</a> (canvas视频【高级教程】)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;canvas最早由Apple引入WebKit，用于Mac OS X的dashboard，后来又在safari和Google Chrome被实现。基于Geoko 1.8的浏览器（如firefox1.5）支持此元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/c
      
    
    </summary>
    
      <category term="web,CSS" scheme="http://garden.aezo.cn/categories/web-CSS/"/>
    
    
      <category term="Computer Language" scheme="http://garden.aezo.cn/tags/Computer-Language/"/>
    
      <category term="web" scheme="http://garden.aezo.cn/tags/web/"/>
    
      <category term="CSS" scheme="http://garden.aezo.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="http://garden.aezo.cn/2020/02/26/others/UML/starUml/"/>
    <id>http://garden.aezo.cn/2020/02/26/others/UML/starUml/</id>
    <published>2020-02-26T06:26:00.000Z</published>
    <updated>2023-02-24T08:23:43.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML基础-1"><a href="#UML基础-1" class="headerlink" title="UML基础 ^1"></a>UML基础 <a href="https://www.bilibili.com/video/av34973179?from=search&amp;seid=955581513016587565" title="熟练使用UML" target="_blank" rel="noopener">^1</a></h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>OO(Object-Orientation)</code> 面向对象，一种系统建模技术 </p></li><li><p><code>OOP(Object-Orientation Programming)</code> 按照<code>OO</code>的方法来开发程序的过程</p></li><li><p><code>OOAD(Object Oriented Analysis and Design)</code> 面向对象的分析与设计，根据<code>OO</code>的方法学，对软件系统进行分析和设计的过程(分析阶段<code>OOA</code>、设计阶段<code>OOD</code>)</p><ul><li><p><code>OOA</code>阶段需要解决的核心问题是 <code>what to do</code></p><ul><li><p>建立针对业务问题域的清晰视图</p></li><li><p>列出系统必须要完成的核心任务</p></li><li><p>针对问题域建立公共词汇表</p></li><li><p>列出针对此问题域的最佳解决方案</p></li></ul></li><li><p><code>OOD</code>阶段需要解决的核心问题是 <code>How to do</code></p><ul><li><p>如何解决具体的业务问题</p></li><li><p>引入系统工作所需的支持元素</p></li><li><p>定义系统的实现策略</p></li></ul></li></ul></li><li><p><code>对象</code>: </p><ul><li><p>客观存在的、唯一的实体</p></li><li><p>是面向对象编程过程中分析与解决问题的出发点与基础</p></li><li><p>拥有自己的标识、数据与行为</p></li><li><p>可以简单或复杂</p></li><li><p>可以抽象或具体</p></li><li><p>在<code>OOP</code>中是一个类的动态实例</p></li></ul></li></ul><h3 id="OOP主要特征"><a href="#OOP主要特征" class="headerlink" title="OOP主要特征"></a>OOP主要特征</h3><ul><li><p>抽象(abstract)</p><ul><li><p>忽略一个对象或实体的细节而只关注其本质特征的过程</p></li><li><p>简化功能与格式</p></li><li><p>帮助用户与对象交互</p></li></ul></li><li><p>封装(encapsulation)</p><ul><li><p>隐藏数据和实现</p></li><li><p>提供公共方法供用户调用功能</p></li><li><p>对象的两种视图： 外部视图(对象能做的工作)、内部视图(对象如何完成工作)  </p></li></ul></li><li><p>继承(inheritance)</p><ul><li><p>通过存在的类型定义新类型的机制</p></li><li><p>通常在两个类型之间存在<code>is a</code>或<code>kind of</code>这样的关系</p></li><li><p>通过继承可实现代码重用，是多态的基础</p></li></ul></li><li><p>多态(polymorphism)</p><ul><li><p>一个名称，多种形式</p></li><li><p>基于继承的多态</p></li><li><p>调用方法时根据所给对象的不同，选择不同的处理方式</p></li></ul></li><li><p>关联(association)</p><ul><li><p>对象之间交互时的一种引用方式</p></li><li><p>当一个对象通过对另一个对象的引用去使用另一个对象的服务或操作时，两个对象之间便产生了关联</p></li></ul></li><li><p>聚合(aggregation)</p><ul><li><p>一种关系较强的关联关系，一个对象成为另一个对象的组成部分</p></li><li><p>两个对象之间存在<code>has a</code>的关系，一个对象作为另一个对象的属性存在，在外部对象被生产时可由客户端指定与其关联的内部对象</p></li><li><p>e.g. 汽车与轮胎的关系： 轮胎作为汽车的一部分可以和汽车分别生产后装配起来，但汽车也可换别新轮胎，轮胎也可与其他汽车装配使用</p></li></ul></li><li><p>组合(composition)</p><ul><li><p>关联关系中最为强烈的一种关系</p></li><li><p>当一个对象包含另一个对象时，外部对象负责管理内部对象的生命周期情况</p></li><li><p>内部对象的创建又由外部对象自己控制</p></li><li><p>外部对象不存在时内部对象也不能存在</p></li></ul></li><li><p>内聚与耦合(cohesion &amp; coupling)</p><p>内聚： 度量一个类独立完成某项工作的能力</p><p>耦合： 度量系统内或系统之间依赖关系的复杂度</p><p>设计原则： 增加内聚，减少耦合(高内聚低耦合)</p></li></ul><h3 id="域模型"><a href="#域模型" class="headerlink" title="域模型"></a>域模型</h3><p>在面向对象术语中也可称为设计模型，由具有状态和行为的域对象组成。</p><p>域对象之间的关系：</p><ul><li><p>关联(Association)</p></li><li><p>依赖(Dependency)</p></li><li><p>聚集(Aggregation)</p><p>整体和部分之间的关系</p></li><li><p>一般化(泛化)(Generalization)</p><p>类之间的继承关系</p></li></ul><h3 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h3><p>传统开发过程： 瀑布模型</p><p><img src="/source/data/img/uml/瀑布模型.png" alt="传统开发过程"></p><p>OOAD开发过程：</p><ul><li><p>大项目分解成子项目</p></li><li><p>使用UML工具</p></li><li><p>统一软件开发过程是迭代、递增的开发过程</p></li></ul><h3 id="迭代、递增的项目生命周期"><a href="#迭代、递增的项目生命周期" class="headerlink" title="迭代、递增的项目生命周期"></a>迭代、递增的项目生命周期</h3><p>在每一个迭代的阶段应该做以下工作：</p><ul><li><p>选择并分析相关用例</p></li><li><p>根据所选架构进行设计</p></li><li><p>在组件层次实现设计</p></li><li><p>验证组件满足用例的需要</p></li></ul><p>当一次迭代满足目标后，开发进入下一个迭代周期。</p><p>主要阶段：</p><p>Inception - start up</p><p>Elaboration - refine</p><p>Constructon - implement</p><p>Transition - promotion</p><p>每个周期包含一次或多次迭代</p><p>一个阶段的结束称之为“里程碑(milestone)”</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>此阶段的增量集中于：</p><ul><li><p>项目启动</p></li><li><p>建立业务模型</p></li><li><p>定义业务问题域</p></li><li><p>找出主要的风险因素</p></li><li><p>定义项目需求的外延</p></li><li><p>创建业务问题域的相关说明文档</p></li></ul><h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>此阶段增量集中于： </p><ul><li><p>高层的分析与设计</p></li><li><p>建立项目的基础框架</p></li><li><p>监督主要的风险因素</p></li><li><p>制定达成项目目标的创建计划</p></li></ul><h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>代码及功能的实现</p><h4 id="移交阶段"><a href="#移交阶段" class="headerlink" title="移交阶段"></a>移交阶段</h4><p>此阶段增量集中于：</p><ul><li><p>向用户发布产品</p></li><li><p>beta测试</p></li><li><p>执行性能调优，用户培训和接收测试</p></li></ul><h4 id="每个阶段包含的工作流"><a href="#每个阶段包含的工作流" class="headerlink" title="每个阶段包含的工作流"></a>每个阶段包含的工作流</h4><p>每一次递增都由5部分组成： 需求与初始分析、分析、设计、实现、测试。</p><p>每一次迭代执行工作流的深度不同，早期的迭代在深度上覆盖初始工作流，后期迭代在深度上覆盖后期工作流。</p><h4 id="迭代、递增生命周期的优势"><a href="#迭代、递增生命周期的优势" class="headerlink" title="迭代、递增生命周期的优势"></a>迭代、递增生命周期的优势</h4><ul><li><p>降低成本</p></li><li><p>便于更好地维护项目进度</p></li><li><p>便于团队的协作开发</p></li><li><p>便于适应用户需求的动态变化</p></li></ul><h2 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h2><p><code>Unified Modeling Language</code>: 统一建模语言。图形化语言表示。</p><h3 id="UML图的分类"><a href="#UML图的分类" class="headerlink" title="UML图的分类"></a>UML图的分类</h3><h4 id="静态模型-static-model"><a href="#静态模型-static-model" class="headerlink" title="静态模型(static model)"></a>静态模型(static model)</h4><ul><li><p>创建并记录一个系统的静态特征</p></li><li><p>反映一个软件系统基础、固定的框架结构</p></li><li><p>创建相关问题域主要元素的视图</p></li></ul><p>静态建模包括： 用例图(user case diagrams)、类图(class diagrams)、对象图(object diagrams)、组件图(component diagrams)、部署图(deployment diagrams)</p><h4 id="动态模型-dynamic-model"><a href="#动态模型-dynamic-model" class="headerlink" title="动态模型(dynamic model)"></a>动态模型(dynamic model)</h4><p>动态建模用以展示系统的行为</p><p>动态建模包括： 时序图(sequence diagrams)、协作图(collaboration diagrams)、状态图(state chart diagrams)、活动图(activity diagrams)</p><h2 id="九大核心UML图"><a href="#九大核心UML图" class="headerlink" title="九大核心UML图"></a>九大核心UML图</h2><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>展示系统的核心功能与其交互的用户，用户被称之为<code>&quot;活动者(Actor)&quot;</code></p><p>用例使用椭圆表示，为简化建模过程，用例图可标注优先级</p><h3 id="使用starUML绘制用例图"><a href="#使用starUML绘制用例图" class="headerlink" title="使用starUML绘制用例图"></a>使用starUML绘制用例图</h3><ol><li>在 <code>Model Explorer</code>工具栏中选中<code>Model</code>–&gt;右键选择<code>Add Diagram</code> –&gt; 选择 <code>Use Case Diagram</code></li></ol><p><img src="/source/data/img/uml/用例图绘制1.png" alt="用例图绘制步骤1"></p><ol start="2"><li>在<code>Tool Box</code>工具栏中选择模板进行绘制</li></ol><p><img src="/source/data/img/uml/用例图绘制2.png" alt="用例图绘制步骤2"></p><p>上图表示 <code>活动者admin</code>可执行<code>add</code> <code>update</code> <code>delete</code> <code>query</code>操作，<code>活动者guest</code>只能执行<code>query</code>操作</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>表现类的特征，描述多个类、接口特征以及对象之间的协作与交互。</p><p>类图由一个或多个矩形区域构成，包括类型(类名)、属性(可选)、操作(可选)</p><h3 id="使用starUML绘制类图"><a href="#使用starUML绘制类图" class="headerlink" title="使用starUML绘制类图"></a>使用starUML绘制类图</h3><p><img src="/source/data/img/uml/类图示例.png" alt="类图示例"></p><hr><p>参考文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UML基础-1&quot;&gt;&lt;a href=&quot;#UML基础-1&quot; class=&quot;headerlink&quot; title=&quot;UML基础 ^1&quot;&gt;&lt;/a&gt;UML基础 &lt;a href=&quot;https://www.bilibili.com/video/av34973179?from=se
      
    
    </summary>
    
      <category term="others" scheme="http://garden.aezo.cn/categories/others/"/>
    
    
      <category term="others" scheme="http://garden.aezo.cn/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Visio</title>
    <link href="http://garden.aezo.cn/2020/02/26/others/visio/"/>
    <id>http://garden.aezo.cn/2020/02/26/others/visio/</id>
    <published>2020-02-26T06:26:00.000Z</published>
    <updated>2023-02-24T08:23:43.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML基础-1"><a href="#UML基础-1" class="headerlink" title="UML基础 ^1"></a>UML基础 <a href="https://www.bilibili.com/video/av34973179?from=search&amp;seid=955581513016587565" title="熟练使用UML" target="_blank" rel="noopener">^1</a></h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>OO(Object-Orientation)</code> 面向对象，一种系统建模技术 </p></li><li><p><code>OOP(Object-Orientation Programming)</code> 按照<code>OO</code>的方法来开发程序的过程</p></li><li><p><code>OOAD(Object Oriented Analysis and Design)</code> 面向对象的分析与设计，根据<code>OO</code>的方法学，对软件系统进行分析和设计的过程(分析阶段<code>OOA</code>、设计阶段<code>OOD</code>)</p><ul><li><p><code>OOA</code>阶段需要解决的核心问题是 <code>what to do</code></p><ul><li><p>建立针对业务问题域的清晰视图</p></li><li><p>列出系统必须要完成的核心任务</p></li><li><p>针对问题域建立公共词汇表</p></li><li><p>列出针对此问题域的最佳解决方案</p></li></ul></li><li><p><code>OOD</code>阶段需要解决的核心问题是 <code>How to do</code></p><ul><li><p>如何解决具体的业务问题</p></li><li><p>引入系统工作所需的支持元素</p></li><li><p>定义系统的实现策略</p></li></ul></li></ul></li><li><p><code>对象</code>: </p><ul><li><p>客观存在的、唯一的实体</p></li><li><p>是面向对象编程过程中分析与解决问题的出发点与基础</p></li><li><p>拥有自己的标识、数据与行为</p></li><li><p>可以简单或复杂</p></li><li><p>可以抽象或具体</p></li><li><p>在<code>OOP</code>中是一个类的动态实例</p></li></ul></li></ul><h3 id="OOP主要特征"><a href="#OOP主要特征" class="headerlink" title="OOP主要特征"></a>OOP主要特征</h3><ul><li><p>抽象(abstract)</p><ul><li><p>忽略一个对象或实体的细节而只关注其本质特征的过程</p></li><li><p>简化功能与格式</p></li><li><p>帮助用户与对象交互</p></li></ul></li><li><p>封装(encapsulation)</p><ul><li><p>隐藏数据和实现</p></li><li><p>提供公共方法供用户调用功能</p></li><li><p>对象的两种视图： 外部视图(对象能做的工作)、内部视图(对象如何完成工作)  </p></li></ul></li><li><p>继承(inheritance)</p><ul><li><p>通过存在的类型定义新类型的机制</p></li><li><p>通常在两个类型之间存在<code>is a</code>或<code>kind of</code>这样的关系</p></li><li><p>通过继承可实现代码重用，是多态的基础</p></li></ul></li><li><p>多态(polymorphism)</p><ul><li><p>一个名称，多种形式</p></li><li><p>基于继承的多态</p></li><li><p>调用方法时根据所给对象的不同，选择不同的处理方式</p></li></ul></li><li><p>关联(association)</p><ul><li><p>对象之间交互时的一种引用方式</p></li><li><p>当一个对象通过对另一个对象的引用去使用另一个对象的服务或操作时，两个对象之间便产生了关联</p></li></ul></li><li><p>聚合(aggregation)</p><ul><li><p>一种关系较强的关联关系，一个对象成为另一个对象的组成部分</p></li><li><p>两个对象之间存在<code>has a</code>的关系，一个对象作为另一个对象的属性存在，在外部对象被生产时可由客户端指定与其关联的内部对象</p></li><li><p>e.g. 汽车与轮胎的关系： 轮胎作为汽车的一部分可以和汽车分别生产后装配起来，但汽车也可换别新轮胎，轮胎也可与其他汽车装配使用</p></li></ul></li><li><p>组合(composition)</p><ul><li><p>关联关系中最为强烈的一种关系</p></li><li><p>当一个对象包含另一个对象时，外部对象负责管理内部对象的生命周期情况</p></li><li><p>内部对象的创建又由外部对象自己控制</p></li><li><p>外部对象不存在时内部对象也不能存在</p></li></ul></li><li><p>内聚与耦合(cohesion &amp; coupling)</p><p>内聚： 度量一个类独立完成某项工作的能力</p><p>耦合： 度量系统内或系统之间依赖关系的复杂度</p><p>设计原则： 增加内聚，减少耦合(高内聚低耦合)</p></li></ul><h3 id="域模型"><a href="#域模型" class="headerlink" title="域模型"></a>域模型</h3><p>在面向对象术语中也可称为设计模型，由具有状态和行为的域对象组成。</p><p>域对象之间的关系：</p><ul><li><p>关联(Association)</p></li><li><p>依赖(Dependency)</p></li><li><p>聚集(Aggregation)</p><p>整体和部分之间的关系</p></li><li><p>一般化(泛化)(Generalization)</p><p>类之间的继承关系</p></li></ul><h3 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h3><p>传统开发过程： 瀑布模型</p><p><img src="/source/data/img/uml/瀑布模型.png" alt="传统开发过程"></p><p>OOAD开发过程：</p><ul><li><p>大项目分解成子项目</p></li><li><p>使用UML工具</p></li><li><p>统一软件开发过程是迭代、递增的开发过程</p></li></ul><h3 id="迭代、递增的项目生命周期"><a href="#迭代、递增的项目生命周期" class="headerlink" title="迭代、递增的项目生命周期"></a>迭代、递增的项目生命周期</h3><p>在每一个迭代的阶段应该做以下工作：</p><ul><li><p>选择并分析相关用例</p></li><li><p>根据所选架构进行设计</p></li><li><p>在组件层次实现设计</p></li><li><p>验证组件满足用例的需要</p></li></ul><p>当一次迭代满足目标后，开发进入下一个迭代周期。</p><p>主要阶段：</p><p>Inception - start up</p><p>Elaboration - refine</p><p>Constructon - implement</p><p>Transition - promotion</p><p>每个周期包含一次或多次迭代</p><p>一个阶段的结束称之为“里程碑(milestone)”</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>此阶段的增量集中于：</p><ul><li><p>项目启动</p></li><li><p>建立业务模型</p></li><li><p>定义业务问题域</p></li><li><p>找出主要的风险因素</p></li><li><p>定义项目需求的外延</p></li><li><p>创建业务问题域的相关说明文档</p></li></ul><h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>此阶段增量集中于： </p><ul><li><p>高层的分析与设计</p></li><li><p>建立项目的基础框架</p></li><li><p>监督主要的风险因素</p></li><li><p>制定达成项目目标的创建计划</p></li></ul><h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>代码及功能的实现</p><h4 id="移交阶段"><a href="#移交阶段" class="headerlink" title="移交阶段"></a>移交阶段</h4><p>此阶段增量集中于：</p><ul><li><p>向用户发布产品</p></li><li><p>beta测试</p></li><li><p>执行性能调优，用户培训和接收测试</p></li></ul><h4 id="每个阶段包含的工作流"><a href="#每个阶段包含的工作流" class="headerlink" title="每个阶段包含的工作流"></a>每个阶段包含的工作流</h4><p>每一次递增都由5部分组成： 需求与初始分析、分析、设计、实现、测试。</p><p>每一次迭代执行工作流的深度不同，早期的迭代在深度上覆盖初始工作流，后期迭代在深度上覆盖后期工作流。</p><h4 id="迭代、递增生命周期的优势"><a href="#迭代、递增生命周期的优势" class="headerlink" title="迭代、递增生命周期的优势"></a>迭代、递增生命周期的优势</h4><ul><li><p>降低成本</p></li><li><p>便于更好地维护项目进度</p></li><li><p>便于团队的协作开发</p></li><li><p>便于适应用户需求的动态变化</p></li></ul><h2 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h2><p><code>Unified Modeling Language</code>: 统一建模语言。图形化语言表示。</p><h3 id="UML图的分类"><a href="#UML图的分类" class="headerlink" title="UML图的分类"></a>UML图的分类</h3><h4 id="静态模型-static-model"><a href="#静态模型-static-model" class="headerlink" title="静态模型(static model)"></a>静态模型(static model)</h4><ul><li><p>创建并记录一个系统的静态特征</p></li><li><p>反映一个软件系统基础、固定的框架结构</p></li><li><p>创建相关问题域主要元素的视图</p></li></ul><p>静态建模包括： 用例图(user case diagrams)、类图(class diagrams)、对象图(object diagrams)、组件图(component diagrams)、部署图(deployment diagrams)</p><h4 id="动态模型-dynamic-model"><a href="#动态模型-dynamic-model" class="headerlink" title="动态模型(dynamic model)"></a>动态模型(dynamic model)</h4><p>动态建模用以展示系统的行为</p><p>动态建模包括： 时序图(sequence diagrams)、协作图(collaboration diagrams)、状态图(state chart diagrams)、活动图(activity diagrams)</p><h2 id="九大核心UML图"><a href="#九大核心UML图" class="headerlink" title="九大核心UML图"></a>九大核心UML图</h2><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>展示系统的核心功能与其交互的用户，用户被称之为<code>&quot;活动者(Actor)&quot;</code></p><p>用例使用椭圆表示，为简化建模过程，用例图可标注优先级</p><h3 id="使用starUML绘制用例图"><a href="#使用starUML绘制用例图" class="headerlink" title="使用starUML绘制用例图"></a>使用starUML绘制用例图</h3><ol><li>在 <code>Model Explorer</code>工具栏中选中<code>Model</code>–&gt;右键选择<code>Add Diagram</code> –&gt; 选择 <code>Use Case Diagram</code></li></ol><p><img src="/source/data/img/uml/用例图绘制1.png" alt="用例图绘制步骤1"></p><ol start="2"><li>在<code>Tool Box</code>工具栏中选择模板进行绘制</li></ol><p><img src="/source/data/img/uml/用例图绘制2.png" alt="用例图绘制步骤2"></p><p>上图表示 <code>活动者admin</code>可执行<code>add</code> <code>update</code> <code>delete</code> <code>query</code>操作，<code>活动者guest</code>只能执行<code>query</code>操作</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>表现类的特征，描述多个类、接口特征以及对象之间的协作与交互。</p><p>类图由一个或多个矩形区域构成，包括类型(类名)、属性(可选)、操作(可选)</p><h3 id="使用starUML绘制类图"><a href="#使用starUML绘制类图" class="headerlink" title="使用starUML绘制类图"></a>使用starUML绘制类图</h3><p><img src="/source/data/img/uml/类图示例.png" alt="类图示例"></p><hr><p>参考文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UML基础-1&quot;&gt;&lt;a href=&quot;#UML基础-1&quot; class=&quot;headerlink&quot; title=&quot;UML基础 ^1&quot;&gt;&lt;/a&gt;UML基础 &lt;a href=&quot;https://www.bilibili.com/video/av34973179?from=se
      
    
    </summary>
    
      <category term="others" scheme="http://garden.aezo.cn/categories/others/"/>
    
    
      <category term="others" scheme="http://garden.aezo.cn/tags/others/"/>
    
  </entry>
  
</feed>
