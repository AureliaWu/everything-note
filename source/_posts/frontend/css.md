---
layout: "post"
title: "前端基础之CSS"
date: "2019-10-13 21:29"
categories: web,CSS
tags: [Computer Language, web,CSS]
---

# CSS一些基本概念

## 术语解释

```css
h1{
    color:red;
    background-color: lightblue;
    text-align: center;
}
```

CSS规则 = 选择器 + 声明块

### 选择器

选择器： 选中元素

1. ID选择器： 选中的是对应id值的元素
2. 元素选择器
3. 类选择器

### 声明块

出现在`{}`中，声明块包含很多声明（属性），每一个声明（属性）表达了某一方面的样式

## CSS代码书写位置

1. 内部样式表

书写在`<style>`元素中，一般放在`<head>`里面

2. 内联样式表（元素样式表）

直接书写在元素的style属性中

3. 外部样式表[推荐]

将样式书写到独立的css文件中

1) 外部样式表可以解决多页面样式重复的问题
2) 有利于浏览器缓存，从而提高页面响应速度
3) 有利于代码分离(HTML和CSS)，更容易阅读和维护

# 常见样式声明

1. `color`

元素内部的文字颜色

**预设值**： 定义好的单词

**三原色(色值)**： 光学三原色（红、绿、蓝），每个颜色可以使用0-255之间的数字来表达色值。

```
rgb表示法：
rgb(0,255,0)
hex(16进制)表示法：
#红绿蓝
```

常用的颜色色号：

淘宝红： #ff4400,#f40
黑色： #000000，#000
白色： #ffffff, #fff
红： #f00
绿： #0f0
蓝： #00f
紫： #f0f
青： #0ff
黄： #ff0
灰色： #ccc

2. `background-color`

元素背景颜色

3. `font-size`

元素内部文字的尺寸大小

1) 像素尺寸 px
2) 相对单位 em 相对父元素的字体大小 

每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小；若果没有父元素(即html元素)，则使用基准字号，即浏览器中设置的字体大小

>user agent:  UA, 用户代理（浏览器）

4. `font-weight`

文字粗细程度，可以取值数字，可以取值为预设值

**预设值**

normal-->400 (不加粗)
bold-->700 (加粗)

> strong元素默认显示加粗字体

5. `font-family`

文字类型

必须用户计算机中存在的字体才会有效

使用多个字体，以匹配不同环境

最后一般会加上`sans-serif`,非衬线字体。 当用户计算机未安装指定的所有字体时，使用计算机自带字体

6. `font-style`

字体样式，通常用它设置斜体

> i、em 元素默认样式是斜体; 实际使用中，通常用它表示一个图标

7. `text-decoration`

文本修饰，给文本加斜线(删除线、下划线等)

> a元素默认带有下划线；  del元素 表示错误内容 默认带有删除线； s元素 表示废弃/过期内容(比如商品原价等) 默认带有删除线

8. `text-indent`

表示首行文本缩进，可以写像素`px`，也可以写`em`

9. `line-height`

行高，每行文本的高度，该值越大，每行文本的距离越大

设置行高为容器的高度，可以让单行文本垂直居中

行高可以设置为纯数字，表示相对于当前元素的字体大小 [多行文字时推荐此写法]

10. width

宽度

11. `height`

高度

12. `letter-spacing`

文字间隙

13. `text-align`

文字水平对齐样式，默认左对齐

# 选择器

选择器： 帮助你精准的选中想要的元素

## 简单选择器

1. ID选择器

2. 元素选择器

3. 类选择器

4. 通配符选择器

`*` : 表示选择所有

5. 属性选择器

根据属性名和属性值选择

```css
/* 选中所有具有href属性的元素 */
[href] {
    color: red;
}

/* 选中href属性=https://www.baidu.com的元素 */
[href="https://www.baidu.com"] {
    color: blue;
}

```

更多写法参见官方文档： https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Attribute_selectors

6. 伪类选择器

选中某些元素的某种状态,书写格式： `:`

`link`: 超链接未访问时的状态

`visited`: 超链接点击后的状态

`hover` : 鼠标悬停状态

`active`: 激活状态，鼠标按下时的状态

书写顺序： 爱恨法则 L V H A 

```css
/* 选中鼠标悬停时的a元素 */
a:hover{
    color:red;
}

/* 鼠标按下时的a元素 */
a:active {
    color: blue;
}

a:link {
    color: black;
}

a:visited {
    color: green
}
```

7. 伪元素选择器

书写格式： `::`

before

after

```css
/* 在span元素前面加"《" 后面加 "》" content为before和after 伪元素选择器特有的属性 */
span::before {
    content: " 《"; 
    color: red;
}

span::before {
    content: "》 "; 
    color: red;
}

```

## 选择器的组合

1. 并且

将两个选择器连着写，中间不加空格

```css

/* 选中class=red的p元素 */
p.red {
    color: red;
}

```

2. 后代元素 —— 空格

```css

/* 选中class=red后代的li元素 */
.red li {
    color: red;
}

```

3. 子元素 —— >

```css

/* 选中class=abc的子元素中class=bcd的元素 */
.abc>.bcd {
    color: red;
}

```

4. 相邻兄弟元素 —— +

```css

/* 选中class=special的元素下一个兄弟li元素 */
.special+li {
    color: red;
}
```

5. 后面出现的所有兄弟元素 —— ~

```css

/* 选中class=special的元素后面所有的兄弟li元素 */
.special~li {
    color: red;
}
```

**CSS选择器中不提供选择元素之前的选择器，跟CSS渲染有关**

## 选择器的并列

多个选择器用逗号分隔

语法糖(Syntactic sugar): 指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。

```css

.special~li {
    color: red;
}

.p {
    color: red;
}
```

可以写成：

```css

.special~li, p{
    color: red;
}
```

# 层叠

声明冲突： 同一个样式，多次应用到同一个元素

层叠： 解决声明冲突的过程，浏览器自动处理（权重计算）

冲突最终值只能胜出一个

## 比较重要性

重要性由高到低： 

> 作者样式表： 开发者书写的样式

1) 作者样式表中的`!important`样式
2) 作者样式表的普通样式
3) 浏览器默认样式表中的样式

## 比较特殊性

总体规则： 选择器选择的范围越窄，越特殊

具体规则： 通过选择器计算出一个四位数(XXXX)，值越大表示越特殊

1. 千位数： 如果是内联样式，记1，否则0
2. 百位数： 等于选择器中所有id选择器的数量
3. 十位数： 等于选择器中所有类选择器、属性选择器、伪类选择器的数量
4. 个位数： 等于选择器中所有元素选择器、伪元素选择器的数量

**此四位数不是严格意义上的四位数，不会逢十进一，而是逢256进一**

## 比较源次序

代码书写靠后的胜出

## 应用

1. 重置样式表

    书写一些作者样式，覆盖浏览器的默认样式，解决不同浏览器默认样式不同使界面显示不同的问题。

    常见的重置样式表： normalize.css、 reset.css、 meyer.css

2. 爱恨法则

    link > visited > hover > active

# 继承

子元素会继承父元素的某些CSS属性

通常跟字体相关的属性都能被继承

# 属性值的计算过程

浏览器是一个元素一个元素依次渲染页面的，顺序按照页面文档的树形目录结构

渲染每个元素的前提条件： 该元素的所有CSS属性必须有值

一个元素从所有属性都没有值，到所有的属性都有值，这个计算过程叫做属性值计算过程。

## 计算步骤

1. 确定声明值

    声明值： 开发者写的样式或者浏览器默认的样式

    参考样式表中没有冲突的声明直接作为CSS属性值

2. 层叠冲突

    对样式表中有冲突的声明使用层叠规则，确定CSS属性值

3. 使用继承

    对仍然没有值的属性，若可以继承则继承父元素的值

4. 使用默认值

    对仍然没有值的属性使用默认值，每个CSS属性都有自己的默认值

特殊的两个CSS取值：

- `inherit`: 手动（强制）继承，将父元素的值取出应用到该元素
- `initial`: 初始值，将该属性设置为默认值 

# 盒模型

box: 盒子，每个元素在页面中都会生成一个矩形区域(盒子)

盒子类型： 

1. 行盒， `display=inline`的元素
2. 块盒， `display=block`的元素

行盒在页面中不换行，块盒独占一行

浏览器默认样式设置的块盒： 容器元素(div header footer...)、h1~h6、p

常见的行盒： span、 a、 img、video、audio

## 盒子的组成部分

无论是行盒还是块盒都由下面几个部分组成，从内到外分别是：

1. 内容 content

    `width`、 `height` 设置的是盒子内容的宽度和高度

    内容部分通常叫做整个盒子的**内容盒 content-box**

2. 填充 padding

    盒子边框到盒子内容的距离

    `padding-left` `padding-right` `padding-top` `padding-bottom`

    `padding` 简写属性

    `padding: 上 右 下 左`

    填充区+内容区叫做 **填充盒 padding-box** 

3. 边框 border

    边框 = 边框样式 + 边框宽度 + 边框颜色

    边框样式：`border-style` (可以取`solid` `dotted` `dashed`等样式值) 简写属性
    边框宽度: `border-width`  简写属性
    边框颜色: `border-color` 默认为字体颜色

    border: 边框宽度 边框样式 边框颜色

    边框 + 填充区 + 内容区 = **边框盒 border-box**

4. 外边距 margin

    边框到其他盒子的距离

    `margin-top` `margin-left` `margin-right` `margin-bottom`

    可简写成： `margin: 上 由 下 左`

# 盒模型的应用

## 改变框高范围

默认情况下，width和height设置的是内容盒的宽高

> 页面重构师： 将psd文件（设计稿）制作为静态页面

衡量页面设计稿尺寸的时候，往往使用的是边框盒，但设置width和height则设置的是内容盒

解决办法：

1. 精确计算
2. 只用CSS3中的`box-sizing`指定宽高的影响范围

## 改变背景覆盖范围

默认情况下背景覆盖边框盒

可以通过`background-clip`修改边框覆盖范围

## 溢出处理

`overflow : visible` 可见(默认值)

`overflow : hidden` 溢出部分隐藏

`overflow : scroll` 生成滚动条

`overflow-y : scroll` 竖向滚动条

`overflow-x : scroll` 横向滚动条

`overflow : auto` 自动控制出现滚动条

## 断词规则

`word-break`, 影响文字在什么位置被截断换行，有以下值：

normal: 普通。 CJK(中日韩)字符在文字位置截断，非CJK字符在单词位置截断

break-all： 截断所有。 所有字符在文字处截断，比如英文会在单词中截断

keep-all: 保持所有。 所有字符在单词间截断，中文字符若无空格则会挤在一行

## 空白处理

`white-space: nowrap`： 不换行

常用处理方式： 

```css

li{
    white-space: nowrap; /* 不换行 */
    overflow: hidden; /* 溢出隐藏 */
    text-overflow: ellipsis; /* 文字部分溢出用圆点代替 */
}

```

# 行盒的盒模型

常见的行盒： 包含具体内容的元素

`span` `strong` `em` `i` `img` `video` `audio`

## 显著特点

1. 盒子沿着内容延伸
2. 行盒不能设置宽高，因为行盒的宽高是根据内容来的，只能通过字体大小、行高、字体类型等间接调整
3. 内边距(填充区)

    水平方向有效，垂直方向只会影响背景，不会实际占据空间 (内容盒不会垂直方向移动)

4. 边框

    水平方向有效，垂直方向可以看见效果，但不会实际占据空间(内容盒不会垂直方向移动)

5. 外边距

    水平方向有效，垂直方向不会实际占据空间(内容盒不会垂直方向移动)

## 行块盒

`display: inline-block` 的盒子

1. 不独占一行
2. 盒模型中所有尺寸都有效

## 空白折叠

空白折叠发生在行盒(行块盒)内部或行盒之间(行块盒)

## 可替换元素和非可替换元素

大部分元素页面上显示的结果取决于元素内容，称为**非可替换元素**

少部分元素页面上显示的结果取决于元素属性，称为**可替换元素**

可替换元素： img video audio

绝大部分可替换元素为行盒

可替换元素类似于行块盒，盒模型中所有尺寸都有效。

图片`img`特殊性属性：`object-fit`

    - fill : 默认值，表示填充，不能保证图片的宽高比

    - cover: 保证填充满区域并保持宽高比，但会丢失部分图片信息

    - contain: 保持图片宽高比并显示图片所有信息

# 常规流

盒模型： 规定单个盒子的规则

视觉格式化模型(布局规则)： 页面中的多个盒子排列规则

视觉格式化模型大体上将页面中盒子的排列分为三种方式

1. 常规流
2. 浮动
3. 定位

## 常规流布局

常规流、文档流、普通文档流、常规文档流

所有元素默认情况下都属于常规流布局

总体规则： 块盒独占一行，行盒水平依次排序

包含块(containing block): 每个盒子都有它的包含块，包含块决定了盒子的排列区域

绝大部分情况下： 盒子的包含块为其父元素的内容盒

**块盒**

1. 每个块盒的总宽度必须 = 包含块的宽度(父元素内容盒的宽度)

    **以下margin为水平方向的margin**

    宽度的默认值是`auto`,表示将剩余空间吸收掉

    `margin`的默认值是`0`,设置为`auto`时会根据实际情况计算

    宽度吸收能力强于`margin`，当两者为`auto`时，宽度默认撑满

    若宽度、边框、内边距、外边距计算后仍然有剩余空间，则剩余空间会被`margin-right` 全部吸收

    在常规流中，若要使块盒在包含块中居中，可以先固定宽度，然后左右`margin`设置为`0`

2. 每个块盒垂直方向上的`auto`值

    `height: auto`: 适应内容的高度

    `margin:auto`: 表示为0

3. 百分比取值

    `padding`、`宽高`、`margin` 可以取值为百分比

    以上所有的百分比(垂直方向和竖直方向)都是相对于包含块的宽度，与包含块的高度无关

    高度的百分比：

    1). 包含块的高度未设置而是取决于子元素的高度时，设置百分比无效

    2). 包含块的高度设置为定值时，百分比相对于父元素的高度

4. 上下外边距的合并

    两个常规流块盒，上下外边距相邻会进行合并，取两个外边距最大值

    父子元素之间外边距相邻时也会出现合并的现象，若不想合并，可以设置父元素的`border`或者`padding`

# 浮动

视觉格式化模型，大体上将页面中盒子的排列分三种方式：

1. 常规流
2. 浮动
3. 定位

## 应用场景

1. 文字环绕
2. 横向排列

## 浮动的基本特点


修改CSS`float`属性值为:

- `left`: 左浮动，元素靠上靠左
- `right`: 右浮动， 元素靠上靠右
- 默认为`none`

1. 当一个元素设置浮动后，元素必定为块盒(更改display属性为block)
2. 浮动元素的包含块和常规流一样，为父元素的内容盒

## 盒子尺寸

1. 宽度为`auto`时，表示适应内容宽度，即宽度由内容撑开
2. 高度为`auto`时，与常规流一致，适应内容高度
3. `margin`为`auto`时，表示为0
4. 边框、内边距、百分比的设置与常规流一样

## 盒子排列

1. 左浮动的盒子靠上靠左
2. 右浮动的盒子靠上靠右
3. 浮动盒子在包含块中排列，会避开常规流盒子
4. 常规流块盒在排列时会无视浮动盒子
5. 行盒排列时会避开浮动盒子
6. 浮动盒子不会发生外边距合并

## 高度坍塌

高度坍塌根源： 常规流盒子的自动高度在计算时，不会考虑浮动盒子

解决方式： 清除浮动，涉及CSS属性`clear`,取值为：

- 默认值: none
- `left`: 清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
- `right`: 清除右浮动，该元素必须出现在前面所有右浮动盒子的下方
- `both`: 清除所有浮动，该元素必须出现在前面所有浮动盒子的下方

方案1：

在**浮动元素后面**添加空元素，为其设置样式`clear: both`

方案2： 

    为发生高度坍塌的容器添加伪元素： 

    ```css
     .clearfix::after {
         content: "";
         display: block;
         clear: both;
     }
    ```






---

参考视频

 https://www.bilibili.com/video/av57100756?from=search&seid=2646463889570770154 (2019年 HTML+CSS 零基础权威入学宝典【渡一教育】p16~p58)